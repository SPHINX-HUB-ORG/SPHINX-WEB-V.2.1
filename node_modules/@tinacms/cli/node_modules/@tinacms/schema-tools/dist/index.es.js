import * as yup from "yup";
import z$1, { z, ZodError } from "zod";
function addNamespaceToSchema(maybeNode, namespace = []) {
  if (typeof maybeNode === "string") {
    return maybeNode;
  }
  if (typeof maybeNode === "boolean") {
    return maybeNode;
  }
  const newNode = { ...maybeNode };
  const keys = Object.keys(maybeNode);
  Object.values(maybeNode).map((m, index) => {
    const key = keys[index];
    if (Array.isArray(m)) {
      newNode[key] = m.map((element) => {
        if (!element) {
          return;
        }
        if (!element.hasOwnProperty("name")) {
          return element;
        }
        const value = element.name || element.value;
        return addNamespaceToSchema(element, [...namespace, value]);
      });
    } else {
      if (!m) {
        return;
      }
      if (!m.hasOwnProperty("name")) {
        newNode[key] = m;
      } else {
        newNode[key] = addNamespaceToSchema(m, [...namespace, m.name]);
      }
    }
  });
  return { ...newNode, namespace };
}
function assertShape(value, yupSchema, errorMessage) {
  const shape = yupSchema(yup);
  try {
    shape.validateSync(value);
  } catch (e) {
    const message = errorMessage || `Failed to assertShape - ${e.message}`;
    throw new Error(message);
  }
}
const lastItem = (arr) => {
  if (typeof arr === "undefined") {
    throw new Error("Can not call lastItem when arr is undefined");
  }
  return arr[arr.length - 1];
};
const capitalize = (s) => {
  if (typeof s !== "string")
    return "";
  return s.charAt(0).toUpperCase() + s.slice(1);
};
const generateNamespacedFieldName = (names, suffix = "") => {
  return (suffix ? [...names, suffix] : names).map(capitalize).join("");
};
const NAMER = {
  dataFilterTypeNameOn: (namespace) => {
    return generateNamespacedFieldName(namespace, "_FilterOn");
  },
  dataFilterTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Filter");
  },
  dataMutationTypeNameOn: (namespace) => {
    return generateNamespacedFieldName(namespace, "_MutationOn");
  },
  dataMutationTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Mutation");
  },
  updateName: (namespace) => {
    return "update" + generateNamespacedFieldName(namespace, "Document");
  },
  createName: (namespace) => {
    return "create" + generateNamespacedFieldName(namespace, "Document");
  },
  queryName: (namespace) => {
    return "get" + generateNamespacedFieldName(namespace, "Document");
  },
  generateQueryListName: (namespace) => {
    return "get" + generateNamespacedFieldName(namespace, "List");
  },
  fragmentName: (namespace) => {
    return generateNamespacedFieldName(namespace, "") + "Parts";
  },
  collectionTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Collection");
  },
  documentTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Document");
  },
  dataTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "");
  },
  referenceConnectionType: (namespace) => {
    return generateNamespacedFieldName(namespace, "Connection");
  },
  referenceConnectionEdgesTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "ConnectionEdges");
  }
};
function hasDuplicates(array) {
  if (!array) {
    return false;
  } else {
    return new Set(array).size !== array.length;
  }
}
class TinaSchema {
  constructor(config) {
    this.config = config;
    this.getIsTitleFieldName = (collection) => {
      const col = this.getCollection(collection);
      const field = col == null ? void 0 : col.fields.find((x) => x.type === "string" && x.isTitle);
      return field == null ? void 0 : field.name;
    };
    this.getCollectionsByName = (collectionNames) => {
      return this.schema.collections.filter((collection) => collectionNames.includes(collection.name));
    };
    this.getAllCollectionPaths = () => {
      const paths = this.getCollections().map((collection) => `${collection.path}${collection.match || ""}`);
      return paths;
    };
    this.getCollection = (collectionName) => {
      const collection = this.schema.collections.find((collection2) => collection2.name === collectionName);
      if (!collection) {
        throw new Error(`Expected to find collection named ${collectionName}`);
      }
      const extraFields = {};
      const templateInfo = this.getTemplatesForCollectable(collection);
      switch (templateInfo.type) {
        case "object":
          extraFields["fields"] = templateInfo.template.fields;
          break;
        case "union":
          extraFields["templates"] = templateInfo.templates;
          break;
      }
      return {
        slug: collection.name,
        ...extraFields,
        ...collection,
        format: collection.format || "md"
      };
    };
    this.getCollections = () => {
      return this.schema.collections.map((collection) => this.getCollection(collection.name)) || [];
    };
    this.getGlobalTemplate = (templateName) => {
      var _a;
      const globalTemplate = (_a = this.schema.templates) == null ? void 0 : _a.find((template) => template.name === templateName);
      if (!globalTemplate) {
        throw new Error(`Expected to find global template of name ${templateName}`);
      }
      return globalTemplate;
    };
    this.getCollectionByFullPath = (filepath) => {
      const collection = this.getCollections().find((collection2) => {
        return filepath.replace("\\", "/").startsWith(collection2.path);
      });
      if (!collection) {
        throw new Error(`Unable to find collection for file at ${filepath}`);
      }
      return collection;
    };
    this.getCollectionAndTemplateByFullPath = (filepath, templateName) => {
      let template;
      const collection = this.getCollections().find((collection2) => {
        return filepath.replace("\\", "/").startsWith(collection2.path);
      });
      if (!collection) {
        throw new Error(`Unable to find collection for file at ${filepath}`);
      }
      const templates = this.getTemplatesForCollectable(collection);
      if (templates.type === "union") {
        if (templateName) {
          template = templates.templates.find((template2) => lastItem(template2.namespace) === templateName);
          if (!template) {
            throw new Error(`Unable to determine template for item at ${filepath}`);
          }
        } else {
          throw new Error(`Unable to determine template for item at ${filepath}, no template name provided for collection with multiple templates`);
        }
      }
      if (templates.type === "object") {
        template = templates.template;
      }
      if (!template) {
        throw new Error(`Something went wrong while trying to determine template for ${filepath}`);
      }
      return { collection, template };
    };
    this.getTemplateForData = ({
      data,
      collection
    }) => {
      const templateInfo = this.getTemplatesForCollectable(collection);
      switch (templateInfo.type) {
        case "object":
          return templateInfo.template;
        case "union":
          assertShape(data, (yup2) => yup2.object({ _template: yup2.string().required() }));
          const template = templateInfo.templates.find((template2) => template2.namespace[template2.namespace.length - 1] === data._template);
          if (!template) {
            throw new Error(`Expected to find template named '${data._template}' for collection '${lastItem(collection.namespace)}'`);
          }
          return template;
      }
    };
    this.isMarkdownCollection = (collectionName) => {
      const collection = this.getCollection(collectionName);
      const format = collection.format;
      if (!format) {
        return true;
      }
      if (["markdown", "md"].includes(format)) {
        return true;
      }
      return false;
    };
    this.getTemplatesForCollectable = (collection) => {
      let extraFields = [];
      if (collection.references) {
        extraFields = collection.references;
      }
      if (collection.fields) {
        const template = typeof collection.fields === "string" ? this.getGlobalTemplate(collection.fields) : collection;
        if (typeof template.fields === "string" || typeof template.fields === "undefined") {
          throw new Error("Exptected template to have fields but none were found");
        }
        return {
          namespace: collection.namespace,
          type: "object",
          template: {
            ...template,
            fields: [...template.fields, ...extraFields]
          }
        };
      } else {
        if (collection.templates) {
          return {
            namespace: collection.namespace,
            type: "union",
            templates: collection.templates.map((templateOrTemplateString) => {
              const template = typeof templateOrTemplateString === "string" ? this.getGlobalTemplate(templateOrTemplateString) : templateOrTemplateString;
              return {
                ...template,
                fields: [...template.fields, ...extraFields]
              };
            })
          };
        } else {
          throw new Error(`Expected either fields or templates array to be defined on collection ${collection.namespace.join("_")}`);
        }
      }
    };
    this.schema = config;
  }
}
const resolveField = ({ namespace, ...field }, schema) => {
  var _a;
  field.parentTypename = NAMER.dataTypeName(namespace.filter((_, i) => i < namespace.length - 1));
  const extraFields = field.ui || {};
  switch (field.type) {
    case "number":
      return {
        component: "number",
        ...field,
        ...extraFields
      };
    case "datetime":
      return {
        component: "date",
        ...field,
        ...extraFields
      };
    case "boolean":
      return {
        component: "toggle",
        ...field,
        ...extraFields
      };
    case "image":
      return {
        component: "image",
        clearable: true,
        ...field,
        ...extraFields
      };
    case "string":
      if (field.options) {
        if (field.list) {
          return {
            component: "checkbox-group",
            ...field,
            ...extraFields,
            options: field.options
          };
        }
        return {
          component: "select",
          ...field,
          ...extraFields,
          options: [{ label: `Choose an option`, value: "" }, ...field.options]
        };
      }
      if (field.list) {
        return {
          component: "list",
          field: {
            component: "text"
          },
          ...field,
          ...extraFields
        };
      }
      return {
        component: "text",
        ...field,
        ...extraFields
      };
    case "object":
      const templateInfo = schema.getTemplatesForCollectable({
        ...field,
        namespace
      });
      if (templateInfo.type === "object") {
        return {
          ...field,
          component: field.list ? "group-list" : "group",
          fields: templateInfo.template.fields.map((field2) => resolveField(field2, schema)),
          ...extraFields
        };
      } else if (templateInfo.type === "union") {
        const templates2 = {};
        const typeMap2 = {};
        templateInfo.templates.forEach((template) => {
          const extraFields2 = template.ui || {};
          const templateName = lastItem(template.namespace);
          typeMap2[templateName] = NAMER.dataTypeName(template.namespace);
          templates2[lastItem(template.namespace)] = {
            label: template.label || templateName,
            key: templateName,
            fields: template.fields.map((field2) => resolveField(field2, schema)),
            ...extraFields2
          };
          return true;
        });
        return {
          ...field,
          typeMap: typeMap2,
          component: field.list ? "blocks" : "not-implemented",
          templates: templates2,
          ...extraFields
        };
      } else {
        throw new Error(`Unknown object for resolveField function`);
      }
    case "rich-text":
      const templates = {};
      (_a = field.templates) == null ? void 0 : _a.forEach((template) => {
        if (typeof template === "string") {
          throw new Error(`Global templates not yet supported for rich-text`);
        } else {
          const extraFields2 = template.ui || {};
          const templateName = lastItem(template.namespace);
          NAMER.dataTypeName(template.namespace);
          templates[lastItem(template.namespace)] = {
            label: template.label || templateName,
            key: templateName,
            inline: template.inline,
            name: templateName,
            fields: template.fields.map((field2) => resolveField(field2, schema)),
            ...extraFields2
          };
          return true;
        }
      });
      return {
        ...field,
        templates: Object.values(templates),
        component: "rich-text",
        ...extraFields
      };
    case "reference":
      return {
        ...field,
        component: "reference",
        ...extraFields
      };
    default:
      throw new Error(`Unknown field type ${field.type}`);
  }
};
const resolveForm = ({
  collection,
  basename,
  template,
  schema
}) => {
  return {
    id: basename,
    label: collection.label,
    name: basename,
    fields: template.fields.map((field) => {
      return resolveField(field, schema);
    })
  };
};
const parseZodError = ({ zodError }) => {
  var _a, _b, _c, _d;
  const errors = zodError.flatten((issue) => {
    const moreInfo = [];
    if (issue.code === "invalid_union") {
      issue.unionErrors.map((unionError) => {
        moreInfo.push(parseZodError({ zodError: unionError }));
      });
    }
    const errorMessage = `Error ${issue == null ? void 0 : issue.message} at path ${issue.path.join(".")}`;
    const errorMessages = [errorMessage, ...moreInfo];
    return {
      errors: errorMessages
    };
  });
  const formErrors = errors.formErrors.flatMap((x) => x.errors);
  const parsedErrors = [
    ...((_b = (_a = errors.fieldErrors) == null ? void 0 : _a.collections) == null ? void 0 : _b.flatMap((x) => x.errors)) || [],
    ...((_d = (_c = errors.fieldErrors) == null ? void 0 : _c.config) == null ? void 0 : _d.flatMap((x) => x.errors)) || [],
    ...formErrors
  ];
  return parsedErrors;
};
const name = z.string({
  required_error: "Name is required but not provided",
  invalid_type_error: "Name must be a string"
});
const TypeName = [
  "string",
  "boolean",
  "number",
  "datetime",
  "image",
  "object",
  "reference",
  "rich-text"
];
const typeTypeError = `type must be one of ${TypeName.join(", ")}`;
const typeRequiredError = `type is required and must be one of ${TypeName.join(", ")}`;
const nameProp = z.string({
  required_error: "name must be provided",
  invalid_type_error: "name must be a sting"
});
const Option = z.union([z.string(), z.object({ label: z.string(), value: z.string() })], {
  errorMap: () => {
    return {
      message: "Invalid option array. Must be a string[] or {label: string, value: string}[]"
    };
  }
});
const TinaField = z.object({
  name: nameProp,
  label: z.string().optional(),
  description: z.string().optional(),
  required: z.boolean().optional()
});
const FieldWithList = TinaField.extend({ list: z.boolean().optional() });
const TinaScalerBase = FieldWithList.extend({
  options: z.array(Option).optional()
});
const StringField = TinaScalerBase.extend({
  type: z.literal("string", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  }),
  isTitle: z.boolean().optional()
});
const BooleanField = TinaScalerBase.extend({
  type: z.literal("boolean", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  })
});
const NumberField = TinaScalerBase.extend({
  type: z.literal("number", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  })
});
const ImageField = TinaScalerBase.extend({
  type: z.literal("image", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  })
});
const DateTimeField = TinaScalerBase.extend({
  type: z.literal("datetime", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  }),
  dateFormat: z.string().optional(),
  timeFormat: z.string().optional()
});
const ReferenceField = FieldWithList.extend({
  type: z.literal("reference", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  })
});
const TinaFieldZod = z.lazy(() => {
  const TemplateTemp = z.object({
    label: z.string(),
    name: nameProp,
    fields: z.array(TinaFieldZod)
  }).refine((val) => {
    var _a;
    return !hasDuplicates((_a = val.fields) == null ? void 0 : _a.map((x) => x.name));
  }, {
    message: "Fields must have a unique name"
  });
  const ObjectField = FieldWithList.extend({
    type: z.literal("object", {
      invalid_type_error: typeTypeError,
      required_error: typeRequiredError
    }),
    fields: z.array(TinaFieldZod).min(1).optional().refine((val) => !hasDuplicates(val == null ? void 0 : val.map((x) => x.name)), {
      message: "Fields must have a unique name"
    }),
    templates: z.array(TemplateTemp).min(1).optional().refine((val) => !hasDuplicates(val == null ? void 0 : val.map((x) => x.name)), {
      message: "Templates must have a unique name"
    })
  });
  const RichTextField = FieldWithList.extend({
    type: z.literal("rich-text", {
      invalid_type_error: typeTypeError,
      required_error: typeRequiredError
    }),
    templates: z.array(TemplateTemp).optional().refine((val) => !hasDuplicates(val == null ? void 0 : val.map((x) => x.name)), {
      message: "Templates must have a unique name"
    })
  });
  return z.discriminatedUnion("type", [
    StringField,
    BooleanField,
    NumberField,
    ImageField,
    DateTimeField,
    ReferenceField,
    ObjectField,
    RichTextField
  ], {
    errorMap: (issue, ctx) => {
      var _a;
      if (issue.code === "invalid_union_discriminator") {
        return {
          message: `Invalid \`type\` property. In the schema is 'type: ${(_a = ctx.data) == null ? void 0 : _a.type}' and expected one of ${TypeName.join(", ")}`
        };
      }
      return {
        message: issue.message
      };
    }
  }).superRefine((val, ctx) => {
    if (val.type === "string") {
      if (val.isTitle) {
        if (val.list) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: "You can not have `list: true` when using `isTitle`"
          });
        }
        if (!val.required) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: "You must have { required: true } when using `isTitle`"
          });
        }
      }
    }
    if (val.type === "object") {
      const message = "Must provide one of templates or fields in your collection";
      let isValid = Boolean(val == null ? void 0 : val.templates) || Boolean(val == null ? void 0 : val.fields);
      if (!isValid) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message
        });
        return false;
      } else {
        isValid = !((val == null ? void 0 : val.templates) && (val == null ? void 0 : val.fields));
        if (!isValid) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message
          });
        }
        return isValid;
      }
    }
    return true;
  });
});
const tinaConfigKey = z$1.object({
  publicFolder: z$1.string(),
  mediaRoot: z$1.string()
}).strict().optional();
const tinaConfigZod = z$1.object({
  media: z$1.object({
    tina: tinaConfigKey,
    loadCustomStore: z$1.function().optional()
  }).optional()
});
const validateTinaCloudSchemaConfig = (config) => {
  const newConfig = tinaConfigZod.parse(config);
  return newConfig;
};
const FORMATS = ["json", "md", "markdown", "mdx"];
const Template = z.object({
  label: z.string({
    invalid_type_error: "label must be a string",
    required_error: "label was not provided but is required"
  }),
  name,
  fields: z.array(TinaFieldZod)
}).refine((val) => {
  var _a;
  return !hasDuplicates((_a = val.fields) == null ? void 0 : _a.map((x) => x.name));
}, {
  message: "Fields must have a unique name"
});
const TinaCloudCollectionBase = z.object({
  label: z.string().optional(),
  name,
  format: z.enum(FORMATS).optional()
});
const TinaCloudCollection = TinaCloudCollectionBase.extend({
  fields: z.array(TinaFieldZod).min(1).optional().refine((val) => !hasDuplicates(val == null ? void 0 : val.map((x) => x.name)), {
    message: "Fields must have a unique name"
  }).refine((val) => {
    const arr = (val == null ? void 0 : val.filter((x) => x.type === "string" && x.isTitle)) || [];
    return arr.length < 2;
  }, {
    message: "Fields can only have one use of `isTitle`"
  }),
  templates: z.array(Template).min(1).optional().refine((val) => !hasDuplicates(val == null ? void 0 : val.map((x) => x.name)), {
    message: "Templates must have a unique name"
  })
}).refine((val) => {
  let isValid = Boolean(val == null ? void 0 : val.templates) || Boolean(val == null ? void 0 : val.fields);
  if (!isValid) {
    return false;
  } else {
    isValid = !((val == null ? void 0 : val.templates) && (val == null ? void 0 : val.fields));
    return isValid;
  }
}, { message: "Must provide one of templates or fields in your collection" });
const TinaCloudSchemaZod = z.object({
  collections: z.array(TinaCloudCollection),
  config: tinaConfigZod.optional()
}).superRefine((val, ctx) => {
  var _a;
  if (hasDuplicates(val.collections.map((x) => x.name))) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: "can not have two collections with the same name",
      fatal: true
    });
  }
  const media = (_a = val == null ? void 0 : val.config) == null ? void 0 : _a.media;
  if (media && media.tina && media.loadCustomStore) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: "can not have both loadCustomStore and tina. Must use one or the other",
      fatal: true,
      path: ["config", "media"]
    });
  }
});
class TinaSchemaValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "TinaSchemaValidationError";
  }
}
const validateSchema = ({
  config
}) => {
  try {
    TinaCloudSchemaZod.parse(config);
  } catch (e) {
    if (e instanceof ZodError) {
      const errors = parseZodError({ zodError: e });
      throw new TinaSchemaValidationError(errors.join(", \n"));
    } else {
      throw new Error(e);
    }
  }
};
export { TinaSchema, TinaSchemaValidationError, addNamespaceToSchema, resolveField, resolveForm, validateSchema, validateTinaCloudSchemaConfig };
