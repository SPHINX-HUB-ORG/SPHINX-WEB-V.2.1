(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("yup"), require("zod")) : typeof define === "function" && define.amd ? define(["exports", "yup", "zod"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global["@tinacms/schema-tools"] = {}, global.NOOP, global.NOOP));
})(this, function(exports2, yup, z) {
  "use strict";
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule)
      return e;
    var n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
    if (e) {
      Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function() {
              return e[k];
            }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }
  var yup__namespace = /* @__PURE__ */ _interopNamespace(yup);
  var z__default = /* @__PURE__ */ _interopDefaultLegacy(z);
  function addNamespaceToSchema(maybeNode, namespace = []) {
    if (typeof maybeNode === "string") {
      return maybeNode;
    }
    if (typeof maybeNode === "boolean") {
      return maybeNode;
    }
    const newNode = { ...maybeNode };
    const keys = Object.keys(maybeNode);
    Object.values(maybeNode).map((m, index) => {
      const key = keys[index];
      if (Array.isArray(m)) {
        newNode[key] = m.map((element) => {
          if (!element) {
            return;
          }
          if (!element.hasOwnProperty("name")) {
            return element;
          }
          const value = element.name || element.value;
          return addNamespaceToSchema(element, [...namespace, value]);
        });
      } else {
        if (!m) {
          return;
        }
        if (!m.hasOwnProperty("name")) {
          newNode[key] = m;
        } else {
          newNode[key] = addNamespaceToSchema(m, [...namespace, m.name]);
        }
      }
    });
    return { ...newNode, namespace };
  }
  function assertShape(value, yupSchema, errorMessage) {
    const shape = yupSchema(yup__namespace);
    try {
      shape.validateSync(value);
    } catch (e) {
      const message = errorMessage || `Failed to assertShape - ${e.message}`;
      throw new Error(message);
    }
  }
  const lastItem = (arr) => {
    if (typeof arr === "undefined") {
      throw new Error("Can not call lastItem when arr is undefined");
    }
    return arr[arr.length - 1];
  };
  const capitalize = (s) => {
    if (typeof s !== "string")
      return "";
    return s.charAt(0).toUpperCase() + s.slice(1);
  };
  const generateNamespacedFieldName = (names, suffix = "") => {
    return (suffix ? [...names, suffix] : names).map(capitalize).join("");
  };
  const NAMER = {
    dataFilterTypeNameOn: (namespace) => {
      return generateNamespacedFieldName(namespace, "_FilterOn");
    },
    dataFilterTypeName: (namespace) => {
      return generateNamespacedFieldName(namespace, "Filter");
    },
    dataMutationTypeNameOn: (namespace) => {
      return generateNamespacedFieldName(namespace, "_MutationOn");
    },
    dataMutationTypeName: (namespace) => {
      return generateNamespacedFieldName(namespace, "Mutation");
    },
    updateName: (namespace) => {
      return "update" + generateNamespacedFieldName(namespace, "Document");
    },
    createName: (namespace) => {
      return "create" + generateNamespacedFieldName(namespace, "Document");
    },
    queryName: (namespace) => {
      return "get" + generateNamespacedFieldName(namespace, "Document");
    },
    generateQueryListName: (namespace) => {
      return "get" + generateNamespacedFieldName(namespace, "List");
    },
    fragmentName: (namespace) => {
      return generateNamespacedFieldName(namespace, "") + "Parts";
    },
    collectionTypeName: (namespace) => {
      return generateNamespacedFieldName(namespace, "Collection");
    },
    documentTypeName: (namespace) => {
      return generateNamespacedFieldName(namespace, "Document");
    },
    dataTypeName: (namespace) => {
      return generateNamespacedFieldName(namespace, "");
    },
    referenceConnectionType: (namespace) => {
      return generateNamespacedFieldName(namespace, "Connection");
    },
    referenceConnectionEdgesTypeName: (namespace) => {
      return generateNamespacedFieldName(namespace, "ConnectionEdges");
    }
  };
  function hasDuplicates(array) {
    if (!array) {
      return false;
    } else {
      return new Set(array).size !== array.length;
    }
  }
  class TinaSchema {
    constructor(config) {
      this.config = config;
      this.getIsTitleFieldName = (collection) => {
        const col = this.getCollection(collection);
        const field = col == null ? void 0 : col.fields.find((x) => x.type === "string" && x.isTitle);
        return field == null ? void 0 : field.name;
      };
      this.getCollectionsByName = (collectionNames) => {
        return this.schema.collections.filter((collection) => collectionNames.includes(collection.name));
      };
      this.getAllCollectionPaths = () => {
        const paths = this.getCollections().map((collection) => `${collection.path}${collection.match || ""}`);
        return paths;
      };
      this.getCollection = (collectionName) => {
        const collection = this.schema.collections.find((collection2) => collection2.name === collectionName);
        if (!collection) {
          throw new Error(`Expected to find collection named ${collectionName}`);
        }
        const extraFields = {};
        const templateInfo = this.getTemplatesForCollectable(collection);
        switch (templateInfo.type) {
          case "object":
            extraFields["fields"] = templateInfo.template.fields;
            break;
          case "union":
            extraFields["templates"] = templateInfo.templates;
            break;
        }
        return {
          slug: collection.name,
          ...extraFields,
          ...collection,
          format: collection.format || "md"
        };
      };
      this.getCollections = () => {
        return this.schema.collections.map((collection) => this.getCollection(collection.name)) || [];
      };
      this.getGlobalTemplate = (templateName) => {
        var _a;
        const globalTemplate = (_a = this.schema.templates) == null ? void 0 : _a.find((template) => template.name === templateName);
        if (!globalTemplate) {
          throw new Error(`Expected to find global template of name ${templateName}`);
        }
        return globalTemplate;
      };
      this.getCollectionByFullPath = (filepath) => {
        const collection = this.getCollections().find((collection2) => {
          return filepath.replace("\\", "/").startsWith(collection2.path);
        });
        if (!collection) {
          throw new Error(`Unable to find collection for file at ${filepath}`);
        }
        return collection;
      };
      this.getCollectionAndTemplateByFullPath = (filepath, templateName) => {
        let template;
        const collection = this.getCollections().find((collection2) => {
          return filepath.replace("\\", "/").startsWith(collection2.path);
        });
        if (!collection) {
          throw new Error(`Unable to find collection for file at ${filepath}`);
        }
        const templates = this.getTemplatesForCollectable(collection);
        if (templates.type === "union") {
          if (templateName) {
            template = templates.templates.find((template2) => lastItem(template2.namespace) === templateName);
            if (!template) {
              throw new Error(`Unable to determine template for item at ${filepath}`);
            }
          } else {
            throw new Error(`Unable to determine template for item at ${filepath}, no template name provided for collection with multiple templates`);
          }
        }
        if (templates.type === "object") {
          template = templates.template;
        }
        if (!template) {
          throw new Error(`Something went wrong while trying to determine template for ${filepath}`);
        }
        return { collection, template };
      };
      this.getTemplateForData = ({
        data,
        collection
      }) => {
        const templateInfo = this.getTemplatesForCollectable(collection);
        switch (templateInfo.type) {
          case "object":
            return templateInfo.template;
          case "union":
            assertShape(data, (yup2) => yup2.object({ _template: yup2.string().required() }));
            const template = templateInfo.templates.find((template2) => template2.namespace[template2.namespace.length - 1] === data._template);
            if (!template) {
              throw new Error(`Expected to find template named '${data._template}' for collection '${lastItem(collection.namespace)}'`);
            }
            return template;
        }
      };
      this.isMarkdownCollection = (collectionName) => {
        const collection = this.getCollection(collectionName);
        const format = collection.format;
        if (!format) {
          return true;
        }
        if (["markdown", "md"].includes(format)) {
          return true;
        }
        return false;
      };
      this.getTemplatesForCollectable = (collection) => {
        let extraFields = [];
        if (collection.references) {
          extraFields = collection.references;
        }
        if (collection.fields) {
          const template = typeof collection.fields === "string" ? this.getGlobalTemplate(collection.fields) : collection;
          if (typeof template.fields === "string" || typeof template.fields === "undefined") {
            throw new Error("Exptected template to have fields but none were found");
          }
          return {
            namespace: collection.namespace,
            type: "object",
            template: {
              ...template,
              fields: [...template.fields, ...extraFields]
            }
          };
        } else {
          if (collection.templates) {
            return {
              namespace: collection.namespace,
              type: "union",
              templates: collection.templates.map((templateOrTemplateString) => {
                const template = typeof templateOrTemplateString === "string" ? this.getGlobalTemplate(templateOrTemplateString) : templateOrTemplateString;
                return {
                  ...template,
                  fields: [...template.fields, ...extraFields]
                };
              })
            };
          } else {
            throw new Error(`Expected either fields or templates array to be defined on collection ${collection.namespace.join("_")}`);
          }
        }
      };
      this.schema = config;
    }
  }
  const resolveField = ({ namespace, ...field }, schema) => {
    var _a;
    field.parentTypename = NAMER.dataTypeName(namespace.filter((_, i) => i < namespace.length - 1));
    const extraFields = field.ui || {};
    switch (field.type) {
      case "number":
        return {
          component: "number",
          ...field,
          ...extraFields
        };
      case "datetime":
        return {
          component: "date",
          ...field,
          ...extraFields
        };
      case "boolean":
        return {
          component: "toggle",
          ...field,
          ...extraFields
        };
      case "image":
        return {
          component: "image",
          clearable: true,
          ...field,
          ...extraFields
        };
      case "string":
        if (field.options) {
          if (field.list) {
            return {
              component: "checkbox-group",
              ...field,
              ...extraFields,
              options: field.options
            };
          }
          return {
            component: "select",
            ...field,
            ...extraFields,
            options: [{ label: `Choose an option`, value: "" }, ...field.options]
          };
        }
        if (field.list) {
          return {
            component: "list",
            field: {
              component: "text"
            },
            ...field,
            ...extraFields
          };
        }
        return {
          component: "text",
          ...field,
          ...extraFields
        };
      case "object":
        const templateInfo = schema.getTemplatesForCollectable({
          ...field,
          namespace
        });
        if (templateInfo.type === "object") {
          return {
            ...field,
            component: field.list ? "group-list" : "group",
            fields: templateInfo.template.fields.map((field2) => resolveField(field2, schema)),
            ...extraFields
          };
        } else if (templateInfo.type === "union") {
          const templates2 = {};
          const typeMap2 = {};
          templateInfo.templates.forEach((template) => {
            const extraFields2 = template.ui || {};
            const templateName = lastItem(template.namespace);
            typeMap2[templateName] = NAMER.dataTypeName(template.namespace);
            templates2[lastItem(template.namespace)] = {
              label: template.label || templateName,
              key: templateName,
              fields: template.fields.map((field2) => resolveField(field2, schema)),
              ...extraFields2
            };
            return true;
          });
          return {
            ...field,
            typeMap: typeMap2,
            component: field.list ? "blocks" : "not-implemented",
            templates: templates2,
            ...extraFields
          };
        } else {
          throw new Error(`Unknown object for resolveField function`);
        }
      case "rich-text":
        const templates = {};
        (_a = field.templates) == null ? void 0 : _a.forEach((template) => {
          if (typeof template === "string") {
            throw new Error(`Global templates not yet supported for rich-text`);
          } else {
            const extraFields2 = template.ui || {};
            const templateName = lastItem(template.namespace);
            NAMER.dataTypeName(template.namespace);
            templates[lastItem(template.namespace)] = {
              label: template.label || templateName,
              key: templateName,
              inline: template.inline,
              name: templateName,
              fields: template.fields.map((field2) => resolveField(field2, schema)),
              ...extraFields2
            };
            return true;
          }
        });
        return {
          ...field,
          templates: Object.values(templates),
          component: "rich-text",
          ...extraFields
        };
      case "reference":
        return {
          ...field,
          component: "reference",
          ...extraFields
        };
      default:
        throw new Error(`Unknown field type ${field.type}`);
    }
  };
  const resolveForm = ({
    collection,
    basename,
    template,
    schema
  }) => {
    return {
      id: basename,
      label: collection.label,
      name: basename,
      fields: template.fields.map((field) => {
        return resolveField(field, schema);
      })
    };
  };
  const parseZodError = ({ zodError }) => {
    var _a, _b, _c, _d;
    const errors = zodError.flatten((issue) => {
      const moreInfo = [];
      if (issue.code === "invalid_union") {
        issue.unionErrors.map((unionError) => {
          moreInfo.push(parseZodError({ zodError: unionError }));
        });
      }
      const errorMessage = `Error ${issue == null ? void 0 : issue.message} at path ${issue.path.join(".")}`;
      const errorMessages = [errorMessage, ...moreInfo];
      return {
        errors: errorMessages
      };
    });
    const formErrors = errors.formErrors.flatMap((x) => x.errors);
    const parsedErrors = [
      ...((_b = (_a = errors.fieldErrors) == null ? void 0 : _a.collections) == null ? void 0 : _b.flatMap((x) => x.errors)) || [],
      ...((_d = (_c = errors.fieldErrors) == null ? void 0 : _c.config) == null ? void 0 : _d.flatMap((x) => x.errors)) || [],
      ...formErrors
    ];
    return parsedErrors;
  };
  const name = z.z.string({
    required_error: "Name is required but not provided",
    invalid_type_error: "Name must be a string"
  });
  const TypeName = [
    "string",
    "boolean",
    "number",
    "datetime",
    "image",
    "object",
    "reference",
    "rich-text"
  ];
  const typeTypeError = `type must be one of ${TypeName.join(", ")}`;
  const typeRequiredError = `type is required and must be one of ${TypeName.join(", ")}`;
  const nameProp = z.z.string({
    required_error: "name must be provided",
    invalid_type_error: "name must be a sting"
  });
  const Option = z.z.union([z.z.string(), z.z.object({ label: z.z.string(), value: z.z.string() })], {
    errorMap: () => {
      return {
        message: "Invalid option array. Must be a string[] or {label: string, value: string}[]"
      };
    }
  });
  const TinaField = z.z.object({
    name: nameProp,
    label: z.z.string().optional(),
    description: z.z.string().optional(),
    required: z.z.boolean().optional()
  });
  const FieldWithList = TinaField.extend({ list: z.z.boolean().optional() });
  const TinaScalerBase = FieldWithList.extend({
    options: z.z.array(Option).optional()
  });
  const StringField = TinaScalerBase.extend({
    type: z.z.literal("string", {
      invalid_type_error: typeTypeError,
      required_error: typeRequiredError
    }),
    isTitle: z.z.boolean().optional()
  });
  const BooleanField = TinaScalerBase.extend({
    type: z.z.literal("boolean", {
      invalid_type_error: typeTypeError,
      required_error: typeRequiredError
    })
  });
  const NumberField = TinaScalerBase.extend({
    type: z.z.literal("number", {
      invalid_type_error: typeTypeError,
      required_error: typeRequiredError
    })
  });
  const ImageField = TinaScalerBase.extend({
    type: z.z.literal("image", {
      invalid_type_error: typeTypeError,
      required_error: typeRequiredError
    })
  });
  const DateTimeField = TinaScalerBase.extend({
    type: z.z.literal("datetime", {
      invalid_type_error: typeTypeError,
      required_error: typeRequiredError
    }),
    dateFormat: z.z.string().optional(),
    timeFormat: z.z.string().optional()
  });
  const ReferenceField = FieldWithList.extend({
    type: z.z.literal("reference", {
      invalid_type_error: typeTypeError,
      required_error: typeRequiredError
    })
  });
  const TinaFieldZod = z.z.lazy(() => {
    const TemplateTemp = z.z.object({
      label: z.z.string(),
      name: nameProp,
      fields: z.z.array(TinaFieldZod)
    }).refine((val) => {
      var _a;
      return !hasDuplicates((_a = val.fields) == null ? void 0 : _a.map((x) => x.name));
    }, {
      message: "Fields must have a unique name"
    });
    const ObjectField = FieldWithList.extend({
      type: z.z.literal("object", {
        invalid_type_error: typeTypeError,
        required_error: typeRequiredError
      }),
      fields: z.z.array(TinaFieldZod).min(1).optional().refine((val) => !hasDuplicates(val == null ? void 0 : val.map((x) => x.name)), {
        message: "Fields must have a unique name"
      }),
      templates: z.z.array(TemplateTemp).min(1).optional().refine((val) => !hasDuplicates(val == null ? void 0 : val.map((x) => x.name)), {
        message: "Templates must have a unique name"
      })
    });
    const RichTextField = FieldWithList.extend({
      type: z.z.literal("rich-text", {
        invalid_type_error: typeTypeError,
        required_error: typeRequiredError
      }),
      templates: z.z.array(TemplateTemp).optional().refine((val) => !hasDuplicates(val == null ? void 0 : val.map((x) => x.name)), {
        message: "Templates must have a unique name"
      })
    });
    return z.z.discriminatedUnion("type", [
      StringField,
      BooleanField,
      NumberField,
      ImageField,
      DateTimeField,
      ReferenceField,
      ObjectField,
      RichTextField
    ], {
      errorMap: (issue, ctx) => {
        var _a;
        if (issue.code === "invalid_union_discriminator") {
          return {
            message: `Invalid \`type\` property. In the schema is 'type: ${(_a = ctx.data) == null ? void 0 : _a.type}' and expected one of ${TypeName.join(", ")}`
          };
        }
        return {
          message: issue.message
        };
      }
    }).superRefine((val, ctx) => {
      if (val.type === "string") {
        if (val.isTitle) {
          if (val.list) {
            ctx.addIssue({
              code: z.z.ZodIssueCode.custom,
              message: "You can not have `list: true` when using `isTitle`"
            });
          }
          if (!val.required) {
            ctx.addIssue({
              code: z.z.ZodIssueCode.custom,
              message: "You must have { required: true } when using `isTitle`"
            });
          }
        }
      }
      if (val.type === "object") {
        const message = "Must provide one of templates or fields in your collection";
        let isValid = Boolean(val == null ? void 0 : val.templates) || Boolean(val == null ? void 0 : val.fields);
        if (!isValid) {
          ctx.addIssue({
            code: z.z.ZodIssueCode.custom,
            message
          });
          return false;
        } else {
          isValid = !((val == null ? void 0 : val.templates) && (val == null ? void 0 : val.fields));
          if (!isValid) {
            ctx.addIssue({
              code: z.z.ZodIssueCode.custom,
              message
            });
          }
          return isValid;
        }
      }
      return true;
    });
  });
  const tinaConfigKey = z__default["default"].object({
    publicFolder: z__default["default"].string(),
    mediaRoot: z__default["default"].string()
  }).strict().optional();
  const tinaConfigZod = z__default["default"].object({
    media: z__default["default"].object({
      tina: tinaConfigKey,
      loadCustomStore: z__default["default"].function().optional()
    }).optional()
  });
  const validateTinaCloudSchemaConfig = (config) => {
    const newConfig = tinaConfigZod.parse(config);
    return newConfig;
  };
  const FORMATS = ["json", "md", "markdown", "mdx"];
  const Template = z.z.object({
    label: z.z.string({
      invalid_type_error: "label must be a string",
      required_error: "label was not provided but is required"
    }),
    name,
    fields: z.z.array(TinaFieldZod)
  }).refine((val) => {
    var _a;
    return !hasDuplicates((_a = val.fields) == null ? void 0 : _a.map((x) => x.name));
  }, {
    message: "Fields must have a unique name"
  });
  const TinaCloudCollectionBase = z.z.object({
    label: z.z.string().optional(),
    name,
    format: z.z.enum(FORMATS).optional()
  });
  const TinaCloudCollection = TinaCloudCollectionBase.extend({
    fields: z.z.array(TinaFieldZod).min(1).optional().refine((val) => !hasDuplicates(val == null ? void 0 : val.map((x) => x.name)), {
      message: "Fields must have a unique name"
    }).refine((val) => {
      const arr = (val == null ? void 0 : val.filter((x) => x.type === "string" && x.isTitle)) || [];
      return arr.length < 2;
    }, {
      message: "Fields can only have one use of `isTitle`"
    }),
    templates: z.z.array(Template).min(1).optional().refine((val) => !hasDuplicates(val == null ? void 0 : val.map((x) => x.name)), {
      message: "Templates must have a unique name"
    })
  }).refine((val) => {
    let isValid = Boolean(val == null ? void 0 : val.templates) || Boolean(val == null ? void 0 : val.fields);
    if (!isValid) {
      return false;
    } else {
      isValid = !((val == null ? void 0 : val.templates) && (val == null ? void 0 : val.fields));
      return isValid;
    }
  }, { message: "Must provide one of templates or fields in your collection" });
  const TinaCloudSchemaZod = z.z.object({
    collections: z.z.array(TinaCloudCollection),
    config: tinaConfigZod.optional()
  }).superRefine((val, ctx) => {
    var _a;
    if (hasDuplicates(val.collections.map((x) => x.name))) {
      ctx.addIssue({
        code: z.z.ZodIssueCode.custom,
        message: "can not have two collections with the same name",
        fatal: true
      });
    }
    const media = (_a = val == null ? void 0 : val.config) == null ? void 0 : _a.media;
    if (media && media.tina && media.loadCustomStore) {
      ctx.addIssue({
        code: z.z.ZodIssueCode.custom,
        message: "can not have both loadCustomStore and tina. Must use one or the other",
        fatal: true,
        path: ["config", "media"]
      });
    }
  });
  class TinaSchemaValidationError extends Error {
    constructor(message) {
      super(message);
      this.name = "TinaSchemaValidationError";
    }
  }
  const validateSchema = ({
    config
  }) => {
    try {
      TinaCloudSchemaZod.parse(config);
    } catch (e) {
      if (e instanceof z.ZodError) {
        const errors = parseZodError({ zodError: e });
        throw new TinaSchemaValidationError(errors.join(", \n"));
      } else {
        throw new Error(e);
      }
    }
  };
  exports2.TinaSchema = TinaSchema;
  exports2.TinaSchemaValidationError = TinaSchemaValidationError;
  exports2.addNamespaceToSchema = addNamespaceToSchema;
  exports2.resolveField = resolveField;
  exports2.resolveForm = resolveForm;
  exports2.validateSchema = validateSchema;
  exports2.validateTinaCloudSchemaConfig = validateTinaCloudSchemaConfig;
  Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
});
