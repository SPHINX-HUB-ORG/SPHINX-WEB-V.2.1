var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/utils/index.ts
var parseMediaFolder;
var init_utils = __esm({
  "src/utils/index.ts"() {
    parseMediaFolder = (str) => {
      let returnString = str;
      if (returnString.startsWith("/"))
        returnString = returnString.substr(1);
      if (returnString.endsWith("/"))
        returnString = returnString.substr(0, returnString.length - 1);
      return returnString;
    };
  }
});

// src/server/models/media.ts
var import_fs_extra5, import_path6, MediaModel;
var init_media = __esm({
  "src/server/models/media.ts"() {
    import_fs_extra5 = __toModule(require("fs-extra"));
    import_path6 = __toModule(require("path"));
    init_utils();
    MediaModel = class {
      constructor({ publicFolder, mediaRoot }) {
        this.mediaRoot = mediaRoot;
        this.publicFolder = publicFolder;
      }
      async listMedia(args) {
        try {
          const folderPath = (0, import_path6.join)(this.publicFolder, this.mediaRoot, args.searchPath);
          const searchPath = parseMediaFolder(args.searchPath);
          const filesStr = await import_fs_extra5.default.readdir(folderPath);
          const filesProm = filesStr.map(async (file) => {
            const filePath = (0, import_path6.join)(folderPath, file);
            const stat = await import_fs_extra5.default.stat(filePath);
            let src = `/${file}`;
            const isFile = stat.isFile();
            if (!isFile) {
              return {
                isFile,
                size: stat.size,
                src,
                filename: file
              };
            }
            if (searchPath) {
              src = `/${searchPath}${src}`;
            }
            if (this.mediaRoot) {
              src = `/${this.mediaRoot}${src}`;
            }
            return {
              isFile,
              size: stat.size,
              src,
              filename: file
            };
          });
          const offset = Number(args.cursor) || 0;
          const limit = Number(args.limit) || 20;
          const rawItems = await Promise.all(filesProm);
          const sortedItems = rawItems.sort((a, b) => {
            if (a.isFile && !b.isFile) {
              return 1;
            }
            if (!a.isFile && b.isFile) {
              return -1;
            }
            return 0;
          });
          const limitItems = sortedItems.slice(offset, offset + limit);
          const files = limitItems.filter((x) => x.isFile);
          const directories = limitItems.filter((x) => !x.isFile).map((x) => x.src);
          const cursor = rawItems.length > offset + limit ? String(offset + limit) : null;
          return {
            files,
            directories,
            cursor
          };
        } catch (error) {
          console.error(error);
          return {
            files: [],
            directories: [],
            error: error == null ? void 0 : error.toString()
          };
        }
      }
      async deleteMedia(args) {
        try {
          const file = (0, import_path6.join)(this.publicFolder, this.mediaRoot, args.searchPath);
          await import_fs_extra5.default.stat(file);
          await import_fs_extra5.default.remove(file);
          return { ok: true };
        } catch (error) {
          console.error(error);
          return { ok: false, message: error == null ? void 0 : error.toString() };
        }
      }
    };
  }
});

// src/server/routes/index.ts
var import_express, import_path7, import_multer, createMediaRouter;
var init_routes = __esm({
  "src/server/routes/index.ts"() {
    import_express = __toModule(require("express"));
    import_path7 = __toModule(require("path"));
    import_multer = __toModule(require("multer"));
    init_media();
    createMediaRouter = (config) => {
      const mediaFolder = (0, import_path7.join)(process.cwd(), config.publicFolder, config.mediaRoot);
      const storage = import_multer.default.diskStorage({
        destination: function(req, file, cb) {
          cb(null, mediaFolder);
        },
        filename: function(req, _file, cb) {
          const file = req.params[0];
          cb(null, file);
        }
      });
      const upload = (0, import_multer.default)({ storage });
      const mediaModel = new MediaModel(config);
      const mediaRouter = (0, import_express.Router)();
      mediaRouter.get("/list/*", async (req, res) => {
        const folder = req.params[0];
        const cursor = req.query.cursor;
        const limit = req.query.limit;
        const media = await mediaModel.listMedia({
          searchPath: folder,
          cursor,
          limit
        });
        res.json(media);
      });
      mediaRouter.delete("/*", async (req, res) => {
        const file = req.params[0];
        const didDelete = await mediaModel.deleteMedia({ searchPath: file });
        res.json(didDelete);
      });
      mediaRouter.post("/upload/*", upload.single("file"), function(req, res) {
        res.json({ success: true });
      });
      return mediaRouter;
    };
  }
});

// src/server/server.ts
var import_cors, import_http, import_express2, import_altair_express_middleware, import_body_parser, gqlServer;
var init_server = __esm({
  "src/server/server.ts"() {
    import_cors = __toModule(require("cors"));
    import_http = __toModule(require("http"));
    import_express2 = __toModule(require("express"));
    import_altair_express_middleware = __toModule(require("altair-express-middleware"));
    import_body_parser = __toModule(require("body-parser"));
    init_routes();
    init_utils();
    gqlServer = async (database, verbose) => {
      var _a, _b, _c;
      const gqlPackage = require("@tinacms/graphql");
      const app = (0, import_express2.default)();
      const server = import_http.default.createServer(app);
      app.use((0, import_cors.default)());
      app.use(import_body_parser.default.json());
      app.use("/altair", (0, import_altair_express_middleware.altairExpress)({
        endpointURL: "/graphql",
        initialQuery: `# Welcome to Tina!
      # We've got a simple query set up for you to get started
      # but there's plenty more for you to explore on your own!
      query MyQuery {
        collections {
          documents {
            id
            sys {
              filename
              extension
            }
          }
        }
      }`
      }));
      app.post("/graphql", async (req, res) => {
        const { query, variables } = req.body;
        const config = {
          useRelativeMedia: true
        };
        const result = await gqlPackage.resolve({
          config,
          database,
          query,
          variables,
          verbose
        });
        return res.json(result);
      });
      const db = database;
      const schema = await db.getSchema();
      const mediaPaths = ((_c = (_b = (_a = schema == null ? void 0 : schema.schema) == null ? void 0 : _a.config) == null ? void 0 : _b.media) == null ? void 0 : _c.tina) || {};
      app.use("/media", createMediaRouter({
        publicFolder: parseMediaFolder((mediaPaths == null ? void 0 : mediaPaths.publicFolder) || ""),
        mediaRoot: parseMediaFolder((mediaPaths == null ? void 0 : mediaPaths.mediaRoot) || "")
      }));
      return server;
    };
  }
});

// src/server/index.ts
var init_server2 = __esm({
  "src/server/index.ts"() {
    init_server();
  }
});

// src/cmds/start-server/server.ts
var server_exports = {};
__export(server_exports, {
  default: () => server_default
});
var server_default;
var init_server3 = __esm({
  "src/cmds/start-server/server.ts"() {
    init_server2();
    server_default = gqlServer;
  }
});

// src/index.ts
__export(exports, {
  defineSchema: () => defineSchema,
  init: () => init
});
var commander = __toModule(require("commander"));

// package.json
var name = "@tinacms/cli";
var version = "0.60.28";

// src/cmds/query-gen/attachSchema.ts
var import_graphql = __toModule(require("@tinacms/graphql"));
var import_datalayer = __toModule(require("@tinacms/datalayer"));

// src/utils/theme.ts
var import_chalk = __toModule(require("chalk"));
var successText = import_chalk.default.bold.green;
var dangerText = import_chalk.default.bold.red;
var neutralText = import_chalk.default.bold.cyan;
var labelText = import_chalk.default.bold;
var cmdText = import_chalk.default.inverse;
var logText = import_chalk.default.italic.gray;
var warnText = import_chalk.default.yellowBright.bgBlack;
var CONFIRMATION_TEXT = import_chalk.default.dim("enter to confirm");

// src/logger/index.ts
var import_log4js = __toModule(require("log4js"));
var logger = import_log4js.default.getLogger();
import_log4js.default.configure({
  appenders: {
    out: { type: "stdout", layout: { type: "messagePassThrough" } }
  },
  categories: { default: { appenders: ["out"], level: "info" } }
});
logger.level = "info";

// src/cmds/query-gen/attachSchema.ts
async function attachSchema(ctx, next, options) {
  logger.info(logText("Building schema..."));
  const rootPath2 = process.cwd();
  const bridge = new import_datalayer.FilesystemBridge(rootPath2);
  const store = new import_datalayer.FilesystemStore({ rootPath: rootPath2 });
  const database = await (0, import_graphql.createDatabase)({ store, bridge });
  const schema = await (0, import_graphql.buildSchema)(rootPath2, database);
  ctx.schema = schema;
  next();
}

// src/cmds/query-gen/genTypes.ts
var import_graphql6 = __toModule(require("graphql"));
var import_fs_extra = __toModule(require("fs-extra"));

// src/codegen/index.ts
var import_graphql5 = __toModule(require("graphql"));

// src/codegen/plugin.ts
var AddGeneratedClientFunc = (_schema, _documents, _config, _info) => {
  return `
// TinaSDK generated code
import { createClient, TinaClient } from "tinacms/dist/client";

const generateRequester = (client: TinaClient) => {
  const requester: (
    doc: any,
    vars?: any,
    options?: any,
    client
  ) => Promise<any> = async (doc, vars, _options) => {
    let data = {};
    try {
      data = await client.request({
        query: doc,
        variables: vars,
      });
    } catch (e) {
      // swallow errors related to document creation
      console.warn("Warning: There was an error when fetching data");
      console.warn(e);
    }

    return { data: data?.data, query: doc, variables: vars || {} };
  };

  return requester;
};

/**
 * @experimental this class can be used but may change in the future
 **/
export const ExperimentalGetTinaClient = () =>
  getSdk(
    generateRequester(createClient({ url: "http://localhost:4001/graphql" }))
  );

export const queries = (client: TinaClient) => {
  const requester = generateRequester(client);
  return getSdk(requester);
};
`;
};
var AddGeneratedClient = {
  plugin: AddGeneratedClientFunc
};

// src/codegen/index.ts
var import_graphql_file_loader = __toModule(require("@graphql-tools/graphql-file-loader"));
var import_core = __toModule(require("@graphql-codegen/core"));
var import_load = __toModule(require("@graphql-tools/load"));
var import_typescript_operations = __toModule(require("@graphql-codegen/typescript-operations"));
var import_typescript = __toModule(require("@graphql-codegen/typescript"));

// src/codegen/sdkPlugin/index.ts
var import_graphql3 = __toModule(require("graphql"));
var import_graphql4 = __toModule(require("graphql"));
var import_path = __toModule(require("path"));

// src/codegen/sdkPlugin/visitor.ts
var import_visitor_plugin_common = __toModule(require("@graphql-codegen/visitor-plugin-common"));
var import_auto_bind = __toModule(require("auto-bind"));
var import_graphql2 = __toModule(require("graphql"));
var GenericSdkVisitor = class extends import_visitor_plugin_common.ClientSideBaseVisitor {
  constructor(schema, fragments, rawConfig) {
    super(schema, fragments, rawConfig, {
      usingObservableFrom: rawConfig.usingObservableFrom
    });
    this._operationsToInclude = [];
    (0, import_auto_bind.default)(this);
    if (this.config.usingObservableFrom) {
      this._additionalImports.push(this.config.usingObservableFrom);
    }
    if (this.config.documentMode !== import_visitor_plugin_common.DocumentMode.string) {
    }
  }
  buildOperation(node, documentVariableName, operationType, operationResultType, operationVariablesTypes) {
    if (node.name == null) {
      throw new Error("Plugin 'generic-sdk' cannot generate SDK for unnamed operation.\n\n" + (0, import_graphql2.print)(node));
    } else {
      this._operationsToInclude.push({
        node,
        documentVariableName,
        operationType,
        operationResultType: `{data: ${operationResultType}, variables: ${operationVariablesTypes}, query: string}`,
        operationVariablesTypes
      });
    }
    return null;
  }
  get sdkContent() {
    const usingObservable = !!this.config.usingObservableFrom;
    const allPossibleActions = this._operationsToInclude.map((o) => {
      const optionalVariables = !o.node.variableDefinitions || o.node.variableDefinitions.length === 0 || o.node.variableDefinitions.every((v) => v.type.kind !== import_graphql2.Kind.NON_NULL_TYPE || v.defaultValue);
      const returnType = usingObservable && o.operationType === "Subscription" ? "Observable" : "Promise";
      return `${o.node.name.value}(variables${optionalVariables ? "?" : ""}: ${o.operationVariablesTypes}, options?: C): ${returnType}<${o.operationResultType}> {
    return requester<${o.operationResultType}, ${o.operationVariablesTypes}>(${o.documentVariableName}, variables, options);
  }`;
    }).map((s) => (0, import_visitor_plugin_common.indentMultiline)(s, 2));
    return `export type Requester<C= {}> = <R, V>(doc: ${this.config.documentMode === import_visitor_plugin_common.DocumentMode.string ? "string" : "DocumentNode"}, vars?: V, options?: C) => ${usingObservable ? "Promise<R> & Observable<R>" : "Promise<R>"}
  export function getSdk<C>(requester: Requester<C>) {
    return {
  ${allPossibleActions.join(",\n")}
    };
  }
  export type Sdk = ReturnType<typeof getSdk>;`;
  }
};

// src/codegen/sdkPlugin/index.ts
var plugin = (schema, documents, config) => {
  const allAst = (0, import_graphql4.concatAST)(documents.reduce((prev, v) => {
    return [...prev, v.document];
  }, []));
  const allFragments = [
    ...allAst.definitions.filter((d) => d.kind === import_graphql4.Kind.FRAGMENT_DEFINITION).map((fragmentDef) => ({
      node: fragmentDef,
      name: fragmentDef.name.value,
      onType: fragmentDef.typeCondition.name.value,
      isExternal: false
    })),
    ...config.externalFragments || []
  ];
  const visitor = new GenericSdkVisitor(schema, allFragments, config);
  const visitorResult = (0, import_graphql3.visit)(allAst, { leave: visitor });
  return {
    content: [
      visitor.fragments,
      ...visitorResult.definitions.filter((t) => typeof t === "string"),
      visitor.sdkContent
    ].join("\n")
  };
};

// src/codegen/index.ts
var generateTypes = async (schema, queryPathGlob = process.cwd(), fragDocPath = process.cwd(), options = {
  noSDK: false,
  verbose: false
}) => {
  if (options.verbose)
    logger.info("Generating types...");
  try {
    let docs = [];
    let fragDocs = [];
    try {
      if (!options.noSDK) {
        docs = await (0, import_load.loadDocuments)(queryPathGlob, {
          loaders: [new import_graphql_file_loader.GraphQLFileLoader()]
        });
      }
    } catch (e) {
      let showErrorMessage = true;
      const message = e.message || "";
      if (message.includes("Unable to find any GraphQL type definitions for the following pointers:")) {
        showErrorMessage = false;
      }
      if (showErrorMessage) {
        console.error(e);
      }
    }
    try {
      if (!options.noSDK) {
        fragDocs = await (0, import_load.loadDocuments)(fragDocPath, {
          loaders: [new import_graphql_file_loader.GraphQLFileLoader()]
        });
      }
    } catch (error) {
      console.error(error);
    }
    const res = await (0, import_core.codegen)({
      filename: process.cwd(),
      schema: (0, import_graphql5.parse)((0, import_graphql5.printSchema)(schema)),
      documents: [...docs, ...fragDocs],
      config: {},
      plugins: [
        { typescript: {} },
        { typescriptOperations: {} },
        {
          typescriptSdk: {}
        },
        { AddGeneratedClient: {} }
      ],
      pluginMap: {
        typescript: {
          plugin: import_typescript.plugin
        },
        typescriptOperations: {
          plugin: import_typescript_operations.plugin
        },
        typescriptSdk: {
          plugin
        },
        AddGeneratedClient
      }
    });
    return res;
  } catch (e) {
    console.error(e);
  }
};

// src/cmds/query-gen/genTypes.ts
async function genTypes({ schema }, next, options) {
  const typesPath = process.cwd() + "/.tina/__generated__/types.ts";
  const fragPath = process.cwd() + "/.tina/__generated__/*.{graphql,gql}";
  const queryPathGlob = process.cwd() + "/.tina/queries/**/*.{graphql,gql}";
  const typescriptTypes = await generateTypes(schema, queryPathGlob, fragPath, options);
  await import_fs_extra.default.outputFile(typesPath, `//@ts-nocheck
// DO NOT MODIFY THIS FILE. This file is automatically generated by Tina
export function gql(strings: TemplateStringsArray, ...args: string[]): string {
  let str = ''
  strings.forEach((string, i) => {
    str += string + (args[i] || '')
  })
  return str
}
${typescriptTypes}
`);
  logger.info(`	Typescript types => ${logText(typesPath)}`);
  const schemaString = await (0, import_graphql6.printSchema)(schema);
  const schemaPath = process.cwd() + "/.tina/__generated__/schema.gql";
  await import_fs_extra.default.outputFile(schemaPath, `# DO NOT MODIFY THIS FILE. This file is automatically generated by Tina
${schemaString}
schema {
  query: Query
  mutation: Mutation
}
  `);
  logger.info(`	GraphQL types ====> ${logText(schemaPath)}
`);
  next();
}

// src/cmds/audit/index.ts
var import_graphql9 = __toModule(require("@tinacms/graphql"));
var import_datalayer2 = __toModule(require("@tinacms/datalayer"));

// src/cmds/audit/audit.ts
var import_graphql7 = __toModule(require("@tinacms/graphql"));
var import_path2 = __toModule(require("path"));
var import_graphql8 = __toModule(require("@tinacms/graphql"));
var import_chalk2 = __toModule(require("chalk"));
var auditCollection = async (args) => {
  let warning = false;
  const { collection, database, rootPath: rootPath2 } = args;
  logger.info(`Checking collection ${collection.name}`);
  const query = `query {
        collection(collection: "${collection.name}") {
          format
          documents {
            edges {
              node {
                ...on Document {
                  _sys {
                    extension
                    path
                  }
                }
              }
            }
          }
        }
      }
      `;
  const result = await (0, import_graphql7.resolve)({
    database,
    query,
    variables: {}
  });
  const format = result.data.collection.format;
  const docs = result.data.collection.documents.edges;
  docs.forEach((x) => {
    const node = x.node;
    if (node._sys.extension.replace(".", "") !== format) {
      warning = true;
      logger.warn(import_chalk2.default.yellowBright(`WARNING: there is a file with extension \`${node._sys.extension}\` but in your schema it is defined to be \`.${format}\`

location: ${import_path2.default.join(rootPath2, node._sys.path)}`));
    }
  });
  return warning;
};
var auditDocuments = async (args) => {
  const { collection, database, rootPath: rootPath2, useDefaultValues } = args;
  const query = `query {
        collection(collection: "${collection.name}") {
          format
          slug
          documents {
            edges {
              node {
                ...on Document {
                  _sys {
                    extension
                    path
                    relativePath
                  }
                }
              }
            }
          }
        }
      }
      `;
  const result = await (0, import_graphql7.resolve)({
    database,
    query,
    variables: {}
  });
  let error = false;
  const documents = result.data.collection.documents.edges;
  for (let i = 0; i < documents.length; i++) {
    const node = documents[i].node;
    const fullPath = import_path2.default.join(rootPath2, node._sys.path);
    logger.info(`Checking document: ${fullPath}`);
    const documentQuery = `query {
        document(collection: "${collection.name}", relativePath: "${node._sys.relativePath}") {
          __typename
          ...on Document {
            _values
          }
        }
      }`;
    const docResult = await (0, import_graphql7.resolve)({
      database,
      query: documentQuery,
      variables: {}
    });
    const topLevelDefaults = {};
    if (useDefaultValues && typeof collection.fields !== "string") {
      collection.fields.filter((x) => !x.list).forEach((x) => {
        const value = x.ui;
        if (typeof value !== "undefined") {
          topLevelDefaults[x.name] = value.defaultValue;
        }
      });
    }
    const params = transformDocumentIntoMutationRequestPayload(docResult.data.document._values, {
      includeCollection: true,
      includeTemplate: typeof collection.templates !== "undefined"
    }, topLevelDefaults);
    const mutation = `mutation($collection: String!, $relativePath: String!, $params: DocumentMutation!) {
        updateDocument(
          collection: $collection,
          relativePath: $relativePath,
          params: $params
        ){__typename}
      }`;
    const mutationRes = await (0, import_graphql7.resolve)({
      database,
      query: mutation,
      variables: {
        params,
        collection: collection.name,
        relativePath: node._sys.relativePath
      },
      silenceErrors: true,
      verbose: true
    });
    if (mutationRes.errors) {
      mutationRes.errors.forEach((err) => {
        error = true;
        logger.error(import_chalk2.default.red(err.message));
      });
    }
  }
  return error;
};
var transformDocumentIntoMutationRequestPayload = (document, instructions, defaults) => {
  const _a = document, { _collection, __typename, _template } = _a, rest = __objRest(_a, ["_collection", "__typename", "_template"]);
  const params = transformParams(rest);
  const paramsWithTemplate = instructions.includeTemplate ? { [_template]: params } : params;
  return instructions.includeCollection ? { [_collection]: __spreadValues(__spreadValues({}, defaults), filterObject(paramsWithTemplate)) } : __spreadValues(__spreadValues({}, defaults), filterObject(paramsWithTemplate));
};
var transformParams = (data) => {
  if (["string", "number", "boolean"].includes(typeof data)) {
    return data;
  }
  if (Array.isArray(data)) {
    return data.map((item) => transformParams(item));
  }
  try {
    (0, import_graphql8.assertShape)(data, (yup) => yup.object({ _template: yup.string().required() }));
    const _a = data, { _template, __typename } = _a, rest = __objRest(_a, ["_template", "__typename"]);
    const nested = transformParams(rest);
    return { [_template]: nested };
  } catch (e) {
    if (e.message === "Failed to assertShape - _template is a required field") {
      if (!data) {
        return void 0;
        return [];
      }
      const accum = {};
      Object.entries(data).map(([keyName, value]) => {
        accum[keyName] = transformParams(value);
      });
      return accum;
    } else {
      if (!data) {
        return void 0;
        return [];
      }
      throw e;
    }
  }
};
function filterObject(obj) {
  const ret = {};
  Object.keys(obj).filter((key) => obj[key] !== void 0).forEach((key) => ret[key] = obj[key]);
  return ret;
}

// src/cmds/audit/index.ts
var import_chalk3 = __toModule(require("chalk"));
var import_prompts = __toModule(require("prompts"));
var import_metrics = __toModule(require("@tinacms/metrics"));
var rootPath = process.cwd();
var audit = async (ctx, next, options) => {
  const telemetry = new import_metrics.Telemetry({ disabled: options.noTelemetry });
  await telemetry.submitRecord({
    event: {
      name: "tinacms:cli:audit:invoke",
      clean: Boolean(options.clean),
      useDefaults: Boolean(options.useDefaultValues)
    }
  });
  if (options.clean) {
    logger.info(`You are using the \`--clean\` option. This will modify your content as if a user is submitting a form. Before running this you should have a ${import_chalk3.default.bold("clean git tree")} so unwanted changes can be undone.

`);
    const res = await (0, import_prompts.default)({
      name: "useClean",
      type: "confirm",
      message: `Do you want to continue?`
    });
    if (!res.useClean) {
      logger.warn(import_chalk3.default.yellowBright("\u26A0\uFE0F Audit not complete"));
      process.exit(0);
    }
  }
  if (options.useDefaultValues && !options.clean) {
    logger.warn(import_chalk3.default.yellowBright("WARNING: using the `--useDefaultValues` without the `--clean` flag has no effect. Please re-run audit and add the `--clean` flag"));
  }
  const bridge = options.clean ? new import_datalayer2.FilesystemBridge(rootPath) : new import_datalayer2.AuditFileSystemBridge(rootPath);
  const store = options.clean ? new import_datalayer2.FilesystemStore({ rootPath }) : new import_datalayer2.AuditFilesystemStore({ rootPath });
  const database = await (0, import_graphql9.createDatabase)({ store, bridge });
  const schema = await database.getSchema();
  const collections = schema.getCollections();
  let warning = false;
  let error = false;
  for (let i = 0; i < collections.length; i++) {
    const collection = collections[i];
    const returnWarning = await auditCollection({
      collection,
      database,
      rootPath,
      useDefaultValues: options.useDefaultValues
    });
    const returnError = await auditDocuments({
      collection,
      database,
      rootPath,
      useDefaultValues: options.useDefaultValues
    });
    warning = warning || returnWarning;
    error = error || returnError;
  }
  ctx.warning = warning;
  ctx.error = error;
  next();
};
var printFinalMessage = async (ctx, next, _options) => {
  if (ctx.error) {
    logger.error(import_chalk3.default.redBright(`\u203C\uFE0F Audit ${import_chalk3.default.bold("failed")} with errors`));
  } else if (ctx.warning) {
    logger.warn(import_chalk3.default.yellowBright("\u26A0\uFE0F Audit passed with warnings"));
  } else {
    logger.info(import_chalk3.default.greenBright("\u2705 Audit passed"));
  }
  next();
};

// src/cmds/init/setup-files/index.ts
var import_chalk4 = __toModule(require("chalk"));
var adminPage = `import { TinaAdmin } from 'tinacms';
export default TinaAdmin;
`;
var blogPost = `---
title: Vote For Pedro
---
# Welcome to the blog.

> To edit this site head over to the [\`/admin\`](/admin) route. Then click the pencil icon in the bottom lefthand corner to start editing \u{1F999}.

# Dixi gaude Arethusa

<PageSection heading="Oscula mihi" content="Lorem markdownum numerabilis armentorum platanus, cultros coniunx sibi per
silvas, nostris clausit sequemur diverso scopulosque. Fecit tum alta sed non
falcato murmura, geminas donata Amyntore, quoque Nox. Invitam inquit, modo
nocte; ut ignis faciemque manes in imagine sinistra ut mucrone non ramos
sepulcro supplex. Crescentesque populos motura, fit cumque. Verumque est; retro
sibi tristia bracchia Aetola telae caruerunt et."/>


## Mutato fefellimus sit demisit aut alterius sollicito

Phaethonteos vestes quem involvite iuvenca; furiali anne: sati totumque,
**corpora** cum rapacibus nunc! Nervis repetatne, miserabile doleas, deprensum
hunc, fluctus Threicio, ad urbes, magicaeque, quid. Per credensque series adicis
poteram [quidem](#)! Iam uni mensas victrix
vittas ut flumina Satyri adulter; bellum iacet domitae repercusso truncis urnis
mille rigidi sub taurum.


`;
var nextPostPage = () => `// THIS FILE HAS BEEN GENERATED WITH THE TINA CLI.
  // This is a demo file once you have tina setup feel free to delete this file

  import { staticRequest, gql } from "tinacms";
  import Head from "next/head";
  import { createGlobalStyle } from "styled-components";
  import { useTina } from "tinacms/dist/edit-state";
  import { TinaMarkdown } from 'tinacms/dist/rich-text'

  const query = gql\`
    query BlogPostQuery($relativePath: String!) {
      posts(relativePath: $relativePath) {
        title
        body
      }
    }
  \`

  // Styles for markdown
  const GlobalStyle = createGlobalStyle\`
  h1,h2,h3,h4,h5 {
    margin-bottom: 1.5rem;
    margin-top: 1.5rem;
  }
  blockquote {
    background-color: rgb(209,250,229);
  }
  h1 {
    font-size: 45px;
  }
  h2 {
    font-size: 35px;
  }
  h3 {
    font-size: 25px;
  }
  h4 {
    font-size: 22px;
  }
  ul {
    padding-left: 0;
  }
  li {
    list-style-type: none;
  }
  a {
    font-weight: bold;
    color: rgb(59,130,246);
    text-decoration: underline;
  }
  \`;

  const BlogPage = (props) => {
    const { data } = useTina({
      query,
      variables: props.variables,
      data: props.data,
    });

    return (
      <>
        <Head>
          {/* Tailwind CDN */}
          <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.7/tailwind.min.css"
            integrity="sha512-y6ZMKFUQrn+UUEVoqYe8ApScqbjuhjqzTuwUMEGMDuhS2niI8KA3vhH2LenreqJXQS+iIXVTRL2iaNfJbDNA1Q=="
            crossOrigin="anonymous"
            referrerPolicy="no-referrer"
          />
        </Head>
        <div>
          <div
            style={{
              textAlign: "center",
            }}
          >
            <h1 className="text-3xl m-8 text-center leading-8 font-extrabold tracking-tight text-gray-900 sm:text-4xl">
              {data.posts.title}
            </h1>
            <ContentSection
              content={data.posts.body}
            ></ContentSection>
          </div>
          <div className="bg-green-100 text-center">
            Lost and looking for a place to start?
            <a
              href="https://tina.io/guides/tina-cloud/getting-started/overview/"
              className="text-blue-500 underline"
            >
              {" "}
              Check out this guide
            </a>{" "}
            to see how add TinaCMS to an existing Next.js site.
          </div>
        </div>
      </>
    );
  };

  export const getStaticProps = async ({ params }) => {
    const variables = { relativePath: \`\${params.filename}.md\` }
    let data = {}
    try {
      data = await staticRequest({
        query,
        variables,
      })
    } catch {
      // swallow errors related to document creation
    }

    return {
      props: {
        variables,
        data,
        //myOtherProp: 'some-other-data',
      },
    }
  };

  export const getStaticPaths = async () => {
    const postsListData = (await staticRequest({
      query: gql\`
        query GetPostsList {
          postsConnection {
            edges {
              node {
                ...on Document {
                  _sys {
                    filename
                  }
                }
              }
            }
          }
        }
      \`,
    }));

    return {
      paths: postsListData.postsConnection.edges.map((post) => ({
        params: { filename: post.node._sys.filename },
      })),
      fallback: false,
    };
  };

  export default BlogPage;

  const PageSection = props => {
    return (
      <>
        <h2>{ props.heading }</h2>
        <p>{ props.content }</p>
      </>
    )
  }

  const components = {
    PageSection: PageSection,
  }

  const ContentSection = ({ content }) => {
    return (
      <div className="relative py-16 bg-white overflow-hidden">
        <div className="hidden lg:block lg:absolute lg:inset-y-0 lg:h-full lg:w-full">
          <div
            className="relative h-full text-lg max-w-prose mx-auto"
            aria-hidden="true"
          >
            <svg
              className="absolute top-12 left-full transform translate-x-32"
              width={404}
              height={384}
              fill="none"
              viewBox="0 0 404 384"
            >
              <defs>
                <pattern
                  id="74b3fd99-0a6f-4271-bef2-e80eeafdf357"
                  x={0}
                  y={0}
                  width={20}
                  height={20}
                  patternUnits="userSpaceOnUse"
                >
                  <rect
                    x={0}
                    y={0}
                    width={4}
                    height={4}
                    className="text-gray-200"
                    fill="currentColor"
                  />
                </pattern>
              </defs>
              <rect
                width={404}
                height={384}
                fill="url(#74b3fd99-0a6f-4271-bef2-e80eeafdf357)"
              />
            </svg>
            <svg
              className="absolute top-1/2 right-full transform -translate-y-1/2 -translate-x-32"
              width={404}
              height={384}
              fill="none"
              viewBox="0 0 404 384"
            >
              <defs>
                <pattern
                  id="f210dbf6-a58d-4871-961e-36d5016a0f49"
                  x={0}
                  y={0}
                  width={20}
                  height={20}
                  patternUnits="userSpaceOnUse"
                >
                  <rect
                    x={0}
                    y={0}
                    width={4}
                    height={4}
                    className="text-gray-200"
                    fill="currentColor"
                  />
                </pattern>
              </defs>
              <rect
                width={404}
                height={384}
                fill="url(#f210dbf6-a58d-4871-961e-36d5016a0f49)"
              />
            </svg>
            <svg
              className="absolute bottom-12 left-full transform translate-x-32"
              width={404}
              height={384}
              fill="none"
              viewBox="0 0 404 384"
            >
              <defs>
                <pattern
                  id="d3eb07ae-5182-43e6-857d-35c643af9034"
                  x={0}
                  y={0}
                  width={20}
                  height={20}
                  patternUnits="userSpaceOnUse"
                >
                  <rect
                    x={0}
                    y={0}
                    width={4}
                    height={4}
                    className="text-gray-200"
                    fill="currentColor"
                  />
                </pattern>
              </defs>
              <rect
                width={404}
                height={384}
                fill="url(#d3eb07ae-5182-43e6-857d-35c643af9034)"
              />
            </svg>
          </div>
        </div>
        <div className="relative px-4 sm:px-6 lg:px-8">
          <div className="text-lg max-w-prose mx-auto">
            <TinaMarkdown components={components} content={content}/>
            <GlobalStyle />
          </div>
        </div>
      </div>
    );
  };

`;
var AppJsContent = (usingSrc, extraImports) => {
  const importLine = `import Tina from '${usingSrc ? "../" : ""}../.tina/components/TinaDynamicProvider.js'`;
  return `${importLine}
${extraImports || ""}

const App = ({ Component, pageProps }) => {
  return (
    <Tina>
      <Component {...pageProps} />
    </Tina>
  )
}

export default App
`;
};
var AppJsContentPrintout = (usingSrc, extraImports) => {
  const importLine = import_chalk4.default.green(`+ import Tina from '${usingSrc ? "../" : ""}../.tina/components/TinaDynamicProvider.js'`);
  return `${importLine}
  ${extraImports || ""}

  const App = ({ Component, pageProps }) => {
  return (
    ${import_chalk4.default.green("+ <Tina>")}
        <Component {...pageProps} />
    ${import_chalk4.default.green("+ </Tina>")}
  )
}

export default App
`;
};

// src/cmds/init/setup-files/tinaProvider.ts
var TinaProvider = `import TinaCMS from 'tinacms'
import { tinaConfig } from '../schema.ts'

// Importing the TinaProvider directly into your page will cause Tina to be added to the production bundle.
// Instead, import the tina/provider/index default export to have it dynamially imported in edit-moode
/**
 *
 * @private Do not import this directly, please import the dynamic provider instead
 */
const TinaProvider = ({ children }) => {
  return <TinaCMS {...tinaConfig}>{children}</TinaCMS>
}

export default TinaProvider
`;
var TinaProviderDynamic = `import dynamic from 'next/dynamic'
const TinaProvider = dynamic(() => import('./TinaProvider'), { ssr: false })
import { TinaEditProvider } from 'tinacms/dist/edit-state'

const DynamicTina = ({ children }) => {
  return (
    <>
      <TinaEditProvider editMode={<TinaProvider>{children}</TinaProvider>}>
        {children}
      </TinaEditProvider>
    </>
  )
}

export default DynamicTina
`;

// src/utils/script-helpers.ts
function generateGqlScript(scriptValue) {
  return `tinacms server:start -c "${scriptValue}"`;
}
function extendNextScripts(scripts) {
  return __spreadProps(__spreadValues({}, scripts), {
    dev: generateGqlScript(scripts.dev || "next dev"),
    build: generateGqlScript(scripts.build || "next build"),
    start: generateGqlScript(scripts.start || "next start")
  });
}

// src/cmds/init/index.ts
var import_fs_extra2 = __toModule(require("fs-extra"));
var import_progress = __toModule(require("progress"));
var import_metrics2 = __toModule(require("@tinacms/metrics"));
var import_chalk5 = __toModule(require("chalk"));
var import_path3 = __toModule(require("path"));
var import_prompts2 = __toModule(require("prompts"));
function execShellCommand(cmd) {
  const exec = require("child_process").exec;
  return new Promise((resolve2, _reject) => {
    exec(cmd, (error, stdout, stderr) => {
      if (error) {
        console.warn(error);
      }
      resolve2(stdout ? stdout : stderr);
    });
  });
}
async function initTina(ctx, next, options) {
  const telemetry = new import_metrics2.Telemetry({ disabled: options.noTelemetry });
  await telemetry.submitRecord({
    event: {
      name: "tinacms:cli:init:invoke",
      schemaFileType: options.schemaFileType || "ts"
    }
  });
  logger.info(successText("Setting up Tina..."));
  next();
}
var MIN_REACT_VERSION = ">=16.14.0";
async function checkDeps(ctx, next, options) {
  const bar = new import_progress.default("Checking dependencies. :prog", 1);
  const packageJSON = JSON.parse((await import_fs_extra2.default.readFileSync(packageJSONPath)).toString());
  if (!checkPackage(packageJSON, "react") || !checkPackage(packageJSON, "react-dom")) {
    const message = `Unable to initialize Tina due to outdated dependencies, try upgrading the following packages:
      "react@${MIN_REACT_VERSION}"
      "react-dom@${MIN_REACT_VERSION}"

  Then re-rerun "@tinacms/cli init"`;
    throw new Error(message);
  }
  bar.tick({
    prog: "\u2705"
  });
  logger.level = "fatal";
  next();
}
var checkPackage = (packageJSON, packageName) => {
  let strippedVersion;
  Object.entries(packageJSON.dependencies).map(([depPackageName, version2]) => {
    if (depPackageName === packageName) {
      strippedVersion = version2.replace(/^[^a-zA-Z0-9]*|[^a-zA-Z0-9]*$/g, "");
    }
  });
  return checkVersion(strippedVersion);
};
var checkVersion = (version2) => {
  const majorMin = 16;
  const minorMin = 14;
  const parts = version2.split(".");
  const major = Number(parts[0]);
  const minor = Number(parts[1]);
  if (parts.length === 1) {
    if (isNaN(major)) {
      return true;
    } else if (major > majorMin) {
      return true;
    } else {
      return false;
    }
  }
  if (major > majorMin) {
    return true;
  } else if (major === majorMin) {
    if (minor >= minorMin) {
      return true;
    } else {
      return false;
    }
  } else {
    return false;
  }
};
async function installDeps(ctx, next, options) {
  const bar = new import_progress.default("Installing Tina packages. This might take a moment... :prog", 2);
  const deps = ["tinacms", "styled-components", "@tinacms/cli"];
  bar.tick({
    prog: ""
  });
  const installCMD = `yarn add ${deps.join(" ")}`;
  await execShellCommand(installCMD);
  bar.tick({
    prog: "\u2705"
  });
  logger.level = "fatal";
  next();
}
var baseDir = process.cwd();
var packageJSONPath = import_path3.default.join(baseDir, "package.json");
var blogContentPath = import_path3.default.join(baseDir, "content", "posts");
var blogPostPath = import_path3.default.join(blogContentPath, "HelloWorld.md");
var TinaFolder = import_path3.default.join(baseDir, ".tina");
var componentFolder = import_path3.default.join(TinaFolder, "components");
var TinaProviderPath = import_path3.default.join(componentFolder, "TinaProvider.js");
var TinaDynamicProvider = import_path3.default.join(componentFolder, "TinaDynamicProvider.js");
async function tinaSetup(_ctx, next, _options) {
  const usingSrc = !import_fs_extra2.default.pathExistsSync(import_path3.default.join(baseDir, "pages"));
  if (!import_fs_extra2.default.pathExistsSync(blogPostPath)) {
    logger.info(logText("Adding a content folder..."));
    import_fs_extra2.default.mkdirpSync(blogContentPath);
    import_fs_extra2.default.writeFileSync(blogPostPath, blogPost);
  }
  if (!import_fs_extra2.default.existsSync(TinaProviderPath) && !import_fs_extra2.default.existsSync(TinaDynamicProvider)) {
    import_fs_extra2.default.mkdirpSync(componentFolder);
    import_fs_extra2.default.writeFileSync(TinaProviderPath, TinaProvider.replace(/'\.\.\/schema\.ts'/, `'../schema.${_ctx.schemaFileType || "ts"}'`));
    import_fs_extra2.default.writeFileSync(TinaDynamicProvider, TinaProviderDynamic);
  }
  logger.level = "info";
  const pagesPath = import_path3.default.join(baseDir, usingSrc ? "src" : "", "pages");
  const appPath = import_path3.default.join(pagesPath, "_app.js");
  const appPathTS = import_path3.default.join(pagesPath, "_app.tsx");
  const appExtension = import_fs_extra2.default.existsSync(appPath) ? ".js" : ".tsx";
  if (!import_fs_extra2.default.pathExistsSync(appPath) && !import_fs_extra2.default.pathExistsSync(appPathTS)) {
    logger.info(logText("Adding _app.js ... \u2705"));
    import_fs_extra2.default.writeFileSync(appPath, AppJsContent(usingSrc));
  } else {
    const override = await (0, import_prompts2.default)({
      name: "res",
      type: "confirm",
      message: `do you want us to ${import_chalk5.default.bold(`override`)} your _app${appExtension}?`
    });
    _ctx.overrideApp = override.res;
    if (override.res) {
      logger.info(logText(`Adding _app${appExtension} ... \u2705`));
      const appPathWithExtension = import_path3.default.join(pagesPath, `_app${appExtension}`);
      const fileContent = import_fs_extra2.default.pathExistsSync(appPath) ? (0, import_fs_extra2.readFileSync)(appPath) : (0, import_fs_extra2.readFileSync)(appPathTS);
      const matches = [
        ...fileContent.toString().matchAll(/^.*import.*\.css("|').*$/gm)
      ];
      const primaryMatches = matches.map((x) => x[0]);
      import_fs_extra2.default.writeFileSync(appPathWithExtension, AppJsContent(usingSrc, primaryMatches.join("\n")));
    }
  }
  const tinaBlogPagePath = import_path3.default.join(pagesPath, "demo", "blog");
  const tinaBlogPagePathFile = import_path3.default.join(tinaBlogPagePath, "[filename].js");
  if (!import_fs_extra2.default.pathExistsSync(tinaBlogPagePathFile)) {
    import_fs_extra2.default.mkdirpSync(tinaBlogPagePath);
    import_fs_extra2.default.writeFileSync(tinaBlogPagePathFile, nextPostPage());
  }
  logger.info("Adding a content folder... \u2705");
  const packagePath = import_path3.default.join(baseDir, "package.json");
  const pack = JSON.parse((0, import_fs_extra2.readFileSync)(packagePath).toString());
  const oldScripts = pack.scripts || {};
  const newPack = JSON.stringify(__spreadProps(__spreadValues({}, pack), {
    scripts: extendNextScripts(oldScripts)
  }), null, 2);
  (0, import_fs_extra2.writeFileSync)(packagePath, newPack);
  const adminPath = import_path3.default.join(pagesPath, "admin.js");
  if (import_fs_extra2.default.pathExistsSync(import_path3.default.join(pagesPath, "admin"))) {
    logger.warn(`Unable to add /pages/admin.js, this path already exists.
	Learn more about toggling edit-mode at https://tina.io/docs/tinacms-context/#manually-toggling-edit-mode`);
    return next();
  }
  (0, import_fs_extra2.outputFileSync)(adminPath, adminPage);
  next();
}
async function successMessage(ctx, next, options) {
  const usingSrc = import_fs_extra2.default.pathExistsSync(import_path3.default.join(baseDir, "src"));
  logger.info(`Tina setup ${import_chalk5.default.underline.green("done")} \u2705
`);
  logger.info("Next Steps: \n");
  if (!ctx.overrideApp) {
    logger.info(`${import_chalk5.default.bold("Add the Tina wrapper")}`);
    logger.info(`\u26A0\uFE0F Before using Tina, you will NEED to add the Tina wrapper to your _app.jsx 
`);
    logger.info(`${AppJsContentPrintout(usingSrc)}`);
  }
  logger.info(`${import_chalk5.default.bold("Run your site with Tina")}`);
  logger.info(`  yarn dev 
`);
  logger.info(`${import_chalk5.default.bold("Start Editing")}`);
  logger.info(`  Go to 'http://localhost:3000/admin' 
`);
  logger.info(`${import_chalk5.default.bold("Read the docs")}`);
  logger.info(`  Check out 'https://tina.io/docs/introduction/tina-init/#adding-tina' for help getting started with Tina 
`);
  logger.info(`Enjoy Tina! \u{1F999}`);
  next();
}

// src/cmds/baseCmds.ts
var import_config = __toModule(require("dotenv/config"));

// src/middleware.ts
var chain = async (cmds, options) => {
  const ctx = {};
  const next = async (middlewareIndex) => {
    if (middlewareIndex >= cmds.length) {
      process.exit(0);
    }
    try {
      await cmds[middlewareIndex](ctx, () => next(middlewareIndex + 1), options || {});
    } catch (err) {
      console.error(`  ${dangerText(err)}`);
      process.exit(1);
    }
  };
  if (cmds.length > 0) {
    await next(0);
  }
};

// src/cmds/baseCmds.ts
var import_chalk7 = __toModule(require("chalk"));

// src/cmds/start-server/errors/index.ts
var import_graphql10 = __toModule(require("@tinacms/graphql"));
var BuildSchemaError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "BuildSchemaError";
  }
};
var ExecuteSchemaError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ExecuteSchemaError";
  }
};
var handleServerErrors = (e) => {
  if (e.name === "BuildSchemaError") {
    logger.error(`${dangerText("ERROR: your schema was not successfully built: see https://tina.io/docs/errors/esbuild-error/ for more details")}
  Error Message Below
  ${e}`);
  } else if (e.name === "ExecuteSchemaError") {
    logger.error(`${dangerText("ERROR: your schema was not successfully executed: see https://tina.io/docs/errors/esbuild-error/ for more details")}
  Error Message Below
  ${e}`);
  } else if (e.name === "TinaSchemaValidationError") {
    logger.error(`${dangerText("ERROR: your schema was not successfully validated: see https://tina.io/docs/schema/ for instructions on how to setup a schema")}
  Error Message Below
  ${e}`);
  } else if (e instanceof import_graphql10.TinaFetchError) {
    (0, import_graphql10.handleFetchErrorError)(e, true);
  } else {
    logger.info(dangerText("Compilation failed with errors. Server has not been restarted.") + ` see error below 
 ${e.message}`);
  }
};

// src/cmds/compile/index.ts
var import_fs_extra4 = __toModule(require("fs-extra"));
var import_path5 = __toModule(require("path"));
var import_esbuild = __toModule(require("esbuild"));

// src/cmds/compile/defaultSchema.ts
var defaultSchema = `
import { defineSchema, defineConfig } from "tinacms";

const schema = defineSchema({
  collections: [
    {
      label: "Blog Posts",
      name: "posts",
      path: "content/posts",
      fields: [
        {
          type: "string",
          label: "Title",
          name: "title",
        },
        {
          type: "rich-text",
          label: "Blog Post Body",
          name: "body",
          isBody: true,
          templates: [
            {
              name: "PageSection",
              label: "Page Section",
              fields: [
                {
                  type: "string",
                  name: "heading",
                  label: "Heading",
                },
                {
                  type: "string",
                  name: "content",
                  label: "Content",
                  ui: {
                    component: "textarea"
                  }
                }
              ],
            },
          ]
        },
      ],
    },
  ],
});

export default schema

// Your tina config
// ==============
const branch = 'main'
// When working locally, hit our local filesystem.
// On a Vercel deployment, hit the Tina Cloud API
const apiURL =
  process.env.NODE_ENV == 'development'
    ? 'http://localhost:4001/graphql'
    : \`https://content.tinajs.io/content/\${process.env.NEXT_PUBLIC_TINA_CLIENT_ID}/github/\${branch}\`

export const tinaConfig = defineConfig({
  apiURL,
  schema,
  cmsCallback: (cms) => {
    //  add your CMS callback code here (if you want)

    // The Route Mapper
    /**
     * 1. Import \`tinacms\` and \`RouteMappingPlugin\`
     **/
    import("tinacms").then(({ RouteMappingPlugin }) => {
      /**
       * 2. Define the \`RouteMappingPlugin\` see https://tina.io/docs/tinacms-context/#the-routemappingplugin for more details
       **/
      const RouteMapping = new RouteMappingPlugin((collection, document) => {
        return undefined;
      });
      /**
       * 3. Add the \`RouteMappingPlugin\` to the \`cms\`.
       **/
      cms.plugins.add(RouteMapping);
    });

    return cms;
  },
});
`;

// src/lib/getPath.ts
var import_path4 = __toModule(require("path"));
var import_fs_extra3 = __toModule(require("fs-extra"));
var getPath = ({
  projectDir,
  filename,
  allowedTypes,
  errorMessage
}) => {
  if (!import_fs_extra3.default.existsSync(projectDir)) {
    throw new Error(errorMessage);
  }
  const filePaths = allowedTypes.map((ext) => import_path4.default.join(projectDir, `${filename}.${ext}`));
  let inputFile = void 0;
  filePaths.every((path4) => {
    if (import_fs_extra3.default.existsSync(path4)) {
      inputFile = path4;
      return false;
    }
    return true;
  });
  if (!inputFile) {
    throw new Error(errorMessage);
  }
  return inputFile;
};
var getSchemaPath = ({ projectDir }) => {
  const filename = "schema";
  const allowedTypes = ["js", "jsx", "ts", "tsx"];
  const errorMessage = "Must provide a `.tina/schema.{ts,js,tsx,jsx}`";
  return getPath({ projectDir, filename, allowedTypes, errorMessage });
};
var getClientPath = ({ projectDir }) => {
  const filename = "client";
  const allowedTypes = ["js", "ts"];
  const errorMessage = "Must provide a `.tina/client.{ts,js}`";
  return getPath({ projectDir, filename, allowedTypes, errorMessage });
};

// src/cmds/compile/index.ts
var tinaPath = import_path5.default.join(process.cwd(), ".tina");
var packageJSONFilePath = import_path5.default.join(process.cwd(), "package.json");
var tinaGeneratedPath = import_path5.default.join(tinaPath, "__generated__");
var tinaConfigPath = import_path5.default.join(tinaGeneratedPath, "config");
var resetGeneratedFolder = async () => {
  try {
    await import_fs_extra4.default.rm(tinaGeneratedPath, {
      recursive: true
    });
  } catch (e) {
    console.log(e);
  }
  await import_fs_extra4.default.mkdir(tinaGeneratedPath);
  await import_fs_extra4.default.writeFile(import_path5.default.join(tinaGeneratedPath, "types.ts"), `
export const queries = (client)=>({})
`);
  await import_fs_extra4.default.outputFile(import_path5.default.join(tinaGeneratedPath, ".gitignore"), "db");
};
var cleanup = async ({ tinaTempPath }) => {
  await import_fs_extra4.default.remove(tinaTempPath);
};
var compileClient = async (ctx, next, options) => {
  const tinaTempPath = import_path5.default.join(tinaGeneratedPath, "temp_client");
  if (!options.clientFileType)
    options = __spreadProps(__spreadValues({}, options), { clientFileType: "ts" });
  if (options.verbose) {
    logger.info(logText("Compiling Client..."));
  }
  const { clientFileType: requestedClientFileType = "ts" } = options;
  const allowedFileTypes = ["ts", "js"];
  if (allowedFileTypes.includes(requestedClientFileType) === false) {
    throw new Error(`Requested schema file type '${requestedClientFileType}' is not valid. Supported schema file types: 'ts, js'`);
  }
  if (ctx) {
    ctx.clientFileType = requestedClientFileType;
  }
  let clientExists = true;
  try {
    getClientPath({ projectDir: tinaPath });
  } catch {
    clientExists = false;
  }
  if (!clientExists) {
    if (options.verbose) {
      logger.info(logText(`.tina/client.${requestedClientFileType} not found, skipping compile client...`));
    }
    return next();
  }
  try {
    const define = {};
    if (!process.env.NODE_ENV) {
      define["process.env.NODE_ENV"] = options.dev ? '"development"' : '"production"';
    }
    const inputFile = getClientPath({ projectDir: tinaPath });
    await transpile(inputFile, "client.js", tinaTempPath, options.verbose, define);
  } catch (e) {
    await cleanup({ tinaTempPath });
    throw new BuildSchemaError(e);
  }
  Object.keys(require.cache).map((key) => {
    if (key.startsWith(tinaTempPath)) {
      delete require.cache[require.resolve(key)];
    }
  });
  try {
    const clientFunc = require(import_path5.default.join(tinaTempPath, "client.js"));
    const client = clientFunc.default;
    ctx.client = client;
    await cleanup({ tinaTempPath });
  } catch (e) {
    await cleanup({ tinaTempPath });
    if (e instanceof Error) {
      if (e.name === "TinaSchemaValidationError") {
        throw e;
      }
    }
    throw new ExecuteSchemaError(e);
  }
  return next();
};
var compileSchema = async (_ctx, _next, options) => {
  const tinaTempPath = import_path5.default.join(tinaGeneratedPath, "temp_schema");
  if (!options.schemaFileType)
    options = __spreadProps(__spreadValues({}, options), { schemaFileType: "ts" });
  if (options.verbose) {
    logger.info(logText("Compiling Schema..."));
  }
  const { schemaFileType: requestedSchemaFileType = "ts" } = options;
  const schemaFileType2 = (requestedSchemaFileType === "ts" || requestedSchemaFileType === "tsx") && "ts" || (requestedSchemaFileType === "js" || requestedSchemaFileType === "jsx") && "js";
  if (!schemaFileType2) {
    throw new Error(`Requested schema file type '${requestedSchemaFileType}' is not valid. Supported schema file types: 'ts, js, tsx, jsx'`);
  }
  if (_ctx) {
    _ctx.schemaFileType = schemaFileType2;
  }
  let schemaExists = true;
  try {
    getSchemaPath({ projectDir: tinaPath });
  } catch {
    schemaExists = false;
  }
  if (!schemaExists) {
    logger.info(dangerText(`
      .tina/schema.${schemaFileType2} not found, Creating one for you...
      See Documentation: https://tina.io/docs/tina-cloud/cli/#getting-started"
      `));
    const file = import_path5.default.join(tinaPath, `schema.${schemaFileType2}`);
    await import_fs_extra4.default.ensureFile(file);
    await import_fs_extra4.default.writeFile(file, defaultSchema);
  }
  try {
    const define = {};
    if (!process.env.NODE_ENV) {
      define["process.env.NODE_ENV"] = options.dev ? '"development"' : '"production"';
    }
    const inputFile = getSchemaPath({ projectDir: tinaPath });
    await transpile(inputFile, "schema.js", tinaTempPath, options.verbose, define);
  } catch (e) {
    await cleanup({ tinaTempPath });
    throw new BuildSchemaError(e);
  }
  Object.keys(require.cache).map((key) => {
    if (key.startsWith(tinaTempPath)) {
      delete require.cache[require.resolve(key)];
    }
  });
  try {
    const schemaFunc = require(import_path5.default.join(tinaTempPath, "schema.js"));
    const schemaObject = schemaFunc.default;
    await import_fs_extra4.default.outputFile(import_path5.default.join(tinaConfigPath, "schema.json"), JSON.stringify(schemaObject, null, 2));
    await cleanup({ tinaTempPath });
  } catch (e) {
    await cleanup({ tinaTempPath });
    if (e instanceof Error) {
      if (e.name === "TinaSchemaValidationError") {
        throw e;
      }
    }
    throw new ExecuteSchemaError(e);
  }
};
var transpile = async (inputFile, outputFile, tempDir, verbose, define) => {
  if (verbose)
    logger.info(logText("Building javascript..."));
  const packageJSON = JSON.parse(import_fs_extra4.default.readFileSync(packageJSONFilePath).toString() || "{}");
  const deps = (packageJSON == null ? void 0 : packageJSON.dependencies) || [];
  const peerDeps = (packageJSON == null ? void 0 : packageJSON.peerDependencies) || [];
  const devDeps = (packageJSON == null ? void 0 : packageJSON.devDependencies) || [];
  const external = Object.keys(__spreadValues(__spreadValues(__spreadValues({}, deps), peerDeps), devDeps));
  const outputPath = import_path5.default.join(tempDir, outputFile);
  await (0, import_esbuild.build)({
    bundle: true,
    platform: "neutral",
    target: ["node10.4"],
    entryPoints: [inputFile],
    treeShaking: true,
    external: [...external, "./node_modules/*"],
    loader: loaders,
    outfile: outputPath,
    define
  });
  if (verbose)
    logger.info(logText(`Javascript built`));
};
var defineSchema = (config) => {
  return config;
};
var loaders = {
  ".aac": "file",
  ".css": "file",
  ".eot": "file",
  ".flac": "file",
  ".gif": "file",
  ".jpeg": "file",
  ".jpg": "file",
  ".json": "json",
  ".mp3": "file",
  ".mp4": "file",
  ".ogg": "file",
  ".otf": "file",
  ".png": "file",
  ".svg": "file",
  ".ttf": "file",
  ".wav": "file",
  ".webm": "file",
  ".webp": "file",
  ".woff": "file",
  ".woff2": "file",
  ".js": "jsx",
  ".jsx": "jsx",
  ".tsx": "tsx"
};

// src/cmds/start-server/index.ts
var import_datalayer3 = __toModule(require("@tinacms/datalayer"));
var import_graphql11 = __toModule(require("@tinacms/graphql"));

// src/cmds/start-server/lock.ts
var AsyncLock = class {
  constructor() {
    this.disable = () => {
    };
    this.promise = Promise.resolve();
  }
  enable() {
    this.promise = new Promise((resolve2) => this.disable = resolve2);
  }
};

// src/cmds/start-server/index.ts
var import_metrics3 = __toModule(require("@tinacms/metrics"));
var import_chalk6 = __toModule(require("chalk"));
var import_chokidar = __toModule(require("chokidar"));
var import_fs_extra6 = __toModule(require("fs-extra"));
var import_ini = __toModule(require("ini"));
var import_os = __toModule(require("os"));
var import_path8 = __toModule(require("path"));
var buildLock = new AsyncLock();
var reBuildLock = new AsyncLock();
var gqlPackageFile = require.resolve("@tinacms/graphql");
var resolveGitRoot = async () => {
  const pathParts = process.cwd().split(import_path8.default.sep);
  while (true) {
    const pathToGit = pathParts.join(import_path8.default.sep);
    if (await import_fs_extra6.default.pathExists(import_path8.default.join(pathToGit, ".git"))) {
      return pathToGit;
    }
    if (!pathParts.length) {
      throw new Error("Unable to locate your .git folder (required for isomorphicGitBridge)");
    }
    pathParts.pop();
  }
};
async function makeIsomorphicOptions(fsBridge) {
  var _a, _b, _c, _d;
  const gitRoot = await resolveGitRoot();
  const options = {
    gitRoot,
    author: {
      name: "",
      email: ""
    },
    onPut: async (filepath, data) => {
      await fsBridge.put(filepath, data);
    },
    onDelete: async (filepath) => {
      await fsBridge.delete(filepath);
    }
  };
  const userGitConfig = `${import_os.default.homedir()}${import_path8.default.sep}.gitconfig`;
  if (await import_fs_extra6.default.pathExists(userGitConfig)) {
    const config = import_ini.default.parse(await import_fs_extra6.default.readFile(userGitConfig, "utf-8"));
    if ((_a = config["user"]) == null ? void 0 : _a["name"]) {
      options.author.name = config["user"]["name"];
    }
    if ((_b = config["user"]) == null ? void 0 : _b["email"]) {
      options.author.email = config["user"]["email"];
    }
  }
  let repoGitConfig = void 0;
  if (!options.author.name) {
    repoGitConfig = import_ini.default.parse(await import_fs_extra6.default.readFile(`${gitRoot}/.git/config`, "utf-8"));
    if ((_c = repoGitConfig["user"]) == null ? void 0 : _c["name"]) {
      options.author.name = repoGitConfig["user"]["name"];
    }
    if (!options.author.name) {
      throw new Error('Unable to determine user.name from git config. Hint: `git config --global user.name "John Doe"`');
    }
  }
  if (!options.author.email) {
    repoGitConfig = repoGitConfig || import_ini.default.parse(await import_fs_extra6.default.readFile(`${gitRoot}/.git/config`, "utf-8"));
    if ((_d = repoGitConfig["user"]) == null ? void 0 : _d["email"]) {
      options.author.email = repoGitConfig["user"]["email"];
    }
    if (!options.author.email) {
      throw new Error("Unable to determine user.email from git config. Hint: `git config --global user.email johndoe@example.com`");
    }
  }
  return options;
}
async function startServer(_ctx, next, {
  port = 4001,
  noWatch,
  experimentalData,
  isomorphicGitBridge: isomorphicGitBridge2,
  noSDK,
  noTelemetry,
  watchFolders,
  verbose,
  dev
}) {
  buildLock.disable();
  reBuildLock.disable();
  const rootPath2 = process.cwd();
  const t = new import_metrics3.Telemetry({ disabled: Boolean(noTelemetry) });
  t.submitRecord({
    event: {
      name: "tinacms:cli:server:start:invoke"
    }
  });
  const fsBridge = new import_datalayer3.FilesystemBridge(rootPath2);
  const isomorphicOptions = isomorphicGitBridge2 && await makeIsomorphicOptions(fsBridge);
  const bridge = isomorphicGitBridge2 ? new import_datalayer3.IsomorphicBridge(rootPath2, isomorphicOptions) : fsBridge;
  const store = experimentalData ? new import_datalayer3.LevelStore(rootPath2) : new import_datalayer3.FilesystemStore({ rootPath: rootPath2 });
  const shouldBuild = bridge.supportsBuilding();
  const database = await (0, import_graphql11.createDatabase)({ store, bridge });
  let ready = false;
  const build2 = async (noSDK2) => {
    database.clearCache();
    await buildLock.promise;
    buildLock.enable();
    try {
      if (!process.env.CI && !noWatch) {
        await store.close();
        await resetGeneratedFolder();
        await store.open();
      }
      const cliFlags = [];
      if (isomorphicGitBridge2) {
        cliFlags.push("isomorphicGitBridge");
      }
      const database2 = await (0, import_graphql11.createDatabase)({ store, bridge });
      await compileSchema(null, null, { verbose, dev });
      const schema = await (0, import_graphql11.buildSchema)(rootPath2, database2, cliFlags);
      await genTypes({ schema }, () => {
      }, { noSDK: noSDK2, verbose });
    } catch (error) {
      throw error;
    } finally {
      buildLock.disable();
    }
  };
  const state = {
    server: null,
    sockets: []
  };
  let isReady = false;
  const start = async () => {
    await buildLock.promise;
    buildLock.enable();
    try {
      const s = (init_server3(), server_exports);
      state.server = await s.default(database);
      state.server.listen(port, () => {
        const altairUrl = `http://localhost:${port}/altair/`;
        const cmsUrl = `[your-development-url]/admin`;
        if (verbose)
          logger.info(`Started Filesystem GraphQL server on port: ${port}`);
        logger.info(`Visit the GraphQL playground at ${import_chalk6.default.underline.blueBright(altairUrl)}
or`);
        logger.info(`Enter the CMS at ${import_chalk6.default.underline.blueBright(cmsUrl)} 
`);
      });
      state.server.on("error", function(e) {
        if (e.code === "EADDRINUSE") {
          logger.error(dangerText(`Port 4001 already in use`));
          process.exit();
        }
        throw e;
      });
      state.server.on("connection", (socket) => {
        state.sockets.push(socket);
      });
    } catch (error) {
      throw error;
    } finally {
      buildLock.disable();
    }
  };
  const restart = async () => {
    return new Promise((resolve2, reject) => {
      logger.info("restarting local server...");
      delete require.cache[gqlPackageFile];
      state.sockets.forEach((socket) => {
        if (socket.destroyed === false) {
          socket.destroy();
        }
      });
      state.sockets = [];
      state.server.close(async () => {
        logger.info("Server closed");
        start().then((x) => resolve2(x)).catch((err) => reject(err));
      });
    });
  };
  const foldersToWatch = (watchFolders || []).map((x) => import_path8.default.join(rootPath2, x));
  if (!noWatch && !process.env.CI) {
    import_chokidar.default.watch([
      ...foldersToWatch,
      `${rootPath2}/.tina/**/*.{ts,gql,graphql,js,tsx,jsx}`,
      gqlPackageFile
    ], {
      ignored: [
        "**/node_modules/**/*",
        "**/.next/**/*",
        `${import_path8.default.resolve(rootPath2)}/.tina/__generated__/**/*`
      ]
    }).on("ready", async () => {
      if (verbose)
        console.log("Generating Tina config");
      try {
        if (shouldBuild) {
          await build2(noSDK);
        }
        ready = true;
        isReady = true;
        await start();
        next();
      } catch (e) {
        handleServerErrors(e);
        console.log(e);
        process.exit(0);
      }
    }).on("all", async () => {
      if (ready) {
        await reBuildLock.promise;
        reBuildLock.enable();
        logger.info("Tina change detected, regenerating config");
        try {
          if (shouldBuild) {
            await build2(noSDK);
          }
          if (isReady) {
            await restart();
          }
        } catch (e) {
          handleServerErrors(e);
          t.submitRecord({
            event: {
              name: "tinacms:cli:server:error",
              errorMessage: e.message
            }
          });
        } finally {
          reBuildLock.disable();
        }
      }
    });
  } else {
    if (process.env.CI) {
      logger.info("Detected CI environment, omitting watch commands...");
    }
    if (shouldBuild) {
      await build2(noSDK);
    }
    await start();
    next();
  }
}

// src/cmds/waitForDB/index.ts
var POLLING_INTERVAL = 5e3;
var STATUS_INPROGRESS = "inprogress";
var STATUS_COMPLETE = "complete";
var STATUS_FAILED = "failed";
var IndexFailedError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "IndexFailedError";
  }
};
var waitForDB = async (ctx, next, options) => {
  if (options.verbose) {
    logger.info(logText("Waiting for DB..."));
  }
  if (!ctx.client) {
    if (options.verbose) {
      logger.info(logText("client is unavailable, skipping..."));
    }
    return next();
  }
  const client = ctx.client;
  const { host, clientId, branch, isLocalClient } = client.parseURL();
  if (isLocalClient) {
    if (options.verbose) {
      logger.info(logText("client is local, skipping..."));
    }
    return next();
  }
  const pollForStatus = async () => {
    try {
      if (options.verbose) {
        logger.info(logText("Polling for status..."));
      }
      const headers = new Headers();
      headers.append("Content-Type", "application/json");
      if (client.readonlyToken) {
        headers.append("X-API-KEY", client.readonlyToken);
      }
      const response = await fetch(`https://${host}/db/${clientId}/status/${branch}`, {
        method: "GET",
        headers
      });
      const { status, error } = await response.json();
      const statusMessage = `DB responded with: '${status}'`;
      if (status === STATUS_COMPLETE) {
        if (options.verbose) {
          logger.info(logText(`${statusMessage}`));
        }
        return next();
      } else if (status === STATUS_INPROGRESS) {
        if (options.verbose) {
          logger.info(logText(`${statusMessage}, trying again in 5 seconds`));
        }
        setTimeout(pollForStatus, POLLING_INTERVAL);
      } else if (status === STATUS_FAILED) {
        throw new IndexFailedError(`Attempting to index DB responded with status 'failed', ${error}`);
      } else {
        if (options.verbose) {
          logger.info(logText(`${statusMessage}`));
        }
        return next();
      }
    } catch (e) {
      if (e instanceof IndexFailedError) {
        throw e;
      } else {
        throw new Error(`Unable to query DB for indexing status, encountered error: ${e.message}`);
      }
    }
  };
  pollForStatus();
};

// src/cmds/startSubprocess/index.ts
var import_child_process = __toModule(require("child_process"));
var startSubprocess = async (_ctx, next, { command }) => {
  if (typeof command === "string") {
    const commands = command.split(" ");
    const firstCommand = commands[0];
    const args = commands.slice(1) || [];
    const ps = import_child_process.default.spawn(firstCommand, args, {
      stdio: "inherit",
      shell: true
    });
    ps.on("error", (code) => {
      logger.error(dangerText(`An error has occurred in the Next.js child process. Error message below`));
      logger.error(`name: ${code.name}
message: ${code.message}

stack: ${code.stack || "No stack was provided"}`);
    });
    ps.on("close", (code) => {
      logger.info(`child process exited with code ${code}`);
      process.exit(code);
    });
  }
};

// src/cmds/baseCmds.ts
var CMD_GEN_TYPES = "schema:types";
var CMD_START_SERVER = "server:start";
var CMD_COMPILE_MODELS = "schema:compile";
var CMD_WAIT_FOR_DB = "server:waitForDB";
var INIT = "init";
var AUDIT = "audit";
var startServerPortOption = {
  name: "--port <port>",
  description: "Specify a port to run the server on. (default 4001)"
};
var experimentalDatalayer = {
  name: "--experimentalData",
  description: "Build the server with additional data querying capabilities"
};
var isomorphicGitBridge = {
  name: "--isomorphicGitBridge",
  description: "Enable Isomorphic Git Bridge Implementation"
};
var schemaFileType = {
  name: "--schemaFileType [fileType]",
  description: "The file type to use for the Tina schema"
};
var subCommand = {
  name: "-c, --command <command>",
  description: "The sub-command to run"
};
var noWatchOption = {
  name: "--noWatch",
  description: "Don't regenerate config on file changes"
};
var noSDKCodegenOption = {
  name: "--noSDK",
  description: "Don't generate the generated client SDK"
};
var cleanOption = {
  name: "--clean",
  description: "Updates all content files to remove any data not explicitly permitted by the current schema definition"
};
var useDefaultValuesOption = {
  name: "--useDefaultValues",
  description: "Adds default values to the graphQL mutation so that default values can be filled into existing documents (useful for adding a field with `required: true`)"
};
var noTelemetryOption = {
  name: "--noTelemetry",
  description: "Disable anonymous telemetry that is collected"
};
var watchFileOption = {
  name: "-w, --watchFolders [folders...]",
  description: "a list of folders (relative to where this is being run) that the cli will watch for changes"
};
var verboseOption = {
  name: "-v, --verbose",
  description: "increase verbosity of logged output",
  defaultValue: false
};
var developmentOption = {
  name: "--dev",
  description: "Uses NODE_ENV=development when compiling client and schema"
};
var baseCmds = [
  {
    command: CMD_START_SERVER,
    description: "Start Filesystem Graphql Server",
    options: [
      startServerPortOption,
      subCommand,
      experimentalDatalayer,
      isomorphicGitBridge,
      noWatchOption,
      noSDKCodegenOption,
      noTelemetryOption,
      watchFileOption,
      verboseOption,
      developmentOption
    ],
    action: (options) => chain([startServer, startSubprocess], options)
  },
  {
    command: CMD_WAIT_FOR_DB,
    description: "Wait for DB to finish indexing, start subprocess",
    options: [
      subCommand,
      experimentalDatalayer,
      isomorphicGitBridge,
      noTelemetryOption,
      verboseOption,
      developmentOption
    ],
    action: (options) => chain([compileClient, waitForDB, startSubprocess], options)
  },
  {
    command: CMD_COMPILE_MODELS,
    description: "Compile schema into static files for the server",
    options: [experimentalDatalayer, isomorphicGitBridge, noTelemetryOption],
    action: (options) => chain([compileSchema], options)
  },
  {
    command: CMD_GEN_TYPES,
    description: "Generate a GraphQL query for your site's schema, (and optionally Typescript types)",
    options: [
      experimentalDatalayer,
      isomorphicGitBridge,
      noSDKCodegenOption,
      noTelemetryOption
    ],
    action: (options) => chain([attachSchema, genTypes], options)
  },
  {
    command: INIT,
    options: [
      experimentalDatalayer,
      isomorphicGitBridge,
      noTelemetryOption,
      schemaFileType
    ],
    description: "Add Tina Cloud to an existing project",
    action: (options) => chain([
      checkDeps,
      initTina,
      installDeps,
      async (_ctx, next, options2) => {
        await compileSchema(_ctx, next, options2);
        next();
      },
      attachSchema,
      genTypes,
      tinaSetup,
      successMessage
    ], options)
  },
  {
    options: [cleanOption, useDefaultValuesOption, noTelemetryOption],
    command: AUDIT,
    description: "Audit your schema and the files to check for errors",
    action: (options) => chain([
      async (_ctx, next) => {
        logger.level = "error";
        next();
      },
      async (_ctx, next) => {
        await compileSchema(_ctx, next, options);
        next();
      },
      attachSchema,
      genTypes,
      async (_ctx, next) => {
        logger.level = "info";
        logger.info(import_chalk7.default.hex("#eb6337").bgWhite("Welcome to tina audit \u{1F999}"));
        next();
      },
      audit,
      printFinalMessage
    ], options)
  }
];

// src/index.ts
var program = new commander.Command(name);
var registerCommands = (commands, noHelp = false) => {
  commands.forEach((command, i) => {
    let newCmd = program.command(command.command, { noHelp }).description(command.description).action((...args) => {
      logger.info("");
      command.action(...args);
    });
    if (command.alias) {
      newCmd = newCmd.alias(command.alias);
    }
    newCmd.on("--help", function() {
      if (command.examples) {
        logger.info(`
Examples:
  ${command.examples}`);
      }
      if (command.subCommands) {
        logger.info("\nCommands:");
        const optionTag = " [options]";
        command.subCommands.forEach((subcommand, i2) => {
          const commandStr = `${subcommand.command}${(subcommand.options || []).length ? optionTag : ""}`;
          const padLength = Math.max(...command.subCommands.map((sub) => sub.command.length)) + optionTag.length;
          logger.info(`${commandStr.padEnd(padLength)} ${subcommand.description}`);
        });
      }
      logger.info("");
    });
    (command.options || []).forEach((option) => {
      newCmd.option(option.name, option.description, option == null ? void 0 : option.defaultValue);
    });
    if (command.subCommands) {
      registerCommands(command.subCommands, true);
    }
  });
};
async function init(args) {
  program.version(version);
  const commands = [...baseCmds];
  registerCommands(commands);
  program.usage("command [options]");
  program.on("command:*", function() {
    logger.error("Invalid command: %s\nSee --help for a list of available commands.", args.join(" "));
    process.exit(1);
  });
  program.on("--help", function() {
    logger.info(logText(`
You can get help on any command with "-h" or "--help".
e.g: "tinacms server:start --help"
    `));
  });
  if (!process.argv.slice(2).length) {
    program.help();
  }
  program.parse(args);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  defineSchema,
  init
});
