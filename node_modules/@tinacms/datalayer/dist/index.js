var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/datalayer/src/index.ts
__export(exports, {
  FilesystemBridge: () => FilesystemBridge,
  FilesystemStore: () => FilesystemStore,
  GithubBridge: () => GithubBridge,
  GithubStore: () => GithubStore,
  LevelStore: () => LevelStore,
  MemoryStore: () => MemoryStore
});

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/datalayer/src/database/bridge/github.ts
var import_lodash = __toModule(require("lodash"));
var import_path = __toModule(require("path"));
var import_rest = __toModule(require("@octokit/rest"));
var import_graphql = __toModule(require("graphql"));
var GithubBridge = class {
  constructor({ rootPath, accessToken, owner, repo, ref }) {
    this.rootPath = rootPath;
    this.repoConfig = {
      owner,
      repo,
      ref
    };
    this.appOctoKit = new import_rest.Octokit({
      auth: accessToken
    });
  }
  async readDir(filepath) {
    const fullPath = import_path.default.join(this.rootPath, filepath);
    const repos = await this.appOctoKit.repos.getContent(__spreadProps(__spreadValues({}, this.repoConfig), {
      path: fullPath
    })).then(async (response) => {
      if (Array.isArray(response.data)) {
        return await Promise.all(await response.data.map(async (d) => {
          if (d.type === "dir") {
            const nestedItems = await this.readDir(d.path);
            if (Array.isArray(nestedItems)) {
              return nestedItems.map((nestedItem) => {
                return import_path.default.join(d.path, nestedItem);
              });
            } else {
              throw new Error(`Expected items to be an array of strings for readDir at ${d.path}`);
            }
          }
          return d.path;
        }));
      }
      throw new Error(`Expected to return an array from Github directory ${import_path.default}`);
    });
    return import_lodash.default.flatten(repos);
  }
  supportsBuilding() {
    return false;
  }
  async glob(pattern) {
    const results = await this.readDir(pattern);
    return results.map((item) => item.replace(this.rootPath, "").replace(/^\/|\/$/g, ""));
  }
  async get(filepath) {
    const realpath = import_path.default.join(this.rootPath, filepath);
    return this.appOctoKit.repos.getContent(__spreadProps(__spreadValues({}, this.repoConfig), {
      path: realpath
    })).then((response) => {
      return Buffer.from(response.data.content, "base64").toString();
    }).catch((e) => {
      if (e.status === 401) {
        throw new import_graphql.GraphQLError(`Unauthorized request to Github Repository: '${this.repoConfig.owner}/${this.repoConfig.repo}', please ensure your access token is valid.`, null, null, null, null, e, { status: e.status });
      }
      throw new import_graphql.GraphQLError(`Unable to find record '${filepath}' in Github Repository: '${this.repoConfig.owner}/${this.repoConfig.repo}', Ref: '${this.repoConfig.ref}'`, null, null, null, null, e, { status: e.status });
    });
  }
  async putConfig(filepath, data) {
    throw new Error(`Config files cannot be changed by the Github bridge`);
  }
  async put(filepath, data) {
    const realpath = import_path.default.join(this.rootPath, filepath);
    let fileSha = void 0;
    try {
      const fileContent = await this.appOctoKit.repos.getContent(__spreadProps(__spreadValues({}, this.repoConfig), {
        path: realpath
      }));
      fileSha = fileContent.data.sha;
    } catch (e) {
      console.log("No file exists, creating new one");
    }
    await this.appOctoKit.repos.createOrUpdateFileContents(__spreadProps(__spreadValues({}, this.repoConfig), {
      branch: this.repoConfig.ref,
      path: realpath,
      message: "Update from GraphQL client",
      content: new Buffer(data).toString("base64"),
      sha: fileSha
    }));
  }
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/datalayer/src/database/store/github.ts
var import_lodash2 = __toModule(require("lodash"));
var import_path2 = __toModule(require("path"));
var import_rest2 = __toModule(require("@octokit/rest"));

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/datalayer/src/database/util.ts
var import_gray_matter = __toModule(require("gray-matter"));

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/datalayer/src/util.ts
var yup = __toModule(require("yup"));
var import_graphql2 = __toModule(require("graphql"));
var sequential = async (items, callback) => {
  const accum = [];
  if (!items) {
    return [];
  }
  const reducePromises = async (previous, endpoint) => {
    const prev = await previous;
    if (prev) {
      accum.push(prev);
    }
    return callback(endpoint, accum.length);
  };
  const result = await items.reduce(reducePromises, Promise.resolve());
  if (result) {
    accum.push(result);
  }
  return accum;
};
function assertShape(value, yupSchema, errorMessage) {
  const shape = yupSchema(yup);
  try {
    shape.validateSync(value);
  } catch (e) {
    const message = errorMessage || `Failed to assertShape - ${e.message}`;
    throw new import_graphql2.GraphQLError(message, null, null, null, null, null, {
      stack: e.stack
    });
  }
}

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/datalayer/src/database/util.ts
var stringifyFile = (content, format, keepTemplateKey) => {
  switch (format) {
    case ".markdown":
    case ".mdx":
    case ".md":
      const _a = content, {
        _relativePath,
        _keepTemplateKey,
        _id,
        _template,
        _collection,
        $_body
      } = _a, rest = __objRest(_a, [
        "_relativePath",
        "_keepTemplateKey",
        "_id",
        "_template",
        "_collection",
        "$_body"
      ]);
      const extra = {};
      if (keepTemplateKey) {
        extra["_template"] = _template;
      }
      const ok = import_gray_matter.default.stringify(typeof $_body === "undefined" ? "" : `
${$_body}`, __spreadValues(__spreadValues({}, rest), extra));
      return ok;
    case ".json":
      return JSON.stringify(content, null, 2);
    default:
      throw new Error(`Must specify a valid format, got ${format}`);
  }
};
var parseFile = (content, format, yupSchema) => {
  switch (format) {
    case ".markdown":
    case ".mdx":
    case ".md":
      const contentJSON = (0, import_gray_matter.default)(content || "");
      const markdownData = __spreadProps(__spreadValues({}, contentJSON.data), {
        $_body: contentJSON.content
      });
      assertShape(markdownData, yupSchema);
      return markdownData;
    case ".json":
      if (!content) {
        return {};
      }
      return JSON.parse(content);
    default:
      throw new Error(`Must specify a valid format, got ${format}`);
  }
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/datalayer/src/database/store/github.ts
var import_graphql3 = __toModule(require("graphql"));
var GithubStore = class {
  async clear() {
  }
  async print() {
  }
  constructor({ rootPath, accessToken, owner, repo, ref }) {
    this.rootPath = rootPath;
    this.repoConfig = {
      owner,
      repo,
      ref
    };
    this.appOctoKit = new import_rest2.Octokit({
      auth: accessToken
    });
  }
  async query(queryStrings) {
    throw new Error(`Unable to perform query for GithubStore`);
  }
  supportsSeeding() {
    return false;
  }
  async seed() {
    throw new Error(`Seeding data is not possible for Github data store`);
  }
  async readDir(filepath) {
    const fullPath = import_path2.default.join(this.rootPath, filepath);
    const repos = await this.appOctoKit.repos.getContent(__spreadProps(__spreadValues({}, this.repoConfig), {
      path: fullPath
    })).then(async (response) => {
      if (Array.isArray(response.data)) {
        return await Promise.all(await response.data.map(async (d) => {
          if (d.type === "dir") {
            const nestedItems = await this.readDir(d.path);
            if (Array.isArray(nestedItems)) {
              return nestedItems.map((nestedItem) => {
                return import_path2.default.join(d.path, nestedItem);
              });
            } else {
              throw new Error(`Expected items to be an array of strings for readDir at ${d.path}`);
            }
          }
          return d.path;
        }));
      }
      throw new Error(`Expected to return an array from Github directory ${import_path2.default}`);
    });
    return import_lodash2.default.flatten(repos);
  }
  async glob(pattern, callback) {
    const results = await this.readDir(pattern);
    const items = results.map((item) => item.replace(this.rootPath, "").replace(/^\/|\/$/g, ""));
    if (callback) {
      return sequential(items, async (item) => {
        return callback(item);
      });
    } else {
      return items;
    }
  }
  async get(filepath) {
    const realpath = import_path2.default.join(this.rootPath, filepath);
    return this.appOctoKit.repos.getContent(__spreadProps(__spreadValues({}, this.repoConfig), {
      path: realpath
    })).then((response) => {
      const responseString = Buffer.from(response.data.content, "base64").toString();
      return parseFile(responseString, import_path2.default.extname(filepath), (yup2) => yup2.object());
    }).catch((e) => {
      if (e.status === 401) {
        throw new import_graphql3.GraphQLError(`Unauthorized request to Github Repository: '${this.repoConfig.owner}/${this.repoConfig.repo}', please ensure your access token is valid.`, null, null, null, null, e, { status: e.status });
      }
      throw new import_graphql3.GraphQLError(`Unable to find record '${filepath}' in Github Repository: '${this.repoConfig.owner}/${this.repoConfig.repo}', Ref: '${this.repoConfig.ref}'`, null, null, null, null, e, { status: e.status });
    });
  }
  supportsIndexing() {
    return false;
  }
  async put(filepath, data) {
    const realpath = import_path2.default.join(this.rootPath, filepath);
    let fileSha = void 0;
    try {
      const fileContent = await this.appOctoKit.repos.getContent(__spreadProps(__spreadValues({}, this.repoConfig), {
        path: realpath
      }));
      fileSha = fileContent.data.sha;
    } catch (e) {
      console.log("No file exists, creating new one");
    }
    await this.appOctoKit.repos.createOrUpdateFileContents(__spreadProps(__spreadValues({}, this.repoConfig), {
      branch: this.repoConfig.ref,
      path: realpath,
      message: "Update from GraphQL client",
      content: new Buffer(stringifyFile(data, import_path2.default.extname(filepath), false)).toString("base64"),
      sha: fileSha
    }));
  }
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/datalayer/src/database/bridge/filesystem.ts
var import_fs_extra = __toModule(require("fs-extra"));
var import_fast_glob = __toModule(require("fast-glob"));
var import_path3 = __toModule(require("path"));
var import_normalize_path = __toModule(require("normalize-path"));
var FilesystemBridge = class {
  constructor(rootPath) {
    this.rootPath = rootPath || "";
  }
  async glob(pattern) {
    const basePath = import_path3.default.join(this.rootPath, ...pattern.split("/"));
    const items = await (0, import_fast_glob.default)(import_path3.default.join(basePath, "**", "/*").replace(/\\/g, "/"), {
      dot: true
    });
    const posixRootPath = (0, import_normalize_path.default)(this.rootPath);
    return items.map((item) => {
      return item.replace(posixRootPath, "").replace(/^\/|\/$/g, "");
    });
  }
  supportsBuilding() {
    return true;
  }
  async get(filepath) {
    return import_fs_extra.default.readFileSync(import_path3.default.join(this.rootPath, filepath)).toString();
  }
  async putConfig(filepath, data) {
    await this.put(filepath, data);
  }
  async put(filepath, data) {
    await import_fs_extra.default.outputFileSync(import_path3.default.join(this.rootPath, filepath), data);
  }
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/datalayer/src/database/store/filesystem.ts
var import_fs_extra2 = __toModule(require("fs-extra"));
var import_fast_glob2 = __toModule(require("fast-glob"));
var import_path4 = __toModule(require("path"));
var import_normalize_path2 = __toModule(require("normalize-path"));
var FilesystemStore = class {
  async clear() {
  }
  async print() {
  }
  constructor({ rootPath }) {
    this.rootPath = rootPath || "";
  }
  async query(queryStrings) {
    throw new Error(`Unable to perform query for Filesystem store`);
  }
  async seed() {
    throw new Error(`Seeding data is not possible for Filesystem store`);
  }
  async get(filepath) {
    return parseFile(await import_fs_extra2.default.readFileSync(import_path4.default.join(this.rootPath, filepath)).toString(), import_path4.default.extname(filepath), (yup2) => yup2.object());
  }
  supportsSeeding() {
    return false;
  }
  supportsIndexing() {
    return false;
  }
  async glob(pattern, callback) {
    const basePath = import_path4.default.join(this.rootPath, ...pattern.split("/"));
    const itemsRaw = await (0, import_fast_glob2.default)(import_path4.default.join(basePath, "**", "/*").replace(/\\/g, "/"), {
      dot: true
    });
    const posixRootPath = (0, import_normalize_path2.default)(this.rootPath);
    const items = itemsRaw.map((item) => {
      return item.replace(posixRootPath, "").replace(/^\/|\/$/g, "");
    });
    if (callback) {
      return sequential(items, async (item) => {
        return callback(item);
      });
    } else {
      return items;
    }
  }
  async put(filepath, data) {
    await import_fs_extra2.default.outputFileSync(import_path4.default.join(this.rootPath, filepath), stringifyFile(data, import_path4.default.extname(filepath), false));
  }
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/datalayer/src/database/store/memory.ts
var MemoryStore = class {
  constructor(rootPath, object = {}) {
    this.map = object;
    this.rootPath = rootPath || "";
    this.db = {
      get: async (filepath) => {
        return this.map[filepath];
      },
      put: async (filepath, content) => {
        this.map[filepath] = content;
        await this.print();
      }
    };
  }
  async query(queryStrings, hydrator) {
    const resultSets = await sequential(queryStrings, async (queryString) => {
      const res = await this.get(queryString);
      return res || [];
    });
    let items = [];
    if (resultSets.length > 0) {
      items = resultSets.reduce((p, c) => p.filter((e) => c.includes(e)));
    }
    return sequential(items, async (documentString) => {
      return hydrator(documentString);
    });
  }
  async seed(filepath, data) {
    await this.put(filepath, data);
  }
  supportsSeeding() {
    return true;
  }
  supportsIndexing() {
    return true;
  }
  async print() {
  }
  async clear() {
    this.map = {};
  }
  async glob(pattern, callback) {
    const strings = Object.keys(this.map).filter((key) => {
      if (key.startsWith(pattern)) {
        return true;
      } else {
        return false;
      }
    });
    if (callback) {
      return sequential(strings, async (item) => {
        return callback(item);
      });
    } else {
      return strings;
    }
  }
  async get(filepath) {
    const content = await this.db.get(filepath);
    return content;
  }
  async put(filepath, data) {
    await this.db.put(filepath, data);
  }
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/datalayer/src/database/store/level.ts
var import_path5 = __toModule(require("path"));
var import_level = __toModule(require("level"));
var import_levelup = __toModule(require("levelup"));
var import_memdown = __toModule(require("memdown"));
var import_encoding_down = __toModule(require("encoding-down"));
var LevelStore = class {
  constructor(rootPath, useMemory = false) {
    this.rootPath = rootPath || "";
    if (useMemory) {
      const db = (0, import_levelup.default)((0, import_encoding_down.default)((0, import_memdown.default)(), { valueEncoding: "json" }));
      this.db = db;
    } else {
      const db = (0, import_level.default)(import_path5.default.join(rootPath, ".tina/__generated__/db"), {
        valueEncoding: "json"
      });
      this.db = db;
    }
  }
  async query(queryStrings, hydrator) {
    const resultSets = await sequential(queryStrings, async (queryString) => {
      let strings = [];
      const p = new Promise((resolve, reject) => {
        this.db.createReadStream({
          gte: queryString,
          lte: queryString + "\xFF"
        }).on("data", (data) => {
          strings = [...strings, ...data.value];
        }).on("error", (message) => {
          reject(message);
        }).on("end", function() {
          resolve();
        });
      });
      await p;
      return strings || [];
    });
    let items = [];
    if (resultSets.length > 0) {
      items = resultSets.reduce((p, c) => p.filter((e) => c.includes(e)));
    }
    return sequential(items, async (documentString) => {
      return hydrator(documentString);
    });
  }
  async seed(filepath, data) {
    await this.put(filepath, data);
  }
  supportsSeeding() {
    return true;
  }
  supportsIndexing() {
    return true;
  }
  async print() {
    this.db.createReadStream().on("data", function(data) {
      console.log(data.key, "=", data.value);
    }).on("error", function(err) {
      console.log("Oh my!", err);
    }).on("close", function() {
      console.log("Stream closed");
    }).on("end", function() {
      console.log("Stream ended");
    });
  }
  async open() {
    await this.db.open();
  }
  async clear() {
    await this.db.clear();
  }
  async glob(pattern, callback) {
    const strings = [];
    const p = new Promise((resolve, reject) => {
      this.db.createKeyStream({
        gte: pattern,
        lte: pattern + "\xFF"
      }).on("data", (data) => {
        strings.push(data);
      }).on("error", (message) => {
        reject(message);
      }).on("end", function() {
        resolve();
      });
    });
    await p;
    if (callback) {
      return sequential(strings, async (item) => {
        return callback(item);
      });
    } else {
      return strings;
    }
  }
  async get(filepath) {
    try {
      const content = await this.db.get(filepath);
      return content;
    } catch (e) {
      return void 0;
    }
  }
  async put(filepath, data) {
    await this.db.put(filepath, data);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  FilesystemBridge,
  FilesystemStore,
  GithubBridge,
  GithubStore,
  LevelStore,
  MemoryStore
});
