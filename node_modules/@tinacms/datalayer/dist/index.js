var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/index.ts
__export(exports, {
  AuditFileSystemBridge: () => AuditFileSystemBridge,
  AuditFilesystemStore: () => AuditFilesystemStore,
  DEFAULT_COLLECTION_SORT_KEY: () => DEFAULT_COLLECTION_SORT_KEY,
  DEFAULT_NUMERIC_LPAD: () => DEFAULT_NUMERIC_LPAD,
  FilesystemBridge: () => FilesystemBridge,
  FilesystemStore: () => FilesystemStore,
  INDEX_KEY_FIELD_SEPARATOR: () => INDEX_KEY_FIELD_SEPARATOR,
  IsomorphicBridge: () => IsomorphicBridge,
  LevelStore: () => LevelStore,
  OP: () => OP,
  atob: () => atob,
  btoa: () => btoa,
  coerceFilterChainOperands: () => coerceFilterChainOperands,
  makeFilter: () => makeFilter,
  makeFilterChain: () => makeFilterChain,
  makeFilterSuffixes: () => makeFilterSuffixes,
  makeKeyForField: () => makeKeyForField,
  makeStringEscaper: () => makeStringEscaper
});

// src/database/bridge/filesystem.ts
var import_fs_extra = __toModule(require("fs-extra"));
var import_fast_glob = __toModule(require("fast-glob"));
var import_path = __toModule(require("path"));
var import_normalize_path = __toModule(require("normalize-path"));
var FilesystemBridge = class {
  constructor(rootPath) {
    this.rootPath = rootPath || "";
  }
  async glob(pattern, extension) {
    const basePath = import_path.default.join(this.rootPath, ...pattern.split("/"));
    const items = await (0, import_fast_glob.default)(import_path.default.join(basePath, "**", `/*${extension}`).replace(/\\/g, "/"), {
      dot: true
    });
    const posixRootPath = (0, import_normalize_path.default)(this.rootPath);
    return items.map((item) => {
      return item.replace(posixRootPath, "").replace(/^\/|\/$/g, "");
    });
  }
  supportsBuilding() {
    return true;
  }
  async delete(filepath) {
    await import_fs_extra.default.remove(import_path.default.join(this.rootPath, filepath));
  }
  async get(filepath) {
    return import_fs_extra.default.readFileSync(import_path.default.join(this.rootPath, filepath)).toString();
  }
  async putConfig(filepath, data) {
    await this.put(filepath, data);
  }
  async put(filepath, data) {
    await import_fs_extra.default.outputFileSync(import_path.default.join(this.rootPath, filepath), data);
  }
};
var AuditFileSystemBridge = class extends FilesystemBridge {
  async put(_filepath, _data) {
    return;
  }
};

// src/database/bridge/isomorphic.ts
var import_isomorphic_git = __toModule(require("isomorphic-git"));
var import_fs_extra2 = __toModule(require("fs-extra"));
var import_glob_parent = __toModule(require("glob-parent"));
var import_normalize_path2 = __toModule(require("normalize-path"));
var import_graphql = __toModule(require("graphql"));
var flat = typeof Array.prototype.flat === "undefined" ? (entries) => entries.reduce((acc, x) => acc.concat(x), []) : (entries) => entries.flat();
var toUint8Array = (buf) => {
  const ab = new ArrayBuffer(buf.length);
  const view = new Uint8Array(ab);
  for (let i = 0; i < buf.length; ++i) {
    view[i] = buf[i];
  }
  return view;
};
var IsomorphicBridge = class {
  constructor(rootPath, {
    gitRoot,
    author,
    committer,
    fsModule = import_fs_extra2.default,
    commitMessage = "Update from GraphQL client",
    ref,
    onPut,
    onDelete
  }) {
    this.cache = {};
    this.rootPath = rootPath;
    this.gitRoot = gitRoot;
    this.relativePath = rootPath.slice(this.gitRoot.length).replace(/\\/g, "/");
    if (this.relativePath.startsWith("/")) {
      this.relativePath = this.relativePath.slice(1);
    }
    this.fsModule = fsModule;
    this.author = author;
    this.committer = committer || author;
    this.isomorphicConfig = {
      dir: (0, import_normalize_path2.default)(this.gitRoot),
      fs: this.fsModule
    };
    this.ref = ref;
    this.commitMessage = commitMessage;
    this.onPut = onPut || (() => {
    });
    this.onDelete = onDelete || (() => {
    });
  }
  getAuthor() {
    return __spreadProps(__spreadValues({}, this.author), {
      timestamp: Math.round(new Date().getTime() / 1e3),
      timezoneOffset: 0
    });
  }
  getCommitter() {
    return __spreadProps(__spreadValues({}, this.committer), {
      timestamp: Math.round(new Date().getTime() / 1e3),
      timezoneOffset: 0
    });
  }
  async listEntries({
    pattern,
    entry,
    path: path4,
    results
  }) {
    const treeResult = await import_isomorphic_git.default.readTree(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
      oid: entry.oid,
      cache: this.cache
    }));
    const children = [];
    for (const childEntry of treeResult.tree) {
      const childPath = path4 ? `${path4}/${childEntry.path}` : childEntry.path;
      if (childEntry.type === "tree") {
        children.push(childEntry);
      } else {
        if (childPath.startsWith(pattern)) {
          results.push(childPath);
        }
      }
    }
    for (const childEntry of children) {
      const childPath = path4 ? `${path4}/${childEntry.path}` : childEntry.path;
      await this.listEntries({
        pattern,
        entry: childEntry,
        path: childPath,
        results
      });
    }
  }
  async resolvePathEntries(path4, ref) {
    let pathParts = path4.split("/");
    const result = await import_isomorphic_git.default.walk(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
      map: async (filepath, [head]) => {
        if (head._fullpath === "." || path4.startsWith(filepath)) {
          return head;
        }
      },
      cache: this.cache,
      trees: [import_isomorphic_git.default.TREE({ ref })]
    }));
    const pathEntries = flat(result);
    if (pathParts.indexOf(".") === -1) {
      pathParts = [".", ...pathParts];
    }
    while (pathParts.length > pathEntries.length) {
      pathEntries.push(null);
    }
    return { pathParts, pathEntries };
  }
  async updateTreeHierarchy(existingOid, updatedOid, path4, type, pathEntries, pathParts) {
    const lastIdx = pathEntries.length - 1;
    const parentEntry = pathEntries[lastIdx];
    const parentPath = pathParts[lastIdx];
    let parentOid;
    let tree;
    const mode = type === "blob" ? "100644" : "040000";
    if (parentEntry) {
      parentOid = await parentEntry.oid();
      const treeResult = await import_isomorphic_git.default.readTree(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
        oid: parentOid,
        cache: this.cache
      }));
      tree = existingOid ? treeResult.tree.map((entry) => {
        if (entry.path === path4) {
          entry.oid = updatedOid;
        }
        return entry;
      }) : [
        ...treeResult.tree,
        {
          oid: updatedOid,
          type,
          path: path4,
          mode
        }
      ];
    } else {
      tree = [
        {
          oid: updatedOid,
          type,
          path: path4,
          mode
        }
      ];
    }
    const updatedParentOid = await import_isomorphic_git.default.writeTree(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
      tree
    }));
    if (lastIdx === 0) {
      return updatedParentOid;
    } else {
      return await this.updateTreeHierarchy(parentOid, updatedParentOid, parentPath, "tree", pathEntries.slice(0, lastIdx), pathParts.slice(0, lastIdx));
    }
  }
  async commitTree(treeSha, ref) {
    const commitSha = await import_isomorphic_git.default.writeCommit(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
      commit: {
        tree: treeSha,
        parent: [
          await import_isomorphic_git.default.resolveRef(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
            ref
          }))
        ],
        message: this.commitMessage,
        author: this.getAuthor(),
        committer: this.getCommitter()
      }
    }));
    await import_isomorphic_git.default.writeRef(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
      ref,
      value: commitSha,
      force: true
    }));
  }
  async getRef() {
    if (this.ref) {
      return this.ref;
    }
    const ref = await import_isomorphic_git.default.currentBranch(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
      fullname: true
    }));
    if (!ref) {
      throw new import_graphql.GraphQLError(`Unable to determine current branch from HEAD`, null, null, null, null, null, {});
    }
    this.ref = ref;
    return ref;
  }
  async glob(pattern, extension) {
    const ref = await this.getRef();
    const parent = (0, import_glob_parent.default)(this.qualifyPath(pattern));
    const { pathParts, pathEntries } = await this.resolvePathEntries(parent, ref);
    const leafEntry = pathEntries[pathEntries.length - 1];
    const entryPath = pathParts[pathParts.length - 1];
    const parentEntry = pathEntries[pathEntries.length - 2];
    let treeEntry;
    let parentPath;
    if (parentEntry) {
      const treeResult = await import_isomorphic_git.default.readTree(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
        oid: await parentEntry.oid(),
        cache: this.cache
      }));
      treeEntry = treeResult.tree.find((entry) => entry.path === entryPath);
      parentPath = pathParts.slice(1, pathParts.length).join("/");
    } else {
      treeEntry = {
        type: "tree",
        oid: await leafEntry.oid()
      };
      parentPath = "";
    }
    const results = [];
    await this.listEntries({
      pattern: this.qualifyPath(pattern),
      entry: treeEntry,
      path: parentPath,
      results
    });
    return results.map((path4) => this.unqualifyPath(path4)).filter((path4) => path4.endsWith(extension));
  }
  supportsBuilding() {
    return true;
  }
  async delete(filepath) {
    const ref = await this.getRef();
    const { pathParts, pathEntries } = await this.resolvePathEntries(this.qualifyPath(filepath), ref);
    let oidToRemove;
    let ptr = pathEntries.length - 1;
    while (ptr >= 1) {
      const leafEntry = pathEntries[ptr];
      const nodePath = pathParts[ptr];
      if (leafEntry) {
        oidToRemove = oidToRemove || await leafEntry.oid();
        const parentEntry = pathEntries[ptr - 1];
        const existingOid = await parentEntry.oid();
        const treeResult = await import_isomorphic_git.default.readTree(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
          oid: existingOid,
          cache: this.cache
        }));
        const updatedTree = treeResult.tree.filter((value) => value.path !== nodePath);
        if (updatedTree.length === 0) {
          ptr -= 1;
          continue;
        }
        const updatedTreeOid = await import_isomorphic_git.default.writeTree(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
          tree: updatedTree
        }));
        const updatedRootTreeOid = await this.updateTreeHierarchy(existingOid, updatedTreeOid, pathParts[ptr - 1], "tree", pathEntries.slice(0, ptr - 1), pathParts.slice(0, ptr - 1));
        await this.commitTree(updatedRootTreeOid, ref);
        break;
      } else {
        throw new import_graphql.GraphQLError(`Unable to resolve path: ${filepath}`, null, null, null, null, null, { status: 404 });
      }
    }
    if (oidToRemove) {
      await import_isomorphic_git.default.updateIndex(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
        filepath: this.qualifyPath(filepath),
        force: true,
        remove: true,
        oid: oidToRemove,
        cache: this.cache
      }));
    }
    await this.onDelete(filepath);
  }
  qualifyPath(filepath) {
    return this.relativePath ? `${this.relativePath}/${filepath}` : filepath;
  }
  unqualifyPath(filepath) {
    return this.relativePath ? filepath.slice(this.relativePath.length + 1) : filepath;
  }
  async get(filepath) {
    const ref = await this.getRef();
    const oid = await import_isomorphic_git.default.resolveRef(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
      ref
    }));
    const { blob } = await import_isomorphic_git.default.readBlob(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
      oid,
      filepath: this.qualifyPath(filepath),
      cache: this.cache
    }));
    return Buffer.from(blob).toString("utf8");
  }
  async putConfig(filepath, data) {
    await this.put(filepath, data);
  }
  async put(filepath, data) {
    const ref = await this.getRef();
    const { pathParts, pathEntries } = await this.resolvePathEntries(this.qualifyPath(filepath), ref);
    const blobUpdate = toUint8Array(Buffer.from(data));
    let existingOid;
    const leafEntry = pathEntries[pathEntries.length - 1];
    const nodePath = pathParts[pathParts.length - 1];
    if (leafEntry) {
      existingOid = await leafEntry.oid();
      const hash = await import_isomorphic_git.default.hashBlob({ object: blobUpdate });
      if (hash.oid === existingOid) {
        await this.onPut(filepath, data);
        return;
      }
    }
    const updatedOid = await import_isomorphic_git.default.writeBlob(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
      blob: blobUpdate
    }));
    const updatedRootSha = await this.updateTreeHierarchy(existingOid, updatedOid, nodePath, "blob", pathEntries.slice(0, pathEntries.length - 1), pathParts.slice(0, pathParts.length - 1));
    await this.commitTree(updatedRootSha, ref);
    await import_isomorphic_git.default.updateIndex(__spreadProps(__spreadValues({}, this.isomorphicConfig), {
      filepath: this.qualifyPath(filepath),
      add: true,
      oid: updatedOid,
      cache: this.cache
    }));
    await this.onPut(filepath, data);
  }
};

// src/database/store/filesystem.ts
var import_fs_extra3 = __toModule(require("fs-extra"));
var import_fast_glob2 = __toModule(require("fast-glob"));
var import_path2 = __toModule(require("path"));
var import_normalize_path3 = __toModule(require("normalize-path"));

// src/database/util.ts
var import_gray_matter = __toModule(require("gray-matter"));

// src/util.ts
var yup = __toModule(require("yup"));
var import_graphql2 = __toModule(require("graphql"));
var sequential = async (items, callback) => {
  const accum = [];
  if (!items) {
    return [];
  }
  const reducePromises = async (previous, endpoint) => {
    const prev = await previous;
    if (prev) {
      accum.push(prev);
    }
    return callback(endpoint, accum.length);
  };
  const result = await items.reduce(reducePromises, Promise.resolve());
  if (result) {
    accum.push(result);
  }
  return accum;
};
function assertShape(value, yupSchema, errorMessage) {
  const shape = yupSchema(yup);
  try {
    shape.validateSync(value);
  } catch (e) {
    const message = errorMessage || `Failed to assertShape - ${e.message}`;
    throw new import_graphql2.GraphQLError(message, null, null, null, null, null, {
      stack: e.stack
    });
  }
}
var atob = (b64Encoded) => {
  return Buffer.from(b64Encoded, "base64").toString();
};
var btoa = (string) => {
  return Buffer.from(string).toString("base64");
};

// src/database/util.ts
var stringifyFile = (content, format, keepTemplateKey) => {
  switch (format) {
    case ".markdown":
    case ".mdx":
    case ".md":
      const _a = content, {
        _relativePath,
        _keepTemplateKey,
        _id,
        _template,
        _collection,
        $_body
      } = _a, rest = __objRest(_a, [
        "_relativePath",
        "_keepTemplateKey",
        "_id",
        "_template",
        "_collection",
        "$_body"
      ]);
      const extra = {};
      if (keepTemplateKey) {
        extra["_template"] = _template;
      }
      const ok = import_gray_matter.default.stringify(typeof $_body === "undefined" ? "" : `
${$_body}`, __spreadValues(__spreadValues({}, rest), extra));
      return ok;
    case ".json":
      return JSON.stringify(content, null, 2);
    default:
      throw new Error(`Must specify a valid format, got ${format}`);
  }
};
var parseFile = (content, format, yupSchema) => {
  switch (format) {
    case ".markdown":
    case ".mdx":
    case ".md":
      const contentJSON = (0, import_gray_matter.default)(content || "");
      const markdownData = __spreadProps(__spreadValues({}, contentJSON.data), {
        $_body: contentJSON.content
      });
      assertShape(markdownData, yupSchema);
      return markdownData;
    case ".json":
      if (!content) {
        return {};
      }
      return JSON.parse(content);
    default:
      throw new Error(`Must specify a valid format, got ${format}`);
  }
};

// src/database/store/filesystem.ts
var FilesystemStore = class {
  async clear() {
  }
  async print() {
  }
  constructor({ rootPath }) {
    this.rootPath = rootPath || "";
  }
  async query(_queryOptions) {
    throw new Error(`Unable to perform query for Filesystem store`);
  }
  async seed() {
    throw new Error(`Seeding data is not possible for Filesystem store`);
  }
  async get(filepath) {
    return parseFile(await import_fs_extra3.default.readFileSync(import_path2.default.join(this.rootPath, filepath)).toString(), import_path2.default.extname(filepath), (yup2) => yup2.object());
  }
  supportsSeeding() {
    return false;
  }
  supportsIndexing() {
    return false;
  }
  async glob(pattern, callback, extension) {
    const basePath = import_path2.default.join(this.rootPath, ...pattern.split("/"));
    const itemsRaw = await (0, import_fast_glob2.default)(import_path2.default.join(basePath, "**", `/*${extension}`).replace(/\\/g, "/"), {
      dot: true
    });
    const posixRootPath = (0, import_normalize_path3.default)(this.rootPath);
    const items = itemsRaw.map((item) => {
      return item.replace(posixRootPath, "").replace(/^\/|\/$/g, "");
    });
    if (callback) {
      return sequential(items, async (item) => {
        return callback(item);
      });
    } else {
      return items;
    }
  }
  async put(filepath, data, options) {
    await import_fs_extra3.default.outputFileSync(import_path2.default.join(this.rootPath, filepath), stringifyFile(data, import_path2.default.extname(filepath), options.keepTemplateKey));
  }
  async open() {
  }
  async close() {
  }
  async delete(filepath) {
    await import_fs_extra3.default.remove(import_path2.default.join(this.rootPath, filepath));
  }
};
var AuditFilesystemStore = class extends FilesystemStore {
  async put(_filepath, _data) {
    return;
  }
};

// src/database/store/index.ts
var import_jsonpath_plus = __toModule(require("jsonpath-plus"));
var DEFAULT_COLLECTION_SORT_KEY = "__filepath__";
var INDEX_KEY_FIELD_SEPARATOR = "#";
var DEFAULT_NUMERIC_LPAD = 4;
var OP;
(function(OP2) {
  OP2["EQ"] = "eq";
  OP2["GT"] = "gt";
  OP2["LT"] = "lt";
  OP2["GTE"] = "gte";
  OP2["LTE"] = "lte";
  OP2["STARTS_WITH"] = "startsWith";
  OP2["IN"] = "in";
})(OP || (OP = {}));
var inferOperatorFromFilter = (filterOperator) => {
  switch (filterOperator) {
    case "after":
      return OP.GT;
    case "before":
      return OP.LT;
    case "eq":
      return OP.EQ;
    case "startsWith":
      return OP.STARTS_WITH;
    case "lt":
      return OP.LT;
    case "lte":
      return OP.LTE;
    case "gt":
      return OP.GT;
    case "gte":
      return OP.GTE;
    case "in":
      return OP.IN;
    default:
      throw new Error(`unsupported filter condition: '${filterOperator}'`);
  }
};
var getFilterOperator = (expression, operand) => {
  return (expression[operand] || expression[operand] === 0) && operand;
};
var makeFilterChain = ({
  conditions
}) => {
  const filterChain = [];
  if (!conditions) {
    return filterChain;
  }
  for (const condition of conditions) {
    const { filterPath, filterExpression } = condition;
    const _a = filterExpression, { _type } = _a, keys = __objRest(_a, ["_type"]);
    const [key1, key2, ...extraKeys] = Object.keys(keys);
    if (extraKeys.length) {
      throw new Error(`Unexpected keys: [${extraKeys.join(",")}] in filter expression`);
    }
    if (key1 && !key2) {
      filterChain.push({
        pathExpression: filterPath,
        rightOperand: filterExpression[key1],
        operator: inferOperatorFromFilter(key1),
        type: _type,
        pad: _type === "number" ? { fillString: "0", maxLength: DEFAULT_NUMERIC_LPAD } : void 0
      });
    } else if (key1 && key2) {
      const leftFilterOperator = getFilterOperator(filterExpression, "gt") || getFilterOperator(filterExpression, "gte") || getFilterOperator(filterExpression, "after") || void 0;
      const rightFilterOperator = getFilterOperator(filterExpression, "lt") || getFilterOperator(filterExpression, "lte") || getFilterOperator(filterExpression, "before") || void 0;
      let leftOperand;
      let rightOperand;
      if (rightFilterOperator && leftFilterOperator) {
        if (key1 === leftFilterOperator) {
          leftOperand = filterExpression[key1];
          rightOperand = filterExpression[key2];
        } else {
          rightOperand = filterExpression[key1];
          leftOperand = filterExpression[key2];
        }
        filterChain.push({
          pathExpression: filterPath,
          rightOperand,
          leftOperand,
          leftOperator: inferOperatorFromFilter(leftFilterOperator),
          rightOperator: inferOperatorFromFilter(rightFilterOperator),
          type: _type,
          pad: _type === "number" ? { fillString: "0", maxLength: DEFAULT_NUMERIC_LPAD } : void 0
        });
      } else {
        throw new Error(`Filter on field '${filterPath}' has invalid combination of conditions: '${key1}, ${key2}'`);
      }
    }
  }
  return filterChain;
};
var makeFilter = ({
  filterChain
}) => {
  return (values) => {
    for (const filter of filterChain) {
      const dataType = filter.type;
      const resolvedValues = (0, import_jsonpath_plus.JSONPath)({
        path: filter.pathExpression,
        json: values
      });
      if (!resolvedValues || !resolvedValues.length) {
        return false;
      }
      let operands;
      if (dataType === "string" || dataType === "reference") {
        operands = resolvedValues;
      } else if (dataType === "number") {
        operands = resolvedValues.map((resolvedValue) => Number(resolvedValue));
      } else if (dataType === "datetime") {
        operands = resolvedValues.map((resolvedValue) => {
          const coerced = new Date(resolvedValue).getTime();
          return isNaN(coerced) ? Number(resolvedValue) : coerced;
        });
      } else if (dataType === "boolean") {
        operands = resolvedValues.map((resolvedValue) => typeof resolvedValue === "boolean" && resolvedValue || resolvedValue === "true" || resolvedValue === "1");
      } else {
        throw new Error(`Unexpected datatype ${dataType}`);
      }
      const { operator } = filter;
      let matches = false;
      if (operator) {
        switch (operator) {
          case OP.EQ:
            if (operands.findIndex((operand) => operand === filter.rightOperand) >= 0) {
              matches = true;
            }
            break;
          case OP.GT:
            for (const operand of operands) {
              if (operand > filter.rightOperand) {
                matches = true;
                break;
              }
            }
            break;
          case OP.LT:
            for (const operand of operands) {
              if (operand < filter.rightOperand) {
                matches = true;
                break;
              }
            }
            break;
          case OP.GTE:
            for (const operand of operands) {
              if (operand >= filter.rightOperand) {
                matches = true;
                break;
              }
            }
            break;
          case OP.LTE:
            for (const operand of operands) {
              if (operand <= filter.rightOperand) {
                matches = true;
                break;
              }
            }
            break;
          case OP.IN:
            for (const operand of operands) {
              if (filter.rightOperand.indexOf(operand) >= 0) {
                matches = true;
                break;
              }
            }
            break;
          case OP.STARTS_WITH:
            for (const operand of operands) {
              if (operand.startsWith(filter.rightOperand)) {
                matches = true;
                break;
              }
            }
            break;
          default:
            throw new Error(`unexpected operator ${operator}`);
        }
      } else {
        const { rightOperator, leftOperator, rightOperand, leftOperand } = filter;
        for (const operand of operands) {
          let rightMatches = false;
          let leftMatches = false;
          if (rightOperator === OP.LTE && operand <= rightOperand) {
            rightMatches = true;
          } else if (rightOperator === OP.LT && operand < rightOperand) {
            rightMatches = true;
          }
          if (leftOperator === OP.GTE && operand >= leftOperand) {
            leftMatches = true;
          } else if (leftOperator === OP.GT && operand > leftOperand) {
            leftMatches = true;
          }
          if (rightMatches && leftMatches) {
            matches = true;
            break;
          }
        }
      }
      if (!matches) {
        return false;
      }
    }
    return true;
  };
};
var makeStringEscaper = (regex, replacement) => {
  return (input) => {
    if (Array.isArray(input)) {
      return input.map((val) => val.replace(regex, replacement));
    } else {
      return input.replace(regex, replacement);
    }
  };
};
var applyPadding = (input, pad) => {
  if (pad) {
    if (Array.isArray(input)) {
      return input.map((val) => String(val).padStart(pad.maxLength, pad.fillString));
    } else {
      return String(input).padStart(pad.maxLength, pad.fillString);
    }
  }
  return input;
};
var coerceFilterChainOperands = (filterChain, stringEscaper) => {
  const result = [];
  if (filterChain.length) {
    for (const filter of filterChain) {
      const dataType = filter.type;
      if (dataType === "datetime") {
        if (filter.leftOperand !== void 0) {
          result.push(__spreadProps(__spreadValues({}, filter), {
            rightOperand: new Date(filter.rightOperand).getTime(),
            leftOperand: new Date(filter.leftOperand).getTime()
          }));
        } else {
          if (Array.isArray(filter.rightOperand)) {
            result.push(__spreadProps(__spreadValues({}, filter), {
              rightOperand: filter.rightOperand.map((operand) => new Date(operand).getTime())
            }));
          } else {
            result.push(__spreadProps(__spreadValues({}, filter), {
              rightOperand: new Date(filter.rightOperand).getTime()
            }));
          }
        }
      } else if (dataType === "string") {
        if (filter.leftOperand !== void 0) {
          result.push(__spreadProps(__spreadValues({}, filter), {
            rightOperand: applyPadding(stringEscaper(filter.rightOperand), filter.pad),
            leftOperand: applyPadding(stringEscaper(filter.leftOperand), filter.pad)
          }));
        } else {
          result.push(__spreadProps(__spreadValues({}, filter), {
            rightOperand: applyPadding(stringEscaper(filter.rightOperand), filter.pad)
          }));
        }
      } else {
        result.push(__spreadValues({}, filter));
      }
    }
  }
  return result;
};
var makeFilterSuffixes = (filterChain, index) => {
  if (filterChain && filterChain.length) {
    const indexFields = index.fields.map((field) => field.name);
    const orderedFilterChain = [];
    for (const filter of filterChain) {
      const idx = indexFields.indexOf(filter.pathExpression);
      if (idx === -1) {
        return;
      }
      if (filter.operator && filter.operator === OP.IN) {
        return;
      }
      orderedFilterChain[idx] = filter;
    }
    const baseFragments = [];
    let rightSuffix;
    let leftSuffix;
    let ternaryFilter = false;
    if (orderedFilterChain[filterChain.length - 1] && !orderedFilterChain[filterChain.length - 1].operator) {
      ternaryFilter = true;
    }
    for (let i = 0; i < orderedFilterChain.length; i++) {
      const filter = orderedFilterChain[i];
      if (!filter) {
        return;
      }
      if (Number(i) < indexFields.length - 1) {
        if (!filter.operator) {
          return;
        }
        const binaryFilter = filter;
        if (binaryFilter.operator !== OP.EQ) {
          return;
        }
        baseFragments.push(applyPadding(orderedFilterChain[i].rightOperand, orderedFilterChain[i].pad));
      } else {
        if (ternaryFilter) {
          leftSuffix = applyPadding(orderedFilterChain[i].leftOperand, orderedFilterChain[i].pad);
          rightSuffix = applyPadding(orderedFilterChain[i].rightOperand, orderedFilterChain[i].pad);
        } else {
          const op = orderedFilterChain[i].operator;
          const operand = applyPadding(orderedFilterChain[i].rightOperand, orderedFilterChain[i].pad);
          if (op === OP.LT || op === OP.LTE) {
            rightSuffix = operand;
          } else if (op === OP.GT || op === OP.GTE) {
            leftSuffix = operand;
          } else {
            rightSuffix = operand;
            leftSuffix = operand;
          }
        }
      }
    }
    return {
      left: leftSuffix && [...baseFragments, leftSuffix].join(INDEX_KEY_FIELD_SEPARATOR) || void 0,
      right: rightSuffix && [...baseFragments, rightSuffix].join(INDEX_KEY_FIELD_SEPARATOR) || void 0
    };
  } else {
    return {};
  }
};
var makeKeyForField = (definition, data, stringEscaper, maxStringLength = 100) => {
  const valueParts = [];
  for (const field of definition.fields) {
    if (field.name in data) {
      const resolvedValue = String(field.type === "datetime" ? new Date(data[field.name]).getTime() : field.type === "string" ? stringEscaper(data[field.name]) : data[field.name]).substring(0, maxStringLength);
      valueParts.push(applyPadding(resolvedValue, field.pad));
    } else {
      return null;
    }
  }
  return valueParts.join(INDEX_KEY_FIELD_SEPARATOR);
};

// src/database/store/level.ts
var import_path3 = __toModule(require("path"));
var import_level = __toModule(require("level"));
var import_levelup = __toModule(require("levelup"));
var import_memdown = __toModule(require("memdown"));
var import_encoding_down = __toModule(require("encoding-down"));
var defaultPrefix = "_ROOT_";
var escapeStr = makeStringEscaper(new RegExp(INDEX_KEY_FIELD_SEPARATOR, "gm"), encodeURIComponent(INDEX_KEY_FIELD_SEPARATOR));
var LevelStore = class {
  constructor(rootPath, useMemory = false) {
    this.rootPath = rootPath || "";
    this.useMemory = useMemory;
    if (useMemory) {
      this.db = (0, import_levelup.default)((0, import_encoding_down.default)((0, import_memdown.default)(), { valueEncoding: "json" }));
    } else {
      this.db = (0, import_level.default)(import_path3.default.join(rootPath, ".tina/__generated__/db"), {
        valueEncoding: "json"
      });
    }
  }
  async query(queryOptions) {
    var _b;
    const _a = queryOptions, {
      filterChain: rawFilterChain,
      sort = DEFAULT_COLLECTION_SORT_KEY,
      collection,
      indexDefinitions,
      limit = 10
    } = _a, query = __objRest(_a, [
      "filterChain",
      "sort",
      "collection",
      "indexDefinitions",
      "limit"
    ]);
    const filterChain = coerceFilterChainOperands(rawFilterChain, escapeStr);
    const indexDefinition = sort && (indexDefinitions == null ? void 0 : indexDefinitions[sort]);
    const filterSuffixes = indexDefinition && makeFilterSuffixes(filterChain, indexDefinition);
    const indexPrefix = indexDefinition ? `${collection}${INDEX_KEY_FIELD_SEPARATOR}${sort}` : `${defaultPrefix}${INDEX_KEY_FIELD_SEPARATOR}`;
    if (!query.gt && !query.gte) {
      query.gte = (filterSuffixes == null ? void 0 : filterSuffixes.left) ? `${indexPrefix}${INDEX_KEY_FIELD_SEPARATOR}${filterSuffixes.left}` : indexPrefix;
    }
    if (!query.lt && !query.lte) {
      query.lte = (filterSuffixes == null ? void 0 : filterSuffixes.right) ? `${indexPrefix}${INDEX_KEY_FIELD_SEPARATOR}${filterSuffixes.right}\xFF` : `${indexPrefix}\xFF`;
    }
    let edges = [];
    let startKey = "";
    let endKey = "";
    let hasPreviousPage = false;
    let hasNextPage = false;
    const fieldsPattern = ((_b = indexDefinition == null ? void 0 : indexDefinition.fields) == null ? void 0 : _b.length) ? `${indexDefinition.fields.map((p) => `${INDEX_KEY_FIELD_SEPARATOR}(?<${p.name}>.+)`).join("")}${INDEX_KEY_FIELD_SEPARATOR}` : INDEX_KEY_FIELD_SEPARATOR;
    const valuesRegex = indexDefinition ? new RegExp(`^${indexPrefix}${fieldsPattern}(?<_filepath_>.+)`) : new RegExp(`^${indexPrefix}(?<_filepath_>.+)`);
    const itemFilter = makeFilter({ filterChain });
    for await (const [key, value] of this.db.iterator(query)) {
      const matcher = valuesRegex.exec(key);
      if (!matcher || indexDefinition && matcher.length !== indexDefinition.fields.length + 2) {
        continue;
      }
      const filepath = matcher.groups["_filepath_"];
      if (!itemFilter(filterSuffixes ? matcher.groups : indexDefinition ? await this.db.get(`${defaultPrefix}${INDEX_KEY_FIELD_SEPARATOR}${filepath}`) : value)) {
        continue;
      }
      if (limit !== -1 && edges.length >= limit) {
        if (query.reverse) {
          hasPreviousPage = true;
        } else {
          hasNextPage = true;
        }
        break;
      }
      startKey = startKey || key || "";
      endKey = key || "";
      edges = [...edges, { cursor: key, path: filepath }];
    }
    return {
      edges,
      pageInfo: {
        hasPreviousPage,
        hasNextPage,
        startCursor: startKey,
        endCursor: endKey
      }
    };
  }
  async seed(filepath, data, options) {
    await this.put(filepath, data, __spreadValues({
      keepTemplateKey: false,
      seed: true
    }, options));
  }
  supportsSeeding() {
    return true;
  }
  supportsIndexing() {
    return true;
  }
  async delete(filepath, options) {
    const data = await this.db.get(`${defaultPrefix}${INDEX_KEY_FIELD_SEPARATOR}${filepath}`);
    if (!data) {
      return;
    }
    if (options == null ? void 0 : options.indexDefinitions) {
      for (const [sort, definition] of Object.entries(options.indexDefinitions)) {
        const indexedValue = makeKeyForField(definition, data, escapeStr);
        let indexKey;
        if (sort === DEFAULT_COLLECTION_SORT_KEY) {
          indexKey = `${options.collection}${INDEX_KEY_FIELD_SEPARATOR}${sort}${INDEX_KEY_FIELD_SEPARATOR}${filepath}`;
        } else {
          indexKey = indexedValue ? `${options.collection}${INDEX_KEY_FIELD_SEPARATOR}${sort}${INDEX_KEY_FIELD_SEPARATOR}${indexedValue}${INDEX_KEY_FIELD_SEPARATOR}${filepath}` : null;
        }
        if (indexKey) {
          await this.db.del(indexKey);
        }
      }
    }
    await this.db.del(`${defaultPrefix}${INDEX_KEY_FIELD_SEPARATOR}${filepath}`);
  }
  async print() {
    this.db.createReadStream().on("data", function(data) {
      console.log(data.key, "=", data.value);
    }).on("error", function(err) {
      console.log("Oh my!", err);
    }).on("close", function() {
      console.log("Stream closed");
    }).on("end", function() {
      console.log("Stream ended");
    });
  }
  async open() {
    await this.db.open();
  }
  async clear() {
    await this.db.clear();
  }
  async glob(pattern, callback) {
    const strings = [];
    const p = new Promise((resolve, reject) => {
      this.db.createKeyStream({
        gte: `${defaultPrefix}${INDEX_KEY_FIELD_SEPARATOR}${pattern}`,
        lte: `${defaultPrefix}${INDEX_KEY_FIELD_SEPARATOR}${pattern}\xFF`
      }).on("data", (data) => {
        strings.push(data.split(`${defaultPrefix}${INDEX_KEY_FIELD_SEPARATOR}`)[1]);
      }).on("error", (message) => {
        reject(message);
      }).on("end", function() {
        resolve();
      });
    });
    await p;
    if (callback) {
      return sequential(strings, async (item) => {
        return callback(item);
      });
    } else {
      return strings;
    }
  }
  async get(filepath) {
    try {
      return await this.db.get(`${defaultPrefix}${INDEX_KEY_FIELD_SEPARATOR}${filepath}`);
    } catch (e) {
      return void 0;
    }
  }
  async close() {
    await this.db.close();
  }
  async put(filepath, data, options) {
    let existingData;
    try {
      existingData = options && !options.seed ? await this.db.get(`${defaultPrefix}${INDEX_KEY_FIELD_SEPARATOR}${filepath}`) : null;
    } catch (err) {
      if (!err.notFound) {
        throw err;
      }
    }
    await this.db.put(`${defaultPrefix}${INDEX_KEY_FIELD_SEPARATOR}${filepath}`, data);
    if (options == null ? void 0 : options.indexDefinitions) {
      for (const [sort, definition] of Object.entries(options.indexDefinitions)) {
        const indexedValue = makeKeyForField(definition, data, escapeStr);
        const existingIndexedValue = existingData ? makeKeyForField(definition, existingData, escapeStr) : null;
        let indexKey;
        let existingIndexKey = null;
        if (sort === DEFAULT_COLLECTION_SORT_KEY) {
          indexKey = `${options.collection}${INDEX_KEY_FIELD_SEPARATOR}${sort}${INDEX_KEY_FIELD_SEPARATOR}${filepath}`;
          existingIndexKey = indexKey;
        } else {
          indexKey = indexedValue ? `${options.collection}${INDEX_KEY_FIELD_SEPARATOR}${sort}${INDEX_KEY_FIELD_SEPARATOR}${indexedValue}${INDEX_KEY_FIELD_SEPARATOR}${filepath}` : null;
          existingIndexKey = existingIndexedValue ? `${options.collection}${INDEX_KEY_FIELD_SEPARATOR}${sort}${INDEX_KEY_FIELD_SEPARATOR}${existingIndexedValue}${INDEX_KEY_FIELD_SEPARATOR}${filepath}` : null;
        }
        if (indexKey) {
          if (existingIndexKey && indexKey != existingIndexKey) {
            await this.db.del(existingIndexKey);
          }
          await this.db.put(indexKey, "");
        }
      }
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AuditFileSystemBridge,
  AuditFilesystemStore,
  DEFAULT_COLLECTION_SORT_KEY,
  DEFAULT_NUMERIC_LPAD,
  FilesystemBridge,
  FilesystemStore,
  INDEX_KEY_FIELD_SEPARATOR,
  IsomorphicBridge,
  LevelStore,
  OP,
  atob,
  btoa,
  coerceFilterChainOperands,
  makeFilter,
  makeFilterChain,
  makeFilterSuffixes,
  makeKeyForField,
  makeStringEscaper
});
