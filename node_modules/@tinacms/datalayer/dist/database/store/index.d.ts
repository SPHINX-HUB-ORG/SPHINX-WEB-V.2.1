/**
Copyright 2021 Forestry.io Holdings, Inc.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
import { FilterOperand } from '../../index';
export declare const DEFAULT_COLLECTION_SORT_KEY = "__filepath__";
export declare const INDEX_KEY_FIELD_SEPARATOR = "#";
export declare const DEFAULT_NUMERIC_LPAD = 4;
export declare enum OP {
    EQ = "eq",
    GT = "gt",
    LT = "lt",
    GTE = "gte",
    LTE = "lte",
    STARTS_WITH = "startsWith",
    IN = "in"
}
export declare type PadDefinition = {
    fillString: string;
    maxLength: number;
};
export declare type BinaryFilter = {
    pathExpression: string;
    rightOperand: FilterOperand;
    operator: OP.EQ | OP.GT | OP.LT | OP.GTE | OP.LTE | OP.STARTS_WITH | OP.IN;
    type: string;
    pad?: PadDefinition;
};
export declare type TernaryFilter = {
    pathExpression: string;
    leftOperand: FilterOperand;
    rightOperand: FilterOperand;
    leftOperator: OP.GTE | OP.GT;
    rightOperator: OP.LT | OP.LTE;
    type: string;
    pad?: PadDefinition;
};
/** Options for {@link Store.query} */
export declare type StoreQueryOptions = {
    collection: string;
    indexDefinitions?: Record<string, IndexDefinition>;
    filterChain: (BinaryFilter | TernaryFilter)[];
    sort?: string;
    gt?: string;
    gte?: string;
    lt?: string;
    lte?: string;
    reverse?: boolean;
    limit?: number;
};
export declare type PageInfo = {
    hasPreviousPage: boolean;
    hasNextPage: boolean;
    startCursor: string;
    endCursor: string;
};
export declare type StoreQueryResponse = {
    edges: {
        cursor: string;
        path: string;
    }[];
    pageInfo: PageInfo;
};
export declare type IndexDefinition = {
    fields: {
        name: string;
        type?: string;
        pad?: PadDefinition;
    }[];
};
export declare type SeedOptions = {
    collection?: string;
    indexDefinitions?: Record<string, IndexDefinition>;
    includeTemplate?: boolean;
    keepTemplateKey?: boolean;
};
export declare type PutOptions = SeedOptions & {
    seed?: boolean;
};
export declare type DeleteOptions = SeedOptions & {
    seed?: boolean;
};
export interface Store {
    glob(pattern: string, hydrator?: (fullPath: string) => Promise<object>, extension?: string): Promise<string[]>;
    get<T extends object>(filepath: string): Promise<T>;
    delete(filepath: string, options?: DeleteOptions): Promise<void>;
    clear(): void;
    close(): void;
    open(): void;
    /**
     * Executes a query against a collection
     * @param queryOptions - options for the query
     * @returns the results of the query
     */
    query(queryOptions: StoreQueryOptions): Promise<StoreQueryResponse>;
    /**
     * In this context, seeding is the act of putting records and indexing data into an ephemeral
     * storage layer for use during the GraphQL runtime. What might seem suprising is that some stores
     * don't support seeding, this is because they're behaving more like a "bridge" (GithubStore and FilesystemStore).
     * Currently they're acting as a way to swap out true data-layer behavior with a backwards-compatible
     * "store". In the future, all stores should be able to query and seed data.
     *
     * At this time it seems that it would never make sense to be able to "query" without "seed"-ing, and
     * there'd be no value in "seeding" without "query"-ing.
     */
    seed(filepath: string, data: object, options?: PutOptions): Promise<void>;
    supportsSeeding(): boolean;
    /**
     * Whether this store supports the ability to index data.
     * Indexing data requires writing arbitrary keys/values to
     * the external service, so is not advisable to use for
     * something like Github, which would write commits to the
     * user's repo.
     */
    supportsIndexing(): boolean;
    put(filepath: string, data: object, options?: PutOptions): Promise<void>;
}
export declare type FilterCondition = {
    filterExpression: Record<string, FilterOperand>;
    filterPath: string;
};
export declare const makeFilterChain: ({ conditions, }: {
    conditions: FilterCondition[];
}) => (BinaryFilter | TernaryFilter)[];
export declare const makeFilter: ({ filterChain, }: {
    filterChain?: (BinaryFilter | TernaryFilter)[];
}) => (values: Record<string, object | FilterOperand>) => boolean;
declare type StringEscaper = <T extends string | string[]>(input: T) => T;
export declare const makeStringEscaper: (regex: RegExp, replacement: string) => StringEscaper;
export declare const coerceFilterChainOperands: (filterChain: (BinaryFilter | TernaryFilter)[], stringEscaper: StringEscaper) => (BinaryFilter | TernaryFilter)[];
export declare const makeFilterSuffixes: (filterChain: (BinaryFilter | TernaryFilter)[], index: IndexDefinition) => {
    left?: string;
    right?: string;
} | undefined;
export declare const makeKeyForField: (definition: IndexDefinition, data: object, stringEscaper: StringEscaper, maxStringLength?: number) => string | null;
export {};
