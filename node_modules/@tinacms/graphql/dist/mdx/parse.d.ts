/**

Copyright 2021 Forestry.io Holdings, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
import type { Content } from 'mdast';
import type { RichTypeInner } from '../types';
export declare const parseMDX: (value: string, field: RichTypeInner) => {
    type: string;
    children: any;
};
/**
 * ### Convert the MDXAST into an API-friendly format
 *
 * When we parse with Remark + MDX we get an AST which has a ton of JS capabilities, meaning
 * we could pass this back into a JS runtime and evaluate it. Ex.
 *
 * ```mdx
 * ## Hello world! The time and date is: {(new Date().toLocaleString())}
 * ```
 *
 * However, as an intentional constraint we don't want this information as part of our API, as
 * we don't intend to support the true JS runtime properties of MDX. Rather, we're using MDX for
 * it's expressive syntax and it's advanced tooling with how it parses JSX inside Markdown.
 *
 * Parsing here does 2 things:
 *
 * #### Remove non-literal uses of JSX
 * Things like <MyComponent myProp={() => alert("HI")} /> are not supported and will be ignored
 *
 * #### Convert remark nodes to slate-compatible nodes
 *
 * A remark node might look like this:
 * ```js
 * {
 *   type: "heading",
 *   depth: 1
 *   children: [{type: 'text', value: 'Hello'}]
 * }
 * ```
 * A slate-compatible node would be:
 * ```js
 * {
 *   type: "heading_one",
 *   children: [{type: 'text', text: 'Hello'}]
 * }
 * ```
 * It's not a huge difference, but in general slate does better with less layers of indirection.
 *
 * While it may be desirable to ultimately serve a remark AST shape as part of the API response,
 * it's currently much easier to only support the shape that works with Slate. This is ok for now for 2
 * reasons.
 *
 * 1. Us providing the `TinaMarkdown` component on the frontend abstracts away an work the developer
 * would need to do, so it doesn't really matter what shape the response is as long as the external API
 * doesn't change
 *
 * 2. We don't need to do any client-side parsing. Since TinaMarkdown and the slate editor work with the same
 * format we can just allow Tina to do it's thing and update the form valuse with no additional work.
 */
export declare const parseMDXInner: (tree: any, field: RichTypeInner) => {
    type: string;
    children: any;
};
export interface NodeTypes {
    paragraph: string;
    block_quote: string;
    code_block: string;
    link: string;
    image: string;
    ul_list: string;
    ol_list: string;
    listItem: string;
    heading: {
        1: string;
        2: string;
        3: string;
        4: string;
        5: string;
        6: string;
    };
    emphasis_mark: string;
    strong_mark: string;
    delete_mark: string;
    inline_code_mark: string;
    thematic_break: string;
}
export declare type SlateNodeType = {
    type: 'heading_one';
    children: SlateNodeType[];
} | {
    type: 'heading_two';
    children: SlateNodeType[];
} | {
    type: 'heading_three';
    children: SlateNodeType[];
} | {
    type: 'heading_four';
    children: SlateNodeType[];
} | {
    type: 'heading_five';
    children: SlateNodeType[];
} | {
    type: 'heading_six';
    children: SlateNodeType[];
} | {
    type: 'paragraph';
    children: SlateNodeType[];
} | {
    children: SlateNodeType[];
    link: string;
    type: 'link';
} | {
    type: 'block_quote';
    children: SlateNodeType[];
} | {
    type: 'text';
    text: string;
} | {
    type: 'mdxJsxTextElement';
    props: object;
    children: SlateNodeType[];
    name: string;
} | {
    type: 'mdxJsxFlowElement';
    props: object;
    children: SlateNodeType[];
    name: string;
} | {
    type: 'block_quote';
    children: SlateNodeType[];
} | {
    type: 'code_block';
    language: string;
    value: string;
} | {
    type: 'image';
    link: string;
    caption: string;
} | {
    type: 'thematic_break';
};
declare type RecursivePartial<T> = {
    [P in keyof T]?: RecursivePartial<T[P]>;
};
export interface OptionType {
    nodeTypes?: RecursivePartial<NodeTypes>;
    linkDestinationKey?: string;
    imageSourceKey?: string;
    imageCaptionKey?: string;
}
export interface MdastNode {
    type?: string;
    ordered?: boolean;
    value?: string;
    text?: string;
    children?: Array<MdastNode>;
    depth?: 1 | 2 | 3 | 4 | 5 | 6;
    url?: string;
    alt?: string;
    lang?: string;
    position?: any;
    spread?: any;
    checked?: any;
    indent?: any;
}
declare type MdxJsxFlowElement = {
    type: 'mdxJsxFlowElement';
    name: string;
    attributes: object;
    children: MdxAstNode[];
};
declare type MdxJsxTextElement = {
    type: 'mdxJsxTextElement';
    name: string;
    attributes: object;
    children: MdxAstNode[];
};
declare type MdxAstNode = Content | MdxJsxFlowElement | MdxJsxTextElement;
export declare const plateElements: {
    ELEMENT_H1: string;
    ELEMENT_H2: string;
    ELEMENT_H3: string;
    ELEMENT_H4: string;
    ELEMENT_H5: string;
    ELEMENT_H6: string;
    ELEMENT_HR: string;
    ELEMENT_ALIGN_CENTER: string;
    ELEMENT_ALIGN_JUSTIFY: string;
    ELEMENT_ALIGN_LEFT: string;
    ELEMENT_ALIGN_RIGHT: string;
    ELEMENT_BLOCKQUOTE: string;
    ELEMENT_CODE_BLOCK: string;
    ELEMENT_CODE_LINE: string;
    ELEMENT_DEFAULT: string;
    ELEMENT_IMAGE: string;
    ELEMENT_LI: string;
    ELEMENT_LIC: string;
    ELEMENT_LINK: string;
    ELEMENT_MEDIA_EMBED: string;
    ELEMENT_MENTION: string;
    ELEMENT_OL: string;
    ELEMENT_PARAGRAPH: string;
    ELEMENT_TABLE: string;
    ELEMENT_TD: string;
    ELEMENT_TH: string;
    ELEMENT_TODO_LI: string;
    ELEMENT_TR: string;
    ELEMENT_UL: string;
    MARK_ITALIC: string;
    MARK_BOLD: string;
    MARK_STRIKETHROUGH: string;
    MARK_UNDERLINE: string;
};
export declare const defaultNodeTypes: NodeTypes;
export default function remarkToSlate(node: MdxAstNode): any;
export {};
