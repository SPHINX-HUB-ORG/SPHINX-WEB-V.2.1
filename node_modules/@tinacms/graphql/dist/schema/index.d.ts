/**
Copyright 2021 Forestry.io Holdings, Inc.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
import type { CollectionTemplateable, Collectable, TinaCloudSchemaEnriched, TinaCloudSchemaBase, Templateable, TinaCloudCollection } from '../types';
export declare const createSchema: ({ schema, flags, }: {
    schema: TinaCloudSchemaBase;
    flags?: string[];
}) => Promise<TinaSchema>;
declare type Version = {
    fullVersion: string;
    major: string;
    minor: string;
    patch: string;
};
/**
 * Metadata about how the schema was built
 */
declare type Meta = {
    flags?: string[];
};
/**
 * TinaSchema is responsible for allowing you to look up certain
 * properties of the user-provided schema with ease.
 */
export declare class TinaSchema {
    config: {
        version?: Version;
        meta?: Meta;
    } & TinaCloudSchemaBase;
    schema: TinaCloudSchemaEnriched;
    constructor(config: {
        version?: Version;
        meta?: Meta;
    } & TinaCloudSchemaBase);
    getCollectionsByName: (collectionNames: string[]) => TinaCloudCollection<true>[];
    getAllCollectionPaths: () => string[];
    getCollection: (collectionName: string) => TinaCloudCollection<true>;
    getCollections: () => TinaCloudCollection<true>[];
    getGlobalTemplate: (templateName: string) => {
        label: string;
        name: string;
        ui?: object;
        fields: import("../types").TinaFieldInner<true>[];
        namespace: string[];
    };
    getCollectionByFullPath: (filepath: string) => Promise<TinaCloudCollection<true>>;
    getCollectionAndTemplateByFullPath: (filepath: string, templateName?: string) => Promise<{
        collection: TinaCloudCollection<true>;
        template: Templateable;
    }>;
    getTemplateForData: ({ data, collection, }: {
        data?: unknown;
        collection: Collectable;
    }) => Promise<Templateable>;
    isMarkdownCollection: (collectionName: string) => boolean;
    /**
     * Gets the template or templates from the item.
     * Both `object` fields and collections support
     * the ability for an object to be polymorphic,
     * and if it is, we need to build unions, which
     * are more of a headache for non-polymorphic
     * needs, so we also need the ability to just
     * build object types
     *
     *
     */
    getTemplatesForCollectable: (collection: Collectable) => CollectionTemplateable;
}
export {};
