var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  __markAsModule(target);
  for (var name2 in all2)
    __defProp(target, name2, { get: all2[name2], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key2 of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key2) && key2 !== "default")
        __defProp(target, key2, { get: () => module2[key2], enumerable: !(desc = __getOwnPropDesc(module2, key2)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/date-fns-npm-2.22.1-cc0cbadceb-a89dc6cdf3.zip/node_modules/date-fns/_lib/requiredArgs/index.js
var require_requiredArgs = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/date-fns-npm-2.22.1-cc0cbadceb-a89dc6cdf3.zip/node_modules/date-fns/_lib/requiredArgs/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = requiredArgs;
    function requiredArgs(required, args) {
      if (args.length < required) {
        throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
      }
    }
    module2.exports = exports.default;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/date-fns-npm-2.22.1-cc0cbadceb-a89dc6cdf3.zip/node_modules/date-fns/toDate/index.js
var require_toDate = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/date-fns-npm-2.22.1-cc0cbadceb-a89dc6cdf3.zip/node_modules/date-fns/toDate/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toDate;
    var _index = _interopRequireDefault(require_requiredArgs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function toDate(argument) {
      (0, _index.default)(1, arguments);
      var argStr = Object.prototype.toString.call(argument);
      if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
        return new Date(argument.getTime());
      } else if (typeof argument === "number" || argStr === "[object Number]") {
        return new Date(argument);
      } else {
        if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
          console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
          console.warn(new Error().stack);
        }
        return new Date(NaN);
      }
    }
    module2.exports = exports.default;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/date-fns-npm-2.22.1-cc0cbadceb-a89dc6cdf3.zip/node_modules/date-fns/isValid/index.js
var require_isValid = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/date-fns-npm-2.22.1-cc0cbadceb-a89dc6cdf3.zip/node_modules/date-fns/isValid/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isValid2;
    var _index = _interopRequireDefault(require_toDate());
    var _index2 = _interopRequireDefault(require_requiredArgs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isValid2(dirtyDate) {
      (0, _index2.default)(1, arguments);
      var date = (0, _index.default)(dirtyDate);
      return !isNaN(date);
    }
    module2.exports = exports.default;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/is-buffer-npm-2.0.5-17e563f277-1a6dc68206.zip/node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/is-buffer-npm-2.0.5-17e563f277-1a6dc68206.zip/node_modules/is-buffer/index.js"(exports, module2) {
    module2.exports = function isBuffer2(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/extend-npm-3.0.2-e1ca07ac54-1406da1f0c.zip/node_modules/extend/index.js
var require_extend = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/extend-npm-3.0.2-e1ca07ac54-1406da1f0c.zip/node_modules/extend/index.js"(exports, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject2 = function isPlainObject3(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key2;
      for (key2 in obj) {
      }
      return typeof key2 === "undefined" || hasOwn.call(obj, key2);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name2) {
      if (name2 === "__proto__") {
        if (!hasOwn.call(obj, name2)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name2).value;
        }
      }
      return obj[name2];
    };
    module2.exports = function extend2() {
      var options, name2, src, copy, copyIsArray, clone;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name2 in options) {
            src = getProperty(target, name2);
            copy = getProperty(options, name2);
            if (target !== copy) {
              if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray(src) ? src : [];
                } else {
                  clone = src && isPlainObject2(src) ? src : {};
                }
                setProperty(target, { name: name2, newValue: extend2(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name: name2, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/constant/has-own-property.js
var require_has_own_property = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/constant/has-own-property.js"(exports, module2) {
    "use strict";
    var own9 = {}.hasOwnProperty;
    module2.exports = own9;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/constant/splice.js
var require_splice = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/constant/splice.js"(exports, module2) {
    "use strict";
    var splice2 = [].splice;
    module2.exports = splice2;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/util/chunked-splice.js
var require_chunked_splice = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/util/chunked-splice.js"(exports, module2) {
    "use strict";
    var splice2 = require_splice();
    function chunkedSplice(list3, start, remove, items) {
      var end = list3.length;
      var chunkStart = 0;
      var parameters;
      if (start < 0) {
        start = -start > end ? 0 : end + start;
      } else {
        start = start > end ? end : start;
      }
      remove = remove > 0 ? remove : 0;
      if (items.length < 1e4) {
        parameters = Array.from(items);
        parameters.unshift(start, remove);
        splice2.apply(list3, parameters);
      } else {
        if (remove)
          splice2.apply(list3, [start, remove]);
        while (chunkStart < items.length) {
          parameters = items.slice(chunkStart, chunkStart + 1e4);
          parameters.unshift(start, 0);
          splice2.apply(list3, parameters);
          chunkStart += 1e4;
          start += 1e4;
        }
      }
    }
    module2.exports = chunkedSplice;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/util/miniflat.js
var require_miniflat = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/util/miniflat.js"(exports, module2) {
    "use strict";
    function miniflat(value) {
      return value === null || value === void 0 ? [] : "length" in value ? value : [value];
    }
    module2.exports = miniflat;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/util/combine-extensions.js
var require_combine_extensions = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/util/combine-extensions.js"(exports, module2) {
    "use strict";
    var hasOwnProperty3 = require_has_own_property();
    var chunkedSplice = require_chunked_splice();
    var miniflat = require_miniflat();
    function combineExtensions2(extensions) {
      var all2 = {};
      var index2 = -1;
      while (++index2 < extensions.length) {
        extension2(all2, extensions[index2]);
      }
      return all2;
    }
    function extension2(all2, extension3) {
      var hook;
      var left;
      var right;
      var code2;
      for (hook in extension3) {
        left = hasOwnProperty3.call(all2, hook) ? all2[hook] : all2[hook] = {};
        right = extension3[hook];
        for (code2 in right) {
          left[code2] = constructs2(miniflat(right[code2]), hasOwnProperty3.call(left, code2) ? left[code2] : []);
        }
      }
    }
    function constructs2(list3, existing) {
      var index2 = -1;
      var before = [];
      while (++index2 < list3.length) {
        ;
        (list3[index2].add === "after" ? existing : before).push(list3[index2]);
      }
      chunkedSplice(existing, 0, 0, before);
      return existing;
    }
    module2.exports = combineExtensions2;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/character/markdown-line-ending.js
var require_markdown_line_ending = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/character/markdown-line-ending.js"(exports, module2) {
    "use strict";
    function markdownLineEnding2(code2) {
      return code2 < -2;
    }
    module2.exports = markdownLineEnding2;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/character/markdown-space.js
var require_markdown_space = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/character/markdown-space.js"(exports, module2) {
    "use strict";
    function markdownSpace2(code2) {
      return code2 === -2 || code2 === -1 || code2 === 32;
    }
    module2.exports = markdownSpace2;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/tokenize/factory-space.js
var require_factory_space = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/tokenize/factory-space.js"(exports, module2) {
    "use strict";
    var markdownSpace2 = require_markdown_space();
    function spaceFactory(effects, ok2, type, max) {
      var limit = max ? max - 1 : Infinity;
      var size = 0;
      return start;
      function start(code2) {
        if (markdownSpace2(code2)) {
          effects.enter(type);
          return prefix(code2);
        }
        return ok2(code2);
      }
      function prefix(code2) {
        if (markdownSpace2(code2) && size++ < limit) {
          effects.consume(code2);
          return prefix;
        }
        effects.exit(type);
        return ok2(code2);
      }
    }
    module2.exports = spaceFactory;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/tokenize/factory-whitespace.js
var require_factory_whitespace = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/tokenize/factory-whitespace.js"(exports, module2) {
    "use strict";
    var markdownLineEnding2 = require_markdown_line_ending();
    var markdownSpace2 = require_markdown_space();
    var factorySpace2 = require_factory_space();
    function whitespaceFactory(effects, ok2) {
      var seen;
      return start;
      function start(code2) {
        if (markdownLineEnding2(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          seen = true;
          return start;
        }
        if (markdownSpace2(code2)) {
          return factorySpace2(effects, start, seen ? "linePrefix" : "lineSuffix")(code2);
        }
        return ok2(code2);
      }
    }
    module2.exports = whitespaceFactory;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/unist-util-stringify-position-npm-2.0.3-abaa9bf961-2017497ef7.zip/node_modules/unist-util-stringify-position/index.js
var require_unist_util_stringify_position = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/unist-util-stringify-position-npm-2.0.3-abaa9bf961-2017497ef7.zip/node_modules/unist-util-stringify-position/index.js"(exports, module2) {
    "use strict";
    var own9 = {}.hasOwnProperty;
    module2.exports = stringify2;
    function stringify2(value) {
      if (!value || typeof value !== "object") {
        return "";
      }
      if (own9.call(value, "position") || own9.call(value, "type")) {
        return position2(value.position);
      }
      if (own9.call(value, "start") || own9.call(value, "end")) {
        return position2(value);
      }
      if (own9.call(value, "line") || own9.call(value, "column")) {
        return point2(value);
      }
      return "";
    }
    function point2(point3) {
      if (!point3 || typeof point3 !== "object") {
        point3 = {};
      }
      return index2(point3.line) + ":" + index2(point3.column);
    }
    function position2(pos) {
      if (!pos || typeof pos !== "object") {
        pos = {};
      }
      return point2(pos.start) + "-" + point2(pos.end);
    }
    function index2(value) {
      return value && typeof value === "number" ? value : 1;
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/vfile-message-npm-2.0.4-ca3f9b6719-a88f41883c.zip/node_modules/vfile-message/index.js
var require_vfile_message = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/vfile-message-npm-2.0.4-ca3f9b6719-a88f41883c.zip/node_modules/vfile-message/index.js"(exports, module2) {
    "use strict";
    var stringify2 = require_unist_util_stringify_position();
    module2.exports = VMessage;
    function VMessagePrototype() {
    }
    VMessagePrototype.prototype = Error.prototype;
    VMessage.prototype = new VMessagePrototype();
    var proto = VMessage.prototype;
    proto.file = "";
    proto.name = "";
    proto.reason = "";
    proto.message = "";
    proto.stack = "";
    proto.fatal = null;
    proto.column = null;
    proto.line = null;
    function VMessage(reason, position2, origin) {
      var parts;
      var range;
      var location;
      if (typeof position2 === "string") {
        origin = position2;
        position2 = null;
      }
      parts = parseOrigin(origin);
      range = stringify2(position2) || "1:1";
      location = {
        start: { line: null, column: null },
        end: { line: null, column: null }
      };
      if (position2 && position2.position) {
        position2 = position2.position;
      }
      if (position2) {
        if (position2.start) {
          location = position2;
          position2 = position2.start;
        } else {
          location.start = position2;
        }
      }
      if (reason.stack) {
        this.stack = reason.stack;
        reason = reason.message;
      }
      this.message = reason;
      this.name = range;
      this.reason = reason;
      this.line = position2 ? position2.line : null;
      this.column = position2 ? position2.column : null;
      this.location = location;
      this.source = parts[0];
      this.ruleId = parts[1];
    }
    function parseOrigin(origin) {
      var result = [null, null];
      var index2;
      if (typeof origin === "string") {
        index2 = origin.indexOf(":");
        if (index2 === -1) {
          result[1] = origin;
        } else {
          result[0] = origin.slice(0, index2);
          result[1] = origin.slice(index2 + 1);
        }
      }
      return result;
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-expression-npm-0.3.2-2a4a54711b-433b81d977.zip/node_modules/micromark-extension-mdx-expression/lib/util-events-to-acorn.js
var require_util_events_to_acorn = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-expression-npm-0.3.2-2a4a54711b-433b81d977.zip/node_modules/micromark-extension-mdx-expression/lib/util-events-to-acorn.js"(exports, module2) {
    "use strict";
    var VMessage = require_vfile_message();
    module2.exports = eventsToAcorn;
    function eventsToAcorn(acorn, acornOptions, events, config) {
      var before = config.prefix || "";
      var after = config.suffix || "";
      var comments = [];
      var acornConfig = Object.assign({}, acornOptions, { onComment: comments });
      var value;
      var swallow = false;
      var estree;
      var exception;
      var index2 = -1;
      var chunks = [];
      var lines = {};
      var mdStartOffset;
      var source;
      var token;
      var point2;
      var isEmptyExpression;
      if (config.start) {
        mdStartOffset = config.start.offset;
        lines[config.start.line] = config.start;
      }
      while (++index2 < events.length) {
        token = events[index2][1];
        if (events[index2][0] === "exit") {
          chunks.push(events[index2][2].sliceSerialize(token));
          if (mdStartOffset === void 0) {
            mdStartOffset = events[index2][1].start.offset;
          }
          if (!(token.start.line in lines) || lines[token.start.line].offset > token.start.offset) {
            lines[token.start.line] = token.start;
          }
        }
      }
      source = chunks.join("");
      value = before + source + after;
      isEmptyExpression = config.expression && empty(source);
      if (isEmptyExpression && !config.allowEmpty) {
        throw new VMessage("Unexpected empty expression", parseOffsetToUnistPoint(0), "micromark-extension-mdx-expression:unexpected-empty-expression");
      }
      try {
        estree = config.expression && !isEmptyExpression ? acorn.parseExpressionAt(value, 0, acornConfig) : acorn.parse(value, acornConfig);
      } catch (error) {
        point2 = parseOffsetToUnistPoint(error.pos);
        error.message = String(error.message).replace(/ \(\d+:\d+\)$/, "");
        error.pos = point2.offset;
        error.loc = { line: point2.line, column: point2.column - 1 };
        exception = error;
        swallow = error.raisedAt >= before.length + source.length || error.message === "Unterminated comment";
      }
      if (estree && config.expression && !isEmptyExpression) {
        if (empty(value.slice(estree.end, value.length - after.length))) {
          estree = {
            type: "Program",
            start: 0,
            end: before.length + source.length,
            body: [
              {
                type: "ExpressionStatement",
                expression: estree,
                start: 0,
                end: before.length + source.length
              }
            ],
            sourceType: "module"
          };
        } else {
          point2 = parseOffsetToUnistPoint(estree.end);
          exception = new Error("Unexpected content after expression");
          exception.pos = point2.offset;
          exception.loc = { line: point2.line, column: point2.column - 1 };
          estree = void 0;
        }
      }
      if (estree) {
        estree.comments = comments;
        visit3(estree);
      }
      return { estree, error: exception, swallow };
      function visit3(esnode) {
        var point3;
        var key2;
        var index3;
        if (!(esnode && typeof esnode === "object" && "type" in esnode && "end" in esnode)) {
          return;
        }
        if ("start" in esnode && "end" in esnode) {
          point3 = parseOffsetToUnistPoint(esnode.start);
          esnode.start = point3.offset;
          esnode.loc = { start: { line: point3.line, column: point3.column - 1 } };
          point3 = parseOffsetToUnistPoint(esnode.end);
          esnode.end = point3.offset;
          esnode.loc.end = { line: point3.line, column: point3.column - 1 };
          esnode.range = [esnode.start, esnode.end];
        } else {
          esnode.start = void 0;
          esnode.end = void 0;
          esnode.loc = void 0;
          esnode.range = void 0;
        }
        for (key2 in esnode) {
          if (esnode[key2] && typeof esnode[key2] === "object") {
            if ("length" in esnode[key2]) {
              index3 = -1;
              while (++index3 < esnode[key2].length) {
                visit3(esnode[key2][index3]);
              }
            } else {
              visit3(esnode[key2]);
            }
          }
        }
      }
      function parseOffsetToUnistPoint(offset) {
        var srcOffset = offset - before.length;
        var line;
        var lineStart;
        if (srcOffset < 0)
          srcOffset = 0;
        else if (srcOffset > source.length)
          srcOffset = source.length;
        srcOffset += mdStartOffset;
        for (line in lines) {
          if (!lineStart)
            lineStart = lines[line];
          if (lines[line].offset > offset)
            break;
          lineStart = lines[line];
        }
        return {
          line: lineStart.line,
          column: lineStart.column + (srcOffset - lineStart.offset),
          offset: srcOffset
        };
      }
    }
    function empty(value) {
      return /^\s*$/.test(value.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, ""));
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-expression-npm-0.3.2-2a4a54711b-433b81d977.zip/node_modules/micromark-extension-mdx-expression/lib/factory-expression.js
var require_factory_expression = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-expression-npm-0.3.2-2a4a54711b-433b81d977.zip/node_modules/micromark-extension-mdx-expression/lib/factory-expression.js"(exports, module2) {
    "use strict";
    module2.exports = factoryExpression;
    var markdownLineEnding2 = require_markdown_line_ending();
    var factoryWhitespace2 = require_factory_whitespace();
    var VMessage = require_vfile_message();
    var eventsToAcorn = require_util_events_to_acorn();
    function factoryExpression(effects, ok2, nok, acorn, acornOptions, addResult, expressionType, expressionMarkerType, expressionChunkType, spread, forbidEmpty) {
      var self2 = this;
      var eventStart = this.events.length + 3;
      var balance = 1;
      var startPosition;
      var lastCrash;
      return start;
      function start(code2) {
        effects.enter(expressionType);
        effects.enter(expressionMarkerType);
        effects.consume(code2);
        effects.exit(expressionMarkerType);
        startPosition = self2.now();
        return atBreak;
      }
      function atBreak(code2) {
        if (code2 === null) {
          throw lastCrash || new VMessage("Unexpected end of file in expression, expected a corresponding closing brace for `{`", self2.now(), "micromark-extension-mdx-expression:unexpected-eof");
        }
        if (code2 === 125) {
          return atClosingBrace(code2);
        }
        if (markdownLineEnding2(code2)) {
          return factoryWhitespace2(effects, atBreak)(code2);
        }
        effects.enter(expressionChunkType);
        return inside(code2);
      }
      function inside(code2) {
        if (code2 === null || code2 === 125 || markdownLineEnding2(code2)) {
          effects.exit(expressionChunkType);
          return atBreak(code2);
        }
        if (code2 === 123 && !acorn) {
          effects.consume(code2);
          balance++;
          return inside;
        }
        effects.consume(code2);
        return inside;
      }
      function atClosingBrace(code2) {
        var result;
        var token;
        var estree;
        balance--;
        if (!acorn) {
          if (balance) {
            effects.enter(expressionChunkType);
            effects.consume(code2);
            return inside;
          }
          effects.enter(expressionMarkerType);
          effects.consume(code2);
          effects.exit(expressionMarkerType);
          effects.exit(expressionType);
          return ok2;
        }
        result = eventsToAcorn(acorn, acornOptions, self2.events.slice(eventStart), {
          start: startPosition,
          expression: true,
          allowEmpty: !spread && !forbidEmpty,
          prefix: spread ? "({" : "",
          suffix: spread ? "})" : ""
        });
        estree = result.estree;
        if (spread && estree && estree.type === "Program" && estree.body[0] && estree.body[0].type === "ExpressionStatement" && estree.body[0].expression.type === "ObjectExpression") {
          if (estree.body[0].expression.properties[1]) {
            throw new VMessage("Unexpected extra content in spread: only a single spread is supported", {
              line: estree.body[0].expression.properties[1].loc.start.line,
              column: estree.body[0].expression.properties[1].loc.start.column + 1,
              offset: estree.body[0].expression.properties[1].start
            }, "micromark-extension-mdx-expression:spread-extra");
          } else if (estree.body[0].expression.properties[0].type !== "SpreadElement") {
            throw new VMessage("Unexpected `" + estree.body[0].expression.properties[0].type + "` in code: only spread elements are supported", {
              line: estree.body[0].expression.properties[0].loc.start.line,
              column: estree.body[0].expression.properties[0].loc.start.column + 1,
              offset: estree.body[0].expression.properties[0].start
            }, "micromark-extension-mdx-expression:non-spread");
          }
        }
        if (result.error) {
          lastCrash = new VMessage("Could not parse expression with acorn: " + result.error.message, {
            line: result.error.loc.line,
            column: result.error.loc.column + 1,
            offset: result.error.pos
          }, "micromark-extension-mdx-expression:acorn");
          if (code2 !== null && result.swallow) {
            effects.enter(expressionChunkType);
            effects.consume(code2);
            return inside;
          }
          throw lastCrash;
        }
        effects.enter(expressionMarkerType);
        effects.consume(code2);
        effects.exit(expressionMarkerType);
        token = effects.exit(expressionType);
        if (addResult)
          token.estree = estree;
        return ok2;
      }
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-expression-npm-0.3.2-2a4a54711b-433b81d977.zip/node_modules/micromark-extension-mdx-expression/lib/index.js
var require_lib = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-expression-npm-0.3.2-2a4a54711b-433b81d977.zip/node_modules/micromark-extension-mdx-expression/lib/index.js"(exports, module2) {
    "use strict";
    module2.exports = mdxExpression;
    var markdownLineEnding2 = require_markdown_line_ending();
    var factorySpace2 = require_factory_space();
    var factoryExpression = require_factory_expression();
    function mdxExpression(options) {
      var settings = options || {};
      var addResult = settings.addResult;
      var acorn = settings.acorn;
      var spread;
      var forbidEmpty;
      var acornOptions;
      if (acorn) {
        if (!acorn.parseExpressionAt) {
          throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
        }
        acornOptions = Object.assign({ ecmaVersion: 2020, sourceType: "module" }, options.acornOptions || {});
        spread = settings.spread;
        forbidEmpty = settings.forbidEmpty;
      } else if (settings.acornOptions || settings.addResult) {
        throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
      }
      return {
        flow: { 123: { tokenize: tokenizeFlowExpression, concrete: true } },
        text: { 123: { tokenize: tokenizeTextExpression } }
      };
      function tokenizeFlowExpression(effects, ok2, nok) {
        var self2 = this;
        return start;
        function start(code2) {
          if (code2 !== 123)
            throw new Error("Expected `{`");
          return factoryExpression.call(self2, effects, factorySpace2(effects, after, "whitespace"), nok, acorn, acornOptions, addResult, "mdxFlowExpression", "mdxFlowExpressionMarker", "mdxFlowExpressionChunk", spread, forbidEmpty)(code2);
        }
        function after(code2) {
          return code2 === null || markdownLineEnding2(code2) ? ok2(code2) : nok(code2);
        }
      }
      function tokenizeTextExpression(effects, ok2, nok) {
        var self2 = this;
        return start;
        function start(code2) {
          if (code2 !== 123)
            throw new Error("Expected `{`");
          return factoryExpression.call(self2, effects, ok2, nok, acorn, acornOptions, addResult, "mdxTextExpression", "mdxTextExpressionMarker", "mdxTextExpressionChunk", spread, forbidEmpty)(code2);
        }
      }
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-expression-npm-0.3.2-2a4a54711b-433b81d977.zip/node_modules/micromark-extension-mdx-expression/index.js
var require_micromark_extension_mdx_expression = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-expression-npm-0.3.2-2a4a54711b-433b81d977.zip/node_modules/micromark-extension-mdx-expression/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_lib();
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/estree-util-is-identifier-name-npm-1.1.0-cceaeaec69-af7043149a.zip/node_modules/estree-util-is-identifier-name/regex.js
var require_regex = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/estree-util-is-identifier-name-npm-1.1.0-cceaeaec69-af7043149a.zip/node_modules/estree-util-is-identifier-name/regex.js"(exports) {
    exports.start = /[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;
    exports.cont = /[0-9\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F]/;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/estree-util-is-identifier-name-npm-1.1.0-cceaeaec69-af7043149a.zip/node_modules/estree-util-is-identifier-name/index.js
var require_estree_util_is_identifier_name = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/estree-util-is-identifier-name-npm-1.1.0-cceaeaec69-af7043149a.zip/node_modules/estree-util-is-identifier-name/index.js"(exports) {
    "use strict";
    exports.start = start;
    exports.cont = cont;
    exports.name = name2;
    var id = require_regex();
    function start(code2) {
      return id.start.test(String.fromCharCode(code2));
    }
    function cont(code2) {
      var character = String.fromCharCode(code2);
      return id.start.test(character) || id.cont.test(character);
    }
    function name2(name3) {
      var index2 = -1;
      while (++index2 < name3.length) {
        if (!(index2 ? cont : start)(name3.charCodeAt(index2)))
          return false;
      }
      return index2 > 0;
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/character/markdown-line-ending-or-space.js
var require_markdown_line_ending_or_space = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/character/markdown-line-ending-or-space.js"(exports, module2) {
    "use strict";
    function markdownLineEndingOrSpace2(code2) {
      return code2 < 0 || code2 === 32;
    }
    module2.exports = markdownLineEndingOrSpace2;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/constant/from-char-code.js
var require_from_char_code = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/constant/from-char-code.js"(exports, module2) {
    "use strict";
    var fromCharCode2 = String.fromCharCode;
    module2.exports = fromCharCode2;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/util/regex-check.js
var require_regex_check = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/util/regex-check.js"(exports, module2) {
    "use strict";
    var fromCharCode2 = require_from_char_code();
    function regexCheck2(regex) {
      return check;
      function check(code2) {
        return regex.test(fromCharCode2(code2));
      }
    }
    module2.exports = regexCheck2;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/character/unicode-whitespace.js
var require_unicode_whitespace = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/character/unicode-whitespace.js"(exports, module2) {
    "use strict";
    var regexCheck2 = require_regex_check();
    var unicodeWhitespace2 = regexCheck2(/\s/);
    module2.exports = unicodeWhitespace2;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-jsx-npm-0.3.3-1a20ad1f60-2af2c66822.zip/node_modules/micromark-extension-mdx-jsx/lib/factory-tag.js
var require_factory_tag = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-jsx-npm-0.3.3-1a20ad1f60-2af2c66822.zip/node_modules/micromark-extension-mdx-jsx/lib/factory-tag.js"(exports, module2) {
    "use strict";
    module2.exports = factoryTag;
    var id = require_estree_util_is_identifier_name();
    var markdownLineEnding2 = require_markdown_line_ending();
    var markdownLineEndingOrSpace2 = require_markdown_line_ending_or_space();
    var markdownSpace2 = require_markdown_space();
    var esWhitespace = require_unicode_whitespace();
    var fromCharCode2 = require_from_char_code();
    var factoryExpression = require_factory_expression();
    var VMessage = require_vfile_message();
    function factoryTag(effects, ok2, nok, acorn, acornOptions, addResult, tagType, tagMarkerType, tagClosingMarkerType, tagSelfClosingMarker, tagNameType, tagNamePrimaryType, tagNameMemberMarkerType, tagNameMemberType, tagNamePrefixMarkerType, tagNameLocalType, tagExpressionAttributeType, tagExpressionAttributeMarkerType, tagExpressionAttributeValueType, tagAttributeType, tagAttributeNameType, tagAttributeNamePrimaryType, tagAttributeNamePrefixMarkerType, tagAttributeNameLocalType, tagAttributeInitializerMarkerType, tagAttributeValueLiteralType, tagAttributeValueLiteralMarkerType, tagAttributeValueLiteralValueType, tagAttributeValueExpressionType, tagAttributeValueExpressionMarkerType, tagAttributeValueExpressionMarkerValue) {
      var self2 = this;
      var returnState;
      var marker;
      return start;
      function start(code2) {
        effects.enter(tagType);
        effects.enter(tagMarkerType);
        effects.consume(code2);
        effects.exit(tagMarkerType);
        return afterStart;
      }
      function afterStart(code2) {
        if (markdownLineEnding2(code2) || markdownSpace2(code2)) {
          return nok(code2);
        }
        returnState = beforeName;
        return optionalEsWhitespace(code2);
      }
      function beforeName(code2) {
        if (code2 === 47) {
          effects.enter(tagClosingMarkerType);
          effects.consume(code2);
          effects.exit(tagClosingMarkerType);
          returnState = beforeClosingTagName;
          return optionalEsWhitespace;
        }
        if (code2 === 62) {
          return tagEnd(code2);
        }
        if (id.start(code2)) {
          effects.enter(tagNameType);
          effects.enter(tagNamePrimaryType);
          effects.consume(code2);
          return primaryName;
        }
        crash(code2, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (code2 === 33 ? " (note: to create a comment in MDX, use `{/* text */}`)" : ""));
      }
      function beforeClosingTagName(code2) {
        if (code2 === 62) {
          return tagEnd(code2);
        }
        if (id.start(code2)) {
          effects.enter(tagNameType);
          effects.enter(tagNamePrimaryType);
          effects.consume(code2);
          return primaryName;
        }
        crash(code2, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (code2 === 42 || code2 === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : ""));
      }
      function primaryName(code2) {
        if (code2 === 45 || id.cont(code2)) {
          effects.consume(code2);
          return primaryName;
        }
        if (code2 === 46 || code2 === 47 || code2 === 58 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace2(code2) || esWhitespace(code2)) {
          effects.exit(tagNamePrimaryType);
          returnState = afterPrimaryName;
          return optionalEsWhitespace(code2);
        }
        crash(code2, "in name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code2 === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
      }
      function afterPrimaryName(code2) {
        if (code2 === 46) {
          effects.enter(tagNameMemberMarkerType);
          effects.consume(code2);
          effects.exit(tagNameMemberMarkerType);
          returnState = beforeMemberName;
          return optionalEsWhitespace;
        }
        if (code2 === 58) {
          effects.enter(tagNamePrefixMarkerType);
          effects.consume(code2);
          effects.exit(tagNamePrefixMarkerType);
          returnState = beforeLocalName;
          return optionalEsWhitespace;
        }
        if (code2 === 47 || code2 === 62 || code2 === 123 || id.start(code2)) {
          effects.exit(tagNameType);
          return beforeAttribute(code2);
        }
        crash(code2, "after name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
      }
      function beforeMemberName(code2) {
        if (id.start(code2)) {
          effects.enter(tagNameMemberType);
          effects.consume(code2);
          return memberName;
        }
        crash(code2, "before member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
      }
      function memberName(code2) {
        if (code2 === 45 || id.cont(code2)) {
          effects.consume(code2);
          return memberName;
        }
        if (code2 === 46 || code2 === 47 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace2(code2) || esWhitespace(code2)) {
          effects.exit(tagNameMemberType);
          returnState = afterMemberName;
          return optionalEsWhitespace(code2);
        }
        crash(code2, "in member name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code2 === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
      }
      function afterMemberName(code2) {
        if (code2 === 46) {
          effects.enter(tagNameMemberMarkerType);
          effects.consume(code2);
          effects.exit(tagNameMemberMarkerType);
          returnState = beforeMemberName;
          return optionalEsWhitespace;
        }
        if (code2 === 47 || code2 === 62 || code2 === 123 || id.start(code2)) {
          effects.exit(tagNameType);
          return beforeAttribute(code2);
        }
        crash(code2, "after member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
      }
      function beforeLocalName(code2) {
        if (id.start(code2)) {
          effects.enter(tagNameLocalType);
          effects.consume(code2);
          return localName;
        }
        crash(code2, "before local name", "a character that can start a name, such as a letter, `$`, or `_`" + (code2 === 43 || code2 > 46 && code2 < 58 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
      }
      function localName(code2) {
        if (code2 === 45 || id.cont(code2)) {
          effects.consume(code2);
          return localName;
        }
        if (code2 === 47 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace2(code2) || esWhitespace(code2)) {
          effects.exit(tagNameLocalType);
          returnState = afterLocalName;
          return optionalEsWhitespace(code2);
        }
        crash(code2, "in local name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag");
      }
      function afterLocalName(code2) {
        if (code2 === 47 || code2 === 62 || code2 === 123 || id.start(code2)) {
          effects.exit(tagNameType);
          return beforeAttribute(code2);
        }
        crash(code2, "after local name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
      }
      function beforeAttribute(code2) {
        if (code2 === 47) {
          effects.enter(tagSelfClosingMarker);
          effects.consume(code2);
          effects.exit(tagSelfClosingMarker);
          returnState = selfClosing;
          return optionalEsWhitespace;
        }
        if (code2 === 62) {
          return tagEnd(code2);
        }
        if (code2 === 123) {
          return factoryExpression.call(self2, effects, afterAttributeExpression, nok, acorn, acornOptions, addResult, tagExpressionAttributeType, tagExpressionAttributeMarkerType, tagExpressionAttributeValueType, true)(code2);
        }
        if (id.start(code2)) {
          effects.enter(tagAttributeType);
          effects.enter(tagAttributeNameType);
          effects.enter(tagAttributeNamePrimaryType);
          effects.consume(code2);
          return attributePrimaryName;
        }
        crash(code2, "before attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
      }
      function afterAttributeExpression(code2) {
        returnState = beforeAttribute;
        return optionalEsWhitespace(code2);
      }
      function attributePrimaryName(code2) {
        if (code2 === 45 || id.cont(code2)) {
          effects.consume(code2);
          return attributePrimaryName;
        }
        if (code2 === 47 || code2 === 58 || code2 === 61 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace2(code2) || esWhitespace(code2)) {
          effects.exit(tagAttributeNamePrimaryType);
          returnState = afterAttributePrimaryName;
          return optionalEsWhitespace(code2);
        }
        crash(code2, "in attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag");
      }
      function afterAttributePrimaryName(code2) {
        if (code2 === 58) {
          effects.enter(tagAttributeNamePrefixMarkerType);
          effects.consume(code2);
          effects.exit(tagAttributeNamePrefixMarkerType);
          returnState = beforeAttributeLocalName;
          return optionalEsWhitespace;
        }
        if (code2 === 61) {
          effects.exit(tagAttributeNameType);
          effects.enter(tagAttributeInitializerMarkerType);
          effects.consume(code2);
          effects.exit(tagAttributeInitializerMarkerType);
          returnState = beforeAttributeValue;
          return optionalEsWhitespace;
        }
        if (code2 === 47 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace2(code2) || esWhitespace(code2) || id.start(code2)) {
          effects.exit(tagAttributeNameType);
          effects.exit(tagAttributeType);
          returnState = beforeAttribute;
          return optionalEsWhitespace(code2);
        }
        crash(code2, "after attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
      }
      function beforeAttributeLocalName(code2) {
        if (id.start(code2)) {
          effects.enter(tagAttributeNameLocalType);
          effects.consume(code2);
          return attributeLocalName;
        }
        crash(code2, "before local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
      }
      function attributeLocalName(code2) {
        if (code2 === 45 || id.cont(code2)) {
          effects.consume(code2);
          return attributeLocalName;
        }
        if (code2 === 47 || code2 === 61 || code2 === 62 || code2 === 123 || markdownLineEndingOrSpace2(code2) || esWhitespace(code2)) {
          effects.exit(tagAttributeNameLocalType);
          effects.exit(tagAttributeNameType);
          returnState = afterAttributeLocalName;
          return optionalEsWhitespace(code2);
        }
        crash(code2, "in local attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag");
      }
      function afterAttributeLocalName(code2) {
        if (code2 === 61) {
          effects.enter(tagAttributeInitializerMarkerType);
          effects.consume(code2);
          effects.exit(tagAttributeInitializerMarkerType);
          returnState = beforeAttributeValue;
          return optionalEsWhitespace;
        }
        if (code2 === 47 || code2 === 62 || code2 === 123 || id.start(code2)) {
          effects.exit(tagAttributeType);
          return beforeAttribute(code2);
        }
        crash(code2, "after local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
      }
      function beforeAttributeValue(code2) {
        if (code2 === 34 || code2 === 39) {
          effects.enter(tagAttributeValueLiteralType);
          effects.enter(tagAttributeValueLiteralMarkerType);
          effects.consume(code2);
          effects.exit(tagAttributeValueLiteralMarkerType);
          marker = code2;
          return attributeValueQuotedStart;
        }
        if (code2 === 123) {
          return factoryExpression.call(self2, effects, afterAttributeValueExpression, nok, acorn, acornOptions, addResult, tagAttributeValueExpressionType, tagAttributeValueExpressionMarkerType, tagAttributeValueExpressionMarkerValue, false, true)(code2);
        }
        crash(code2, "before attribute value", "a character that can start an attribute value, such as `\"`, `'`, or `{`" + (code2 === 60 ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : ""));
      }
      function afterAttributeValueExpression(code2) {
        effects.exit(tagAttributeType);
        returnState = beforeAttribute;
        return optionalEsWhitespace(code2);
      }
      function attributeValueQuotedStart(code2) {
        if (code2 === null) {
          crash(code2, "in attribute value", "a corresponding closing quote `" + fromCharCode2(marker) + "`");
        }
        if (code2 === marker) {
          effects.enter(tagAttributeValueLiteralMarkerType);
          effects.consume(code2);
          effects.exit(tagAttributeValueLiteralMarkerType);
          effects.exit(tagAttributeValueLiteralType);
          effects.exit(tagAttributeType);
          marker = void 0;
          returnState = beforeAttribute;
          return optionalEsWhitespace;
        }
        if (markdownLineEnding2(code2)) {
          returnState = attributeValueQuotedStart;
          return optionalEsWhitespace(code2);
        }
        effects.enter(tagAttributeValueLiteralValueType);
        return attributeValueQuoted(code2);
      }
      function attributeValueQuoted(code2) {
        if (code2 === null || code2 === marker || markdownLineEnding2(code2)) {
          effects.exit(tagAttributeValueLiteralValueType);
          return attributeValueQuotedStart(code2);
        }
        effects.consume(code2);
        return attributeValueQuoted;
      }
      function selfClosing(code2) {
        if (code2 === 62) {
          return tagEnd(code2);
        }
        crash(code2, "after self-closing slash", "`>` to end the tag" + (code2 === 42 || code2 === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : ""));
      }
      function tagEnd(code2) {
        if (code2 !== 62)
          throw new Error("expected `>`");
        effects.enter(tagMarkerType);
        effects.consume(code2);
        effects.exit(tagMarkerType);
        effects.exit(tagType);
        return ok2;
      }
      function optionalEsWhitespace(code2) {
        if (markdownLineEnding2(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return optionalEsWhitespace;
        }
        if (markdownSpace2(code2) || esWhitespace(code2)) {
          effects.enter("esWhitespace");
          return optionalEsWhitespaceContinue(code2);
        }
        return returnState(code2);
      }
      function optionalEsWhitespaceContinue(code2) {
        if (markdownLineEnding2(code2) || !(markdownSpace2(code2) || esWhitespace(code2))) {
          effects.exit("esWhitespace");
          return optionalEsWhitespace(code2);
        }
        effects.consume(code2);
        return optionalEsWhitespaceContinue;
      }
      function crash(code2, at, expect) {
        throw new VMessage("Unexpected " + (code2 === null ? "end of file" : "character `" + (code2 === 96 ? "` ` `" : fromCharCode2(code2)) + "` (" + serializeCharCode(code2) + ")") + " " + at + ", expected " + expect, self2.now(), "micromark-extension-mdx-jsx:unexpected-" + (code2 === null ? "eof" : "character"));
      }
    }
    function serializeCharCode(code2) {
      var value = code2.toString(16).toUpperCase();
      while (value.length < 4)
        value = "0" + value;
      return "U+" + value;
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-jsx-npm-0.3.3-1a20ad1f60-2af2c66822.zip/node_modules/micromark-extension-mdx-jsx/lib/jsx-text.js
var require_jsx_text = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-jsx-npm-0.3.3-1a20ad1f60-2af2c66822.zip/node_modules/micromark-extension-mdx-jsx/lib/jsx-text.js"(exports, module2) {
    "use strict";
    module2.exports = createJsxText;
    var factoryTag = require_factory_tag();
    function createJsxText(acorn, acornOptions, addResult) {
      return { tokenize: tokenizeJsxText };
      function tokenizeJsxText(effects, ok2, nok) {
        return factoryTag.call(this, effects, ok2, nok, acorn, acornOptions, addResult, "mdxJsxTextTag", "mdxJsxTextTagMarker", "mdxJsxTextTagClosingMarker", "mdxJsxTextTagSelfClosingMarker", "mdxJsxTextTagName", "mdxJsxTextTagNamePrimary", "mdxJsxTextTagNameMemberMarker", "mdxJsxTextTagNameMember", "mdxJsxTextTagNamePrefixMarker", "mdxJsxTextTagNameLocal", "mdxJsxTextTagExpressionAttribute", "mdxJsxTextTagExpressionAttributeMarker", "mdxJsxTextTagExpressionAttributeValue", "mdxJsxTextTagAttribute", "mdxJsxTextTagAttributeName", "mdxJsxTextTagAttributeNamePrimary", "mdxJsxTextTagAttributeNamePrefixMarker", "mdxJsxTextTagAttributeNameLocal", "mdxJsxTextTagAttributeInitializerMarker", "mdxJsxTextTagAttributeValueLiteral", "mdxJsxTextTagAttributeValueLiteralMarker", "mdxJsxTextTagAttributeValueLiteralValue", "mdxJsxTextTagAttributeValueExpression", "mdxJsxTextTagAttributeValueExpressionMarker", "mdxJsxTextTagAttributeValueExpressionValue");
      }
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-jsx-npm-0.3.3-1a20ad1f60-2af2c66822.zip/node_modules/micromark-extension-mdx-jsx/lib/jsx-flow.js
var require_jsx_flow = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-jsx-npm-0.3.3-1a20ad1f60-2af2c66822.zip/node_modules/micromark-extension-mdx-jsx/lib/jsx-flow.js"(exports, module2) {
    "use strict";
    module2.exports = createJsxFlow;
    var markdownLineEnding2 = require_markdown_line_ending();
    var factorySpace2 = require_factory_space();
    var factoryTag = require_factory_tag();
    function createJsxFlow(acorn, acornOptions, addResult) {
      return { tokenize: tokenizeJsxFlow, concrete: true };
      function tokenizeJsxFlow(effects, ok2, nok) {
        var self2 = this;
        return start;
        function start(code2) {
          return factoryTag.call(self2, effects, factorySpace2(effects, after, "whitespace"), nok, acorn, acornOptions, addResult, "mdxJsxFlowTag", "mdxJsxFlowTagMarker", "mdxJsxFlowTagClosingMarker", "mdxJsxFlowTagSelfClosingMarker", "mdxJsxFlowTagName", "mdxJsxFlowTagNamePrimary", "mdxJsxFlowTagNameMemberMarker", "mdxJsxFlowTagNameMember", "mdxJsxFlowTagNamePrefixMarker", "mdxJsxFlowTagNameLocal", "mdxJsxFlowTagExpressionAttribute", "mdxJsxFlowTagExpressionAttributeMarker", "mdxJsxFlowTagExpressionAttributeValue", "mdxJsxFlowTagAttribute", "mdxJsxFlowTagAttributeName", "mdxJsxFlowTagAttributeNamePrimary", "mdxJsxFlowTagAttributeNamePrefixMarker", "mdxJsxFlowTagAttributeNameLocal", "mdxJsxFlowTagAttributeInitializerMarker", "mdxJsxFlowTagAttributeValueLiteral", "mdxJsxFlowTagAttributeValueLiteralMarker", "mdxJsxFlowTagAttributeValueLiteralValue", "mdxJsxFlowTagAttributeValueExpression", "mdxJsxFlowTagAttributeValueExpressionMarker", "mdxJsxFlowTagAttributeValueExpressionValue")(code2);
        }
        function after(code2) {
          if (code2 === 60) {
            return start(code2);
          }
          return code2 === null || markdownLineEnding2(code2) ? ok2(code2) : nok(code2);
        }
      }
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-jsx-npm-0.3.3-1a20ad1f60-2af2c66822.zip/node_modules/micromark-extension-mdx-jsx/lib/index.js
var require_lib2 = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-jsx-npm-0.3.3-1a20ad1f60-2af2c66822.zip/node_modules/micromark-extension-mdx-jsx/lib/index.js"(exports, module2) {
    "use strict";
    module2.exports = mdxJsx;
    var createJsxText = require_jsx_text();
    var createJsxFlow = require_jsx_flow();
    function mdxJsx(options) {
      var settings = options || {};
      var acorn = settings.acorn;
      var addResult = settings.addResult;
      var acornOptions;
      if (acorn) {
        if (!acorn.parseExpressionAt) {
          throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
        }
        acornOptions = Object.assign({ ecmaVersion: 2020, sourceType: "module" }, options.acornOptions || {}, { locations: true });
      } else if (settings.acornOptions || addResult) {
        throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
      }
      return {
        flow: { 60: createJsxFlow(acorn, acornOptions, addResult) },
        text: { 60: createJsxText(acorn, acornOptions, addResult) }
      };
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-jsx-npm-0.3.3-1a20ad1f60-2af2c66822.zip/node_modules/micromark-extension-mdx-jsx/index.js
var require_micromark_extension_mdx_jsx = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-jsx-npm-0.3.3-1a20ad1f60-2af2c66822.zip/node_modules/micromark-extension-mdx-jsx/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_lib2();
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-md-npm-0.1.1-c765df71f1-7790328412.zip/node_modules/micromark-extension-mdx-md/index.js
var require_micromark_extension_mdx_md = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-md-npm-0.1.1-c765df71f1-7790328412.zip/node_modules/micromark-extension-mdx-md/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] }
    };
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-npm-0.2.1-d4c81ce768-042fabf994.zip/node_modules/micromark-extension-mdx/index.js
var require_micromark_extension_mdx = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdx-npm-0.2.1-d4c81ce768-042fabf994.zip/node_modules/micromark-extension-mdx/index.js"(exports, module2) {
    var combine = require_combine_extensions();
    var expression = require_micromark_extension_mdx_expression();
    var jsx = require_micromark_extension_mdx_jsx();
    var md = require_micromark_extension_mdx_md();
    module2.exports = create;
    function create() {
      return combine([expression(), jsx(), md]);
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/acorn-npm-8.5.0-faed0ea119-989ff8bf4b.zip/node_modules/acorn/dist/acorn.js
var require_acorn = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/acorn-npm-8.5.0-faed0ea119-989ff8bf4b.zip/node_modules/acorn/dist/acorn.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = global || self, factory(global.acorn = {}));
    })(exports, function(exports2) {
      "use strict";
      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };
      var keywordRelationalOperator = /^in(stanceof)?$/;
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function isInAstralSet(code2, set) {
        var pos = 65536;
        for (var i = 0; i < set.length; i += 2) {
          pos += set[i];
          if (pos > code2) {
            return false;
          }
          pos += set[i + 1];
          if (pos >= code2) {
            return true;
          }
        }
      }
      function isIdentifierStart(code2, astral) {
        if (code2 < 65) {
          return code2 === 36;
        }
        if (code2 < 91) {
          return true;
        }
        if (code2 < 97) {
          return code2 === 95;
        }
        if (code2 < 123) {
          return true;
        }
        if (code2 <= 65535) {
          return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code2, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code2, astral) {
        if (code2 < 48) {
          return code2 === 36;
        }
        if (code2 < 58) {
          return true;
        }
        if (code2 < 65) {
          return false;
        }
        if (code2 < 91) {
          return true;
        }
        if (code2 < 97) {
          return code2 === 95;
        }
        if (code2 < 123) {
          return true;
        }
        if (code2 <= 65535) {
          return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
      }
      var TokenType = function TokenType2(label, conf) {
        if (conf === void 0)
          conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop(name2, prec) {
        return new TokenType(name2, { beforeExpr: true, binop: prec });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
      var keywords$1 = {};
      function kw(name2, options) {
        if (options === void 0)
          options = {};
        options.keyword = name2;
        return keywords$1[name2] = new TokenType(name2, options);
      }
      var types = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
        eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", { isLoop: true, beforeExpr: true }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", { beforeExpr: true, startsExpr: true }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code2) {
        return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref = Object.prototype;
      var hasOwnProperty3 = ref.hasOwnProperty;
      var toString2 = ref.toString;
      function has(obj, propName) {
        return hasOwnProperty3.call(obj, propName);
      }
      var isArray = Array.isArray || function(obj) {
        return toString2.call(obj) === "[object Array]";
      };
      function wordsRegexp(words) {
        return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
      }
      var Position = function Position2(line, col) {
        this.line = line;
        this.column = col;
      };
      Position.prototype.offset = function offset(n) {
        return new Position(this.line, this.column + n);
      };
      var SourceLocation = function SourceLocation2(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0; ; ) {
          lineBreakG.lastIndex = cur;
          var match = lineBreakG.exec(input);
          if (match && match.index < offset) {
            ++line;
            cur = match.index + match[0].length;
          } else {
            return new Position(line, offset - cur);
          }
        }
      }
      var defaultOptions = {
        ecmaVersion: null,
        sourceType: "script",
        onInsertedSemicolon: null,
        onTrailingComma: null,
        allowReserved: null,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowAwaitOutsideFunction: null,
        allowSuperOutsideMethod: null,
        allowHashBang: false,
        locations: false,
        onToken: null,
        onComment: null,
        ranges: false,
        program: null,
        sourceFile: null,
        directSourceFile: null,
        preserveParens: false
      };
      var warnedAboutEcmaVersion = false;
      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions) {
          options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (isArray(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray(options.onComment)) {
          options.onComment = pushComment(options, options.onComment);
        }
        return options;
      }
      function pushComment(options, array) {
        return function(block, text4, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text4,
            start,
            end
          };
          if (options.locations) {
            comment.loc = new SourceLocation(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [start, end];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
      var Parser = function Parser2(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
      Parser.prototype.parse = function parse4() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
      prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      };
      prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.canAwait.get = function() {
        for (var i = this.scopeStack.length - 1; i >= 0; i--) {
          var scope = this.scopeStack[i];
          if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
            return false;
          }
          if (scope.flags & SCOPE_FUNCTION) {
            return (scope.flags & SCOPE_ASYNC) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors.allowSuper.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        var inClassFieldInit = ref2.inClassFieldInit;
        return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      };
      prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors.allowNewDotTarget.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        var inClassFieldInit = ref2.inClassFieldInit;
        return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
      };
      prototypeAccessors.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
      };
      Parser.extend = function extend2() {
        var plugins = [], len = arguments.length;
        while (len--)
          plugins[len] = arguments[len];
        var cls = this;
        for (var i = 0; i < plugins.length; i++) {
          cls = plugins[i](cls);
        }
        return cls;
      };
      Parser.parse = function parse4(input, options) {
        return new this(options, input).parse();
      };
      Parser.parseExpressionAt = function parseExpressionAt2(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser.tokenizer = function tokenizer2(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser.prototype, prototypeAccessors);
      var pp = Parser.prototype;
      var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
      pp.strictDirective = function(start) {
        for (; ; ) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp.eat = function(type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp.isContextual = function(name2) {
        return this.type === types.name && this.value === name2 && !this.containsEsc;
      };
      pp.eatContextual = function(name2) {
        if (!this.isContextual(name2)) {
          return false;
        }
        this.next();
        return true;
      };
      pp.expectContextual = function(name2) {
        if (!this.eatContextual(name2)) {
          this.unexpected();
        }
      };
      pp.canInsertSemicolon = function() {
        return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp.semicolon = function() {
        if (!this.eat(types.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp.expect = function(type) {
        this.eat(type) || this.unexpected();
      };
      pp.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      function DestructuringErrors() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      }
      pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, "Parenthesized pattern");
        }
      };
      pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$1 = Parser.prototype;
      pp$1.parseTopLevel = function(node) {
        var exports3 = Object.create(null);
        if (!node.body) {
          node.body = [];
        }
        while (this.type !== types.eof) {
          var stmt = this.parseStatement(null, true, exports3);
          node.body.push(stmt);
        }
        if (this.inModule) {
          for (var i = 0, list3 = Object.keys(this.undefinedExports); i < list3.length; i += 1) {
            var name2 = list3[i];
            this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$1.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123) {
          return true;
        }
        if (isIdentifierStart(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$1.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$1.parseStatement = function(context, topLevel, exports3) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types._var;
          kind = "let";
        }
        switch (starttype) {
          case types._break:
          case types._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
          case types._debugger:
            return this.parseDebuggerStatement(node);
          case types._do:
            return this.parseDoStatement(node);
          case types._for:
            return this.parseForStatement(node);
          case types._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node, false, !context);
          case types._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node, true);
          case types._if:
            return this.parseIfStatement(node);
          case types._return:
            return this.parseReturnStatement(node);
          case types._switch:
            return this.parseSwitchStatement(node);
          case types._throw:
            return this.parseThrowStatement(node);
          case types._try:
            return this.parseTryStatement(node);
          case types._const:
          case types._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node, kind);
          case types._while:
            return this.parseWhileStatement(node);
          case types._with:
            return this.parseWithStatement(node);
          case types.braceL:
            return this.parseBlock(true, node);
          case types.semi:
            return this.parseEmptyStatement(node);
          case types._export:
          case types._import:
            if (this.options.ecmaVersion > 10 && starttype === types._import) {
              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports3);
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
              return this.parseLabeledStatement(node, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node, expr);
            }
        }
      };
      pp$1.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types.semi) || this.insertSemicolon()) {
          node.label = null;
        } else if (this.type !== types.name) {
          this.unexpected();
        } else {
          node.label = this.parseIdent();
          this.semicolon();
        }
        var i = 0;
        for (; i < this.labels.length; ++i) {
          var lab = this.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node.label && isBreak) {
              break;
            }
          }
        }
        if (i === this.labels.length) {
          this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$1.parseDebuggerStatement = function(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };
      pp$1.parseDoStatement = function(node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
      };
      pp$1.parseForStatement = function(node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types.parenL);
        if (this.type === types.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types._var || this.type === types._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node.await = awaitAt > -1;
              }
            }
            return this.parseForIn(node, init$1);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init$1);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var refDestructuringErrors = new DestructuringErrors();
        var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
        if (this.type === types._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLValPattern(init);
          return this.parseForIn(node, init);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      };
      pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      };
      pp$1.parseIfStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };
      pp$1.parseReturnStatement = function(node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types.semi) || this.insertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };
      pp$1.parseSwitchStatement = function(node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types.braceR; ) {
          if (this.type === types._case || this.type === types._default) {
            var isCase = this.type === types._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };
      pp$1.parseThrowStatement = function(node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };
      var empty = [];
      pp$1.parseTryStatement = function(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types.parenL)) {
            clause.param = this.parseBindingAtom();
            var simple = clause.param.type === "Identifier";
            this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
            this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
            this.expect(types.parenR);
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
      };
      pp$1.parseVarStatement = function(node, kind) {
        this.next();
        this.parseVar(node, false, kind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };
      pp$1.parseWhileStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };
      pp$1.parseWithStatement = function(node) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
      };
      pp$1.parseEmptyStatement = function(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };
      pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
        for (var i$1 = 0, list3 = this.labels; i$1 < list3.length; i$1 += 1) {
          var label = list3[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
        for (var i = this.labels.length - 1; i >= 0; i--) {
          var label$1 = this.labels[i];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };
      pp$1.parseExpressionStatement = function(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };
      pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0)
          createNewLexicalScope = true;
        if (node === void 0)
          node = this.startNode();
        node.body = [];
        this.expect(types.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
      };
      pp$1.parseFor = function(node, init) {
        node.init = init;
        this.expect(types.semi);
        node.test = this.type === types.semi ? null : this.parseExpression();
        this.expect(types.semi);
        node.update = this.type === types.parenR ? null : this.parseExpression();
        this.expect(types.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };
      pp$1.parseForIn = function(node, init) {
        var isForIn = this.type === types._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$1.parseVar = function(node, isFor, kind) {
        node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (kind === "const" && !(this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types.comma)) {
            break;
          }
        }
        return node;
      };
      pp$1.parseVarId = function(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node.generator = this.eat(types.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node.id = statement & FUNC_NULLABLE_ID && this.type !== types.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node.id = this.type === types.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$1.parseFunctionParams = function(node) {
        this.expect(types.parenL);
        node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$1.parseClass = function(node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types.braceL);
        while (this.type !== types.braceR) {
          var element = this.parseClassElement(node.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) {
                this.raise(element.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
              this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$1.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types.semi)) {
          return null;
        }
        var ecmaVersion = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion >= 13 && this.eat(types.braceL)) {
            this.parseClassStaticBlock(node);
            return node;
          }
          if (this.isClassElementNameStart() || this.type === types.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node.computed = false;
          node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node.key.name = keyName;
          this.finishNode(node.key, "Identifier");
        } else {
          this.parseClassElementName(node);
        }
        if (ecmaVersion < 13 || this.type === types.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node.static && checkKeyName(node, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node.key.start, "Constructor can't have get/set modifier");
          }
          node.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node);
        }
        return node;
      };
      pp$1.isClassElementNameStart = function() {
        return this.type === types.name || this.type === types.privateId || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword;
      };
      pp$1.parseClassElementName = function(element) {
        if (this.type === types.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element.computed = false;
          element.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element);
        }
      };
      pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        var key2 = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key2.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key2.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName(method, "prototype")) {
          this.raise(key2.start, "Classes may not have a static property named prototype");
        }
        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value.params.length !== 0) {
          this.raiseRecoverable(value.start, "getter should have no params");
        }
        if (method.kind === "set" && value.params.length !== 1) {
          this.raiseRecoverable(value.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value.params[0].type === "RestElement") {
          this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$1.parseClassField = function(field) {
        if (checkKeyName(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types.eq)) {
          var scope = this.currentThisScope();
          var inClassFieldInit = scope.inClassFieldInit;
          scope.inClassFieldInit = true;
          field.value = this.parseMaybeAssign();
          scope.inClassFieldInit = inClassFieldInit;
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$1.parseClassStaticBlock = function(node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while (this.type !== types.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
      };
      pp$1.parseClassId = function(node, isStatement) {
        if (this.type === types.name) {
          node.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node.id, BIND_LEXICAL, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node.id = null;
        }
      };
      pp$1.parseClassSuper = function(node) {
        node.superClass = this.eat(types._extends) ? this.parseExprSubscripts(false) : null;
      };
      pp$1.enterClassBody = function() {
        var element = { declared: Object.create(null), used: [] };
        this.privateNameStack.push(element);
        return element.declared;
      };
      pp$1.exitClassBody = function() {
        var ref2 = this.privateNameStack.pop();
        var declared = ref2.declared;
        var used = ref2.used;
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i = 0; i < used.length; ++i) {
          var id = used[i];
          if (!has(declared, id.name)) {
            if (parent) {
              parent.used.push(id);
            } else {
              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted(privateNameMap, element) {
        var name2 = element.key.name;
        var curr = privateNameMap[name2];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
          next = (element.static ? "s" : "i") + element.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name2] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name2] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName(node, name2) {
        var computed = node.computed;
        var key2 = node.key;
        return !computed && (key2.type === "Identifier" && key2.name === name2 || key2.type === "Literal" && key2.value === name2);
      }
      pp$1.parseExport = function(node, exports3) {
        this.next();
        if (this.eat(types.star)) {
          if (this.options.ecmaVersion >= 11) {
            if (this.eatContextual("as")) {
              node.exported = this.parseIdent(true);
              this.checkExport(exports3, node.exported.name, this.lastTokStart);
            } else {
              node.exported = null;
            }
          }
          this.expectContextual("from");
          if (this.type !== types.string) {
            this.unexpected();
          }
          node.source = this.parseExprAtom();
          this.semicolon();
          return this.finishNode(node, "ExportAllDeclaration");
        }
        if (this.eat(types._default)) {
          this.checkExport(exports3, "default", this.lastTokStart);
          var isAsync;
          if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) {
              this.next();
            }
            node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
          } else if (this.type === types._class) {
            var cNode = this.startNode();
            node.declaration = this.parseClass(cNode, "nullableID");
          } else {
            node.declaration = this.parseMaybeAssign();
            this.semicolon();
          }
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseStatement(null);
          if (node.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports3, node.declaration.declarations);
          } else {
            this.checkExport(exports3, node.declaration.id.name, node.declaration.id.start);
          }
          node.specifiers = [];
          node.source = null;
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports3);
          if (this.eatContextual("from")) {
            if (this.type !== types.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
          } else {
            for (var i = 0, list3 = node.specifiers; i < list3.length; i += 1) {
              var spec = list3[i];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
            }
            node.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      pp$1.checkExport = function(exports3, name2, pos) {
        if (!exports3) {
          return;
        }
        if (has(exports3, name2)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
        }
        exports3[name2] = true;
      };
      pp$1.checkPatternExport = function(exports3, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports3, pat.name, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i = 0, list3 = pat.properties; i < list3.length; i += 1) {
            var prop = list3[i];
            this.checkPatternExport(exports3, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports3, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports3, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports3, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports3, pat.argument);
        } else if (type === "ParenthesizedExpression") {
          this.checkPatternExport(exports3, pat.expression);
        }
      };
      pp$1.checkVariableExport = function(exports3, decls) {
        if (!exports3) {
          return;
        }
        for (var i = 0, list3 = decls; i < list3.length; i += 1) {
          var decl = list3[i];
          this.checkPatternExport(exports3, decl.id);
        }
      };
      pp$1.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$1.parseExportSpecifiers = function(exports3) {
        var nodes = [], first = true;
        this.expect(types.braceL);
        while (!this.eat(types.braceR)) {
          if (!first) {
            this.expect(types.comma);
            if (this.afterTrailingComma(types.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var node = this.startNode();
          node.local = this.parseIdent(true);
          node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
          this.checkExport(exports3, node.exported.name, node.exported.start);
          nodes.push(this.finishNode(node, "ExportSpecifier"));
        }
        return nodes;
      };
      pp$1.parseImport = function(node) {
        this.next();
        if (this.type === types.string) {
          node.specifiers = empty;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      pp$1.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types.name) {
          var node = this.startNode();
          node.local = this.parseIdent();
          this.checkLValSimple(node.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
          if (!this.eat(types.comma)) {
            return nodes;
          }
        }
        if (this.type === types.star) {
          var node$1 = this.startNode();
          this.next();
          this.expectContextual("as");
          node$1.local = this.parseIdent();
          this.checkLValSimple(node$1.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
          return nodes;
        }
        this.expect(types.braceL);
        while (!this.eat(types.braceR)) {
          if (!first) {
            this.expect(types.comma);
            if (this.afterTrailingComma(types.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var node$2 = this.startNode();
          node$2.imported = this.parseIdent(true);
          if (this.eatContextual("as")) {
            node$2.local = this.parseIdent();
          } else {
            this.checkUnreserved(node$2.imported);
            node$2.local = node$2.imported;
          }
          this.checkLValSimple(node$2.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node$2, "ImportSpecifier"));
        }
        return nodes;
      };
      pp$1.adaptDirectivePrologue = function(statements) {
        for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
          statements[i].directive = statements[i].expression.raw.slice(1, -1);
        }
      };
      pp$1.isDirectiveCandidate = function(statement) {
        return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$2 = Parser.prototype;
      pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
            case "Identifier":
              if (this.inAsync && node.name === "await") {
                this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i = 0, list3 = node.properties; i < list3.length; i += 1) {
                var prop = list3[i];
                this.toAssignable(prop, isBinding);
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node.kind !== "init") {
                this.raise(node.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node.value, isBinding);
              break;
            case "ArrayExpression":
              node.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node.elements, isBinding);
              break;
            case "SpreadElement":
              node.type = "RestElement";
              this.toAssignable(node.argument, isBinding);
              if (node.argument.type === "AssignmentPattern") {
                this.raise(node.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
      };
      pp$2.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i = 0; i < end; i++) {
          var elt = exprList[i];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$2.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
      };
      pp$2.parseRestBinding = function() {
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types.name) {
          this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };
      pp$2.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types.bracketL:
              var node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(types.bracketR, true, true);
              return this.finishNode(node, "ArrayPattern");
            case types.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types.comma);
          }
          if (allowEmpty && this.type === types.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            var elem = this.parseMaybeDefault(this.start, this.startLoc);
            this.parseBindingListItem(elem);
            elts.push(elem);
          }
        }
        return elts;
      };
      pp$2.parseBindingListItem = function(param) {
        return param;
      };
      pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {
          return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };
      pp$2.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (has(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$2.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i = 0, list3 = expr.properties; i < list3.length; i += 1) {
              var prop = list3[i];
              this.checkLValInnerPattern(prop, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$2.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types$1 = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };
      var pp$3 = Parser.prototype;
      pp$3.initialContext = function() {
        return [types$1.b_stat];
      };
      pp$3.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$3.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types$1.f_expr || parent === types$1.f_stat) {
          return true;
        }
        if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types._return || prevType === types.name && this.exprAllowed) {
          return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
          return true;
        }
        if (prevType === types.braceL) {
          return parent === types$1.b_stat;
        }
        if (prevType === types._var || prevType === types._const || prevType === types.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$3.inGeneratorContext = function() {
        for (var i = this.context.length - 1; i >= 1; i--) {
          var context = this.context[i];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$3.updateContext = function(prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types.dot) {
          this.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      pp$3.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types.parenR.updateContext = types.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types$1.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
        this.exprAllowed = true;
      };
      types.dollarBraceL.updateContext = function() {
        this.context.push(types$1.b_tmpl);
        this.exprAllowed = true;
      };
      types.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
        this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
        this.exprAllowed = true;
      };
      types.incDec.updateContext = function() {
      };
      types._function.updateContext = types._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types._else && !(prevType === types.semi && this.curContext() !== types$1.p_stat) && !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
          this.context.push(types$1.f_expr);
        } else {
          this.context.push(types$1.f_stat);
        }
        this.exprAllowed = false;
      };
      types.backQuote.updateContext = function() {
        if (this.curContext() === types$1.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types$1.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types.star.updateContext = function(prevType) {
        if (prevType === types._function) {
          var index2 = this.context.length - 1;
          if (this.context[index2] === types$1.f_expr) {
            this.context[index2] = types$1.f_expr_gen;
          } else {
            this.context[index2] = types$1.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$4 = Parser.prototype;
      pp$4.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key2 = prop.key;
        var name2;
        switch (key2.type) {
          case "Identifier":
            name2 = key2.name;
            break;
          case "Literal":
            name2 = String(key2.value);
            break;
          default:
            return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name2 === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key2.start;
                }
              } else {
                this.raiseRecoverable(key2.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name2 = "$" + name2;
        var other = propHash[name2];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key2.start, "Redefinition of property");
          }
        } else {
          other = propHash[name2] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$4.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types.comma)) {
            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      pp$4.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types.parenL || this.type === types.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === types.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$4.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      pp$4.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$4.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types._in)) {
          if (prec > minPrec) {
            var logical = this.type === types.logicalOR || this.type === types.logicalAND;
            var coalesce = this.type === types.coalesce;
            if (coalesce) {
              prec = types.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types.coalesce || coalesce && (this.type === types.logicalOR || this.type === types.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$4.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$4.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update = this.type === types.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true, update, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node.argument);
          } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
          } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isPrivateFieldAccess(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
      }
      pp$4.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$4.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
        var optionalChained = false;
        while (true) {
          var element = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element.optional) {
            optionalChained = true;
          }
          if (element === base2 || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element;
              element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base2 = element;
        }
      };
      pp$4.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types.bracketL);
        if (computed || optional && this.type !== types.parenL && this.type !== types.backQuote || this.eat(types.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base2;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(types.bracketR);
          } else if (this.type === types.privateId && base2.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base2 = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base2;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base2 = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base2;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base2 = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base2;
      };
      pp$4.parseExprAtom = function(refDestructuringErrors, forInit) {
        if (this.type === types.slash) {
          this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node = this.startNode();
            this.next();
            if (this.type === types.parenL && !this.allowDirectSuper) {
              this.raise(node.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {
              this.unexpected();
            }
            return this.finishNode(node, "Super");
          case types._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case types.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) {
              this.overrideContext(types$1.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
              }
              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
              }
            }
            return id;
          case types.regexp:
            var value = this.value;
            node = this.parseLiteral(value.value);
            node.regex = { pattern: value.pattern, flags: value.flags };
            return node;
          case types.num:
          case types.string:
            return this.parseLiteral(this.value);
          case types._null:
          case types._true:
          case types._false:
            node = this.startNode();
            node.value = this.type === types._null ? null : this.type === types._true;
            node.raw = this.type.keyword;
            this.next();
            return this.finishNode(node, "Literal");
          case types.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start;
              }
            }
            return expr;
          case types.bracketL:
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node, "ArrayExpression");
          case types.braceL:
            this.overrideContext(types$1.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, 0);
          case types._class:
            return this.parseClass(this.startNode(), false);
          case types._new:
            return this.parseNew();
          case types.backQuote:
            return this.parseTemplate();
          case types._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport();
            } else {
              return this.unexpected();
            }
          default:
            this.unexpected();
        }
      };
      pp$4.parseExprImport = function() {
        var node = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        var meta = this.parseIdent(true);
        switch (this.type) {
          case types.parenL:
            return this.parseDynamicImport(node);
          case types.dot:
            node.meta = meta;
            return this.parseImportMeta(node);
          default:
            this.unexpected();
        }
      };
      pp$4.parseDynamicImport = function(node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (!this.eat(types.parenR)) {
          var errorPos = this.start;
          if (this.eat(types.comma) && this.eat(types.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node, "ImportExpression");
      };
      pp$4.parseImportMeta = function(node) {
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
      };
      pp$4.parseLiteral = function(value) {
        var node = this.startNode();
        node.value = value;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      };
      pp$4.parseParenExpression = function() {
        this.expect(types.parenL);
        var val = this.parseExpression();
        this.expect(types.parenR);
        return val;
      };
      pp$4.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types.parenR) {
            first ? first = false : this.expect(types.comma);
            if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types.parenR);
          if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$4.parseParenItem = function(item) {
        return item;
      };
      pp$4.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, forInit);
      };
      var empty$1 = [];
      pp$4.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
          node.meta = meta;
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
        node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
        if (isImport && node.callee.type === "ImportExpression") {
          this.raise(startPos, "Cannot use new with import()");
        }
        if (this.eat(types.parenL)) {
          node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = empty$1;
        }
        return this.finishNode(node, "NewExpression");
      };
      pp$4.parseTemplateElement = function(ref2) {
        var isTagged = ref2.isTagged;
        var elem = this.startNode();
        if (this.type === types.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value,
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$4.parseTemplate = function(ref2) {
        if (ref2 === void 0)
          ref2 = {};
        var isTagged = ref2.isTagged;
        if (isTagged === void 0)
          isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };
      pp$4.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$4.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types.braceR)) {
          if (!first) {
            this.expect(types.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$4.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          if (this.type === types.parenL && refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0) {
              refDestructuringErrors.parenthesizedAssign = this.start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = this.start;
            }
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
          this.parsePropertyName(prop, refDestructuringErrors);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$4.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types.colon) {
          this.unexpected();
        }
        if (this.eat(types.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.kind = "init";
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          prop.kind = prop.key.name;
          this.parsePropertyName(prop);
          prop.value = this.parseMethod(false);
          var paramCount = prop.kind === "get" ? 0 : 1;
          if (prop.value.params.length !== paramCount) {
            var start = prop.value.start;
            if (prop.kind === "get") {
              this.raiseRecoverable(start, "getter should have no params");
            } else {
              this.raiseRecoverable(start, "setter should have exactly one param");
            }
          } else {
            if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
              this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
            }
          }
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          prop.kind = "init";
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$4.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$4.initFunction = function(node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      pp$4.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types.parenL);
        node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
      };
      pp$4.parseArrowExpression = function(node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      pp$4.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node.body = this.parseMaybeAssign(forInit);
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          if (this.strict && node.id) {
            this.checkLValSimple(node.id, BIND_OUTSIDE);
          }
          node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$4.isSimpleParamList = function(params) {
        for (var i = 0, list3 = params; i < list3.length; i += 1) {
          var param = list3[i];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$4.checkParams = function(node, allowDuplicates) {
        var nameHash = Object.create(null);
        for (var i = 0, list3 = node.params; i < list3.length; i += 1) {
          var param = list3[i];
          this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };
      pp$4.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types.comma) {
            elt = null;
          } else if (this.type === types.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$4.checkUnreserved = function(ref2) {
        var start = ref2.start;
        var end = ref2.end;
        var name2 = ref2.name;
        if (this.inGenerator && name2 === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name2 === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
          this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
          this.raise(start, "Cannot use " + name2 + " in class static initialization block");
        }
        if (this.keywords.test(name2)) {
          this.raise(start, "Unexpected keyword '" + name2 + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name2)) {
          if (!this.inAsync && name2 === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name2 + "' is reserved");
        }
      };
      pp$4.parseIdent = function(liberal, isBinding) {
        var node = this.startNode();
        if (this.type === types.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;
          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
        } else {
          this.unexpected();
        }
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node.start;
          }
        }
        return node;
      };
      pp$4.parsePrivateIdent = function() {
        var node = this.startNode();
        if (this.type === types.privateId) {
          node.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        if (this.privateNameStack.length === 0) {
          this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
        } else {
          this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
        }
        return node;
      };
      pp$4.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types.star);
          node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
      };
      pp$4.parseAwait = function(forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
      };
      var pp$5 = Parser.prototype;
      pp$5.raise = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$5.raiseRecoverable = pp$5.raise;
      pp$5.curPosition = function() {
        if (this.options.locations) {
          return new Position(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$6 = Parser.prototype;
      var Scope = function Scope2(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
        this.inClassFieldInit = false;
      };
      pp$6.enterScope = function(flags) {
        this.scopeStack.push(new Scope(flags));
      };
      pp$6.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$6.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
      };
      pp$6.declareName = function(name2, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
          scope.lexical.push(name2);
          if (this.inModule && scope.flags & SCOPE_TOP) {
            delete this.undefinedExports[name2];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name2);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name2) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
          }
          scope$2.functions.push(name2);
        } else {
          for (var i = this.scopeStack.length - 1; i >= 0; --i) {
            var scope$3 = this.scopeStack[i];
            if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name2);
            if (this.inModule && scope$3.flags & SCOPE_TOP) {
              delete this.undefinedExports[name2];
            }
            if (scope$3.flags & SCOPE_VAR) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
        }
      };
      pp$6.checkLocalExport = function(id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$6.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$6.currentVarScope = function() {
        for (var i = this.scopeStack.length - 1; ; i--) {
          var scope = this.scopeStack[i];
          if (scope.flags & SCOPE_VAR) {
            return scope;
          }
        }
      };
      pp$6.currentThisScope = function() {
        for (var i = this.scopeStack.length - 1; ; i--) {
          var scope = this.scopeStack[i];
          if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
            return scope;
          }
        }
      };
      var Node = function Node2(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [pos, 0];
        }
      };
      var pp$7 = Parser.prototype;
      pp$7.startNode = function() {
        return new Node(this, this.start, this.startLoc);
      };
      pp$7.startNodeAt = function(pos, loc) {
        return new Node(this, pos, loc);
      };
      function finishNodeAt(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations) {
          node.loc.end = loc;
        }
        if (this.options.ranges) {
          node.range[1] = pos;
        }
        return node;
      }
      pp$7.finishNode = function(node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$7.finishNodeAt = function(node, type, pos, loc) {
        return finishNodeAt.call(this, node, type, pos, loc);
      };
      pp$7.copyNode = function(node) {
        var newNode = new Node(this, node.start, this.startLoc);
        for (var prop in node) {
          newNode[prop] = node[prop];
        }
        return newNode;
      };
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties
      };
      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues
      };
      var data = {};
      function buildUnicodeData(ecmaVersion) {
        var d = data[ecmaVersion] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      buildUnicodeData(9);
      buildUnicodeData(10);
      buildUnicodeData(11);
      buildUnicodeData(12);
      var pp$8 = Parser.prototype;
      var RegExpValidationState = function RegExpValidationState2(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 12 ? 12 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = [];
        this.backReferenceNames = [];
      };
      RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
      };
      RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState.prototype.at = function at(i, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) {
          return -1;
        }
        var c = s.charCodeAt(i);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) {
          return l;
        }
        var c = s.charCodeAt(i), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
          return i + 1;
        }
        return i + 2;
      };
      RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0)
          forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0)
          forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      function codePointToString(ch) {
        if (ch <= 65535) {
          return String.fromCharCode(ch);
        }
        ch -= 65536;
        return String.fromCharCode((ch >> 10) + 55296, (ch & 1023) + 56320);
      }
      pp$8.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        for (var i = 0; i < flags.length; i++) {
          var flag = flags.charAt(i);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
        }
      };
      pp$8.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$8.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames.length = 0;
        state.backReferenceNames.length = 0;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(41)) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(93) || state.eat(125)) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i = 0, list3 = state.backReferenceNames; i < list3.length; i += 1) {
          var name2 = list3[i];
          if (state.groupNames.indexOf(name2) === -1) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$8.regexp_disjunction = function(state) {
        this.regexp_alternative(state);
        while (state.eat(124)) {
          this.regexp_alternative(state);
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(123)) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$8.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$8.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$8.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(94) || state.eat(36)) {
          return true;
        }
        if (state.eat(92)) {
          if (state.eat(66) || state.eat(98)) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(40) && state.eat(63)) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(60);
          }
          if (state.eat(61) || state.eat(33)) {
            this.regexp_disjunction(state);
            if (!state.eat(41)) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$8.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0)
          noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(63);
          return true;
        }
        return false;
      };
      pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$8.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(123)) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(125)) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(40)) {
          if (state.eat(63) && state.eat(58)) {
            this.regexp_disjunction(state);
            if (state.eat(41)) {
              return true;
            }
            state.raise("Unterminated group");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatCapturingGroup = function(state) {
        if (state.eat(40)) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$8.regexp_eatExtendedAtom = function(state) {
        return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$8.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$8.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$8.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_groupSpecifier = function(state) {
        if (state.eat(63)) {
          if (this.regexp_eatGroupName(state)) {
            if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
              state.raise("Duplicate capture group name");
            }
            state.groupNames.push(state.lastStringValue);
            return;
          }
          state.raise("Invalid group");
        }
      };
      pp$8.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(60)) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$8.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$8.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$8.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$8.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$8.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n = state.lastIntValue;
          if (state.switchU) {
            if (n > state.maxBackReference) {
              state.maxBackReference = n;
            }
            return true;
          }
          if (n <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatKGroupName = function(state) {
        if (state.eat(107)) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$8.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$8.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(99)) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatZero = function(state) {
        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0)
          forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(117)) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$8.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(47)) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      pp$8.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return true;
        }
        if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
            return true;
          }
          state.raise("Invalid property name");
        }
        return false;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
          var name2 = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name2, value);
            return true;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
          return true;
        }
        return false;
      };
      pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value) {
        if (!has(state.unicodeProperties.nonBinary, name2)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name2].test(value)) {
          state.raise("Invalid property value");
        }
      };
      pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (!state.unicodeProperties.binary.test(nameOrValue)) {
          state.raise("Invalid property name");
        }
      };
      pp$8.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$8.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$8.regexp_eatCharacterClass = function(state) {
        if (state.eat(91)) {
          state.eat(94);
          this.regexp_classRanges(state);
          if (state.eat(93)) {
            return true;
          }
          state.raise("Unterminated character class");
        }
        return false;
      };
      pp$8.regexp_classRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(45) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$8.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(92)) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(98)) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(45)) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(99)) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$8.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$8.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(120)) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$8.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$8.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$8.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$8.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i = 0; i < length; ++i) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true;
      };
      var Token = function Token2(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [p.start, p.end];
        }
      };
      var pp$9 = Parser.prototype;
      pp$9.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp$9.getToken = function() {
        this.next();
        return new Token(this);
      };
      if (typeof Symbol !== "undefined") {
        pp$9[Symbol.iterator] = function() {
          var this$1 = this;
          return {
            next: function() {
              var token = this$1.getToken();
              return {
                done: token.type === types.eof,
                value: token
              };
            }
          };
        };
      }
      pp$9.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp$9.readToken = function(code2) {
        if (isIdentifierStart(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code2);
      };
      pp$9.fullCharCodeAtPos = function() {
        var code2 = this.input.charCodeAt(this.pos);
        if (code2 <= 55295 || code2 >= 56320) {
          return code2;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code2 : (code2 << 10) + next - 56613888;
      };
      pp$9.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          lineBreakG.lastIndex = start;
          var match;
          while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
            ++this.curLine;
            this.lineStart = match.index + match[0].length;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp$9.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
        }
      };
      pp$9.skipSpace = function() {
        loop:
          while (this.pos < this.input.length) {
            var ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 32:
              case 160:
                ++this.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.pos + 1) === 10) {
                  ++this.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.pos;
                if (this.options.locations) {
                  ++this.curLine;
                  this.lineStart = this.pos;
                }
                break;
              case 47:
                switch (this.input.charCodeAt(this.pos + 1)) {
                  case 42:
                    this.skipBlockComment();
                    break;
                  case 47:
                    this.skipLineComment(2);
                    break;
                  default:
                    break loop;
                }
                break;
              default:
                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                  ++this.pos;
                } else {
                  break loop;
                }
            }
          }
      };
      pp$9.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp$9.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types.dot);
        }
      };
      pp$9.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        }
        return this.finishOp(types.slash, 1);
      };
      pp$9.readToken_mult_modulo_exp = function(code2) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code2 === 42 ? types.star : types.modulo;
        if (this.options.ecmaVersion >= 7 && code2 === 42 && next === 42) {
          ++size;
          tokentype = types.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp$9.readToken_pipe_amp = function(code2) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code2) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types.assign, 3);
            }
          }
          return this.finishOp(code2 === 124 ? types.logicalOR : types.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        }
        return this.finishOp(code2 === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
      };
      pp$9.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        }
        return this.finishOp(types.bitwiseXOR, 1);
      };
      pp$9.readToken_plus_min = function(code2) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code2) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        }
        return this.finishOp(types.plusMin, 1);
      };
      pp$9.readToken_lt_gt = function(code2) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code2) {
          size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types.assign, size + 1);
          }
          return this.finishOp(types.bitShift, size);
        }
        if (next === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types.relational, size);
      };
      pp$9.readToken_eq_excl = function(code2) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code2 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types.arrow);
        }
        return this.finishOp(code2 === 61 ? types.eq : types.prefix, 1);
      };
      pp$9.readToken_question = function() {
        var ecmaVersion = this.options.ecmaVersion;
        if (ecmaVersion >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types.assign, 3);
              }
            }
            return this.finishOp(types.coalesce, 2);
          }
        }
        return this.finishOp(types.question, 1);
      };
      pp$9.readToken_numberSign = function() {
        var ecmaVersion = this.options.ecmaVersion;
        var code2 = 35;
        if (ecmaVersion >= 13) {
          ++this.pos;
          code2 = this.fullCharCodeAtPos();
          if (isIdentifierStart(code2, true) || code2 === 92) {
            return this.finishToken(types.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString$1(code2) + "'");
      };
      pp$9.getTokenFromCode = function(code2) {
        switch (code2) {
          case 46:
            return this.readToken_dot();
          case 40:
            ++this.pos;
            return this.finishToken(types.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          case 34:
          case 39:
            return this.readString(code2);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code2);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code2);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code2);
          case 60:
          case 62:
            return this.readToken_lt_gt(code2);
          case 61:
          case 33:
            return this.readToken_eq_excl(code2);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString$1(code2) + "'");
      };
      pp$9.finishOp = function(type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };
      pp$9.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value = null;
        try {
          value = new RegExp(pattern, flags);
        } catch (e) {
        }
        return this.finishToken(types.regexp, { pattern, flags, value });
      };
      pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
          var code2 = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code2 === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code2;
            continue;
          }
          if (code2 >= 97) {
            val = code2 - 97 + 10;
          } else if (code2 >= 65) {
            val = code2 - 65 + 10;
          } else if (code2 >= 48 && code2 <= 57) {
            val = code2 - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code2;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp$9.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types.num, val);
      };
      pp$9.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types.num, val);
      };
      pp$9.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code2;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code2 > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code2 = this.readHexChar(4);
        }
        return code2;
      };
      function codePointToString$1(code2) {
        if (code2 <= 65535) {
          return String.fromCharCode(code2);
        }
        code2 -= 65536;
        return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
      }
      pp$9.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp$9.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp$9.invalidStringToken = function(position2, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
          this.raise(position2, message);
        }
      };
      pp$9.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp$9.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            case "`":
              return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos));
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp$9.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          case 114:
            return "\r";
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          case 117:
            return codePointToString$1(this.readCodePoint());
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(codePos, "Invalid escape sequence in template string");
              return null;
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine(ch)) {
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp$9.readHexChar = function(len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n;
      };
      pp$9.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString$1(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp$9.readWord = function() {
        var word = this.readWord1();
        var type = types.name;
        if (this.keywords.test(word)) {
          type = keywords$1[word];
        }
        return this.finishToken(type, word);
      };
      var version2 = "8.5.0";
      Parser.acorn = {
        Parser,
        version: version2,
        defaultOptions,
        Position,
        SourceLocation,
        getLineInfo,
        Node,
        TokenType,
        tokTypes: types,
        keywordTypes: keywords$1,
        TokContext,
        tokContexts: types$1,
        isIdentifierChar,
        isIdentifierStart,
        Token,
        isNewLine,
        lineBreak,
        lineBreakG,
        nonASCIIwhitespace
      };
      function parse3(input, options) {
        return Parser.parse(input, options);
      }
      function parseExpressionAt(input, pos, options) {
        return Parser.parseExpressionAt(input, pos, options);
      }
      function tokenizer(input, options) {
        return Parser.tokenizer(input, options);
      }
      exports2.Node = Node;
      exports2.Parser = Parser;
      exports2.Position = Position;
      exports2.SourceLocation = SourceLocation;
      exports2.TokContext = TokContext;
      exports2.Token = Token;
      exports2.TokenType = TokenType;
      exports2.defaultOptions = defaultOptions;
      exports2.getLineInfo = getLineInfo;
      exports2.isIdentifierChar = isIdentifierChar;
      exports2.isIdentifierStart = isIdentifierStart;
      exports2.isNewLine = isNewLine;
      exports2.keywordTypes = keywords$1;
      exports2.lineBreak = lineBreak;
      exports2.lineBreakG = lineBreakG;
      exports2.nonASCIIwhitespace = nonASCIIwhitespace;
      exports2.parse = parse3;
      exports2.parseExpressionAt = parseExpressionAt;
      exports2.tokContexts = types$1;
      exports2.tokTypes = types;
      exports2.tokenizer = tokenizer;
      exports2.version = version2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/$$virtual/acorn-jsx-virtual-72c18c2401/0/cache/acorn-jsx-npm-5.3.2-d7594599ea-41c748fd26.zip/node_modules/acorn-jsx/xhtml.js
var require_xhtml = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/$$virtual/acorn-jsx-virtual-72c18c2401/0/cache/acorn-jsx-npm-5.3.2-d7594599ea-41c748fd26.zip/node_modules/acorn-jsx/xhtml.js"(exports, module2) {
    module2.exports = {
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      "int": "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/$$virtual/acorn-jsx-virtual-72c18c2401/0/cache/acorn-jsx-npm-5.3.2-d7594599ea-41c748fd26.zip/node_modules/acorn-jsx/index.js
var require_acorn_jsx = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/$$virtual/acorn-jsx-virtual-72c18c2401/0/cache/acorn-jsx-npm-5.3.2-d7594599ea-41c748fd26.zip/node_modules/acorn-jsx/index.js"(exports, module2) {
    "use strict";
    var XHTMLEntities = require_xhtml();
    var hexNumber = /^[\da-fA-F]+$/;
    var decimalNumber = /^\d+$/;
    var acornJsxMap = new WeakMap();
    function getJsxTokens(acorn) {
      acorn = acorn.Parser.acorn || acorn;
      let acornJsx = acornJsxMap.get(acorn);
      if (!acornJsx) {
        const tt = acorn.tokTypes;
        const TokContext = acorn.TokContext;
        const TokenType = acorn.TokenType;
        const tc_oTag = new TokContext("<tag", false);
        const tc_cTag = new TokContext("</tag", false);
        const tc_expr = new TokContext("<tag>...</tag>", true, true);
        const tokContexts = {
          tc_oTag,
          tc_cTag,
          tc_expr
        };
        const tokTypes = {
          jsxName: new TokenType("jsxName"),
          jsxText: new TokenType("jsxText", { beforeExpr: true }),
          jsxTagStart: new TokenType("jsxTagStart", { startsExpr: true }),
          jsxTagEnd: new TokenType("jsxTagEnd")
        };
        tokTypes.jsxTagStart.updateContext = function() {
          this.context.push(tc_expr);
          this.context.push(tc_oTag);
          this.exprAllowed = false;
        };
        tokTypes.jsxTagEnd.updateContext = function(prevType) {
          let out = this.context.pop();
          if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {
            this.context.pop();
            this.exprAllowed = this.curContext() === tc_expr;
          } else {
            this.exprAllowed = true;
          }
        };
        acornJsx = { tokContexts, tokTypes };
        acornJsxMap.set(acorn, acornJsx);
      }
      return acornJsx;
    }
    function getQualifiedJSXName(object2) {
      if (!object2)
        return object2;
      if (object2.type === "JSXIdentifier")
        return object2.name;
      if (object2.type === "JSXNamespacedName")
        return object2.namespace.name + ":" + object2.name.name;
      if (object2.type === "JSXMemberExpression")
        return getQualifiedJSXName(object2.object) + "." + getQualifiedJSXName(object2.property);
    }
    module2.exports = function(options) {
      options = options || {};
      return function(Parser) {
        return plugin({
          allowNamespaces: options.allowNamespaces !== false,
          allowNamespacedObjects: !!options.allowNamespacedObjects
        }, Parser);
      };
    };
    Object.defineProperty(module2.exports, "tokTypes", {
      get: function get_tokTypes() {
        return getJsxTokens(require_acorn()).tokTypes;
      },
      configurable: true,
      enumerable: true
    });
    function plugin(options, Parser) {
      const acorn = Parser.acorn || require_acorn();
      const acornJsx = getJsxTokens(acorn);
      const tt = acorn.tokTypes;
      const tok = acornJsx.tokTypes;
      const tokContexts = acorn.tokContexts;
      const tc_oTag = acornJsx.tokContexts.tc_oTag;
      const tc_cTag = acornJsx.tokContexts.tc_cTag;
      const tc_expr = acornJsx.tokContexts.tc_expr;
      const isNewLine = acorn.isNewLine;
      const isIdentifierStart = acorn.isIdentifierStart;
      const isIdentifierChar = acorn.isIdentifierChar;
      return class extends Parser {
        static get acornJsx() {
          return acornJsx;
        }
        jsx_readToken() {
          let out = "", chunkStart = this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length)
              this.raise(this.start, "Unterminated JSX contents");
            let ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 60:
              case 123:
                if (this.pos === this.start) {
                  if (ch === 60 && this.exprAllowed) {
                    ++this.pos;
                    return this.finishToken(tok.jsxTagStart);
                  }
                  return this.getTokenFromCode(ch);
                }
                out += this.input.slice(chunkStart, this.pos);
                return this.finishToken(tok.jsxText, out);
              case 38:
                out += this.input.slice(chunkStart, this.pos);
                out += this.jsx_readEntity();
                chunkStart = this.pos;
                break;
              case 62:
              case 125:
                this.raise(this.pos, "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?');
              default:
                if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.pos);
                  out += this.jsx_readNewLine(true);
                  chunkStart = this.pos;
                } else {
                  ++this.pos;
                }
            }
          }
        }
        jsx_readNewLine(normalizeCRLF) {
          let ch = this.input.charCodeAt(this.pos);
          let out;
          ++this.pos;
          if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          return out;
        }
        jsx_readString(quote) {
          let out = "", chunkStart = ++this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length)
              this.raise(this.start, "Unterminated string constant");
            let ch = this.input.charCodeAt(this.pos);
            if (ch === quote)
              break;
            if (ch === 38) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readEntity();
              chunkStart = this.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readNewLine(false);
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
          }
          out += this.input.slice(chunkStart, this.pos++);
          return this.finishToken(tt.string, out);
        }
        jsx_readEntity() {
          let str = "", count = 0, entity;
          let ch = this.input[this.pos];
          if (ch !== "&")
            this.raise(this.pos, "Entity must start with an ampersand");
          let startPos = ++this.pos;
          while (this.pos < this.input.length && count++ < 10) {
            ch = this.input[this.pos++];
            if (ch === ";") {
              if (str[0] === "#") {
                if (str[1] === "x") {
                  str = str.substr(2);
                  if (hexNumber.test(str))
                    entity = String.fromCharCode(parseInt(str, 16));
                } else {
                  str = str.substr(1);
                  if (decimalNumber.test(str))
                    entity = String.fromCharCode(parseInt(str, 10));
                }
              } else {
                entity = XHTMLEntities[str];
              }
              break;
            }
            str += ch;
          }
          if (!entity) {
            this.pos = startPos;
            return "&";
          }
          return entity;
        }
        jsx_readWord() {
          let ch, start = this.pos;
          do {
            ch = this.input.charCodeAt(++this.pos);
          } while (isIdentifierChar(ch) || ch === 45);
          return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));
        }
        jsx_parseIdentifier() {
          let node = this.startNode();
          if (this.type === tok.jsxName)
            node.name = this.value;
          else if (this.type.keyword)
            node.name = this.type.keyword;
          else
            this.unexpected();
          this.next();
          return this.finishNode(node, "JSXIdentifier");
        }
        jsx_parseNamespacedName() {
          let startPos = this.start, startLoc = this.startLoc;
          let name2 = this.jsx_parseIdentifier();
          if (!options.allowNamespaces || !this.eat(tt.colon))
            return name2;
          var node = this.startNodeAt(startPos, startLoc);
          node.namespace = name2;
          node.name = this.jsx_parseIdentifier();
          return this.finishNode(node, "JSXNamespacedName");
        }
        jsx_parseElementName() {
          if (this.type === tok.jsxTagEnd)
            return "";
          let startPos = this.start, startLoc = this.startLoc;
          let node = this.jsx_parseNamespacedName();
          if (this.type === tt.dot && node.type === "JSXNamespacedName" && !options.allowNamespacedObjects) {
            this.unexpected();
          }
          while (this.eat(tt.dot)) {
            let newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node;
            newNode.property = this.jsx_parseIdentifier();
            node = this.finishNode(newNode, "JSXMemberExpression");
          }
          return node;
        }
        jsx_parseAttributeValue() {
          switch (this.type) {
            case tt.braceL:
              let node = this.jsx_parseExpressionContainer();
              if (node.expression.type === "JSXEmptyExpression")
                this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
              return node;
            case tok.jsxTagStart:
            case tt.string:
              return this.parseExprAtom();
            default:
              this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
          }
        }
        jsx_parseEmptyExpression() {
          let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
          return this.finishNodeAt(node, "JSXEmptyExpression", this.start, this.startLoc);
        }
        jsx_parseExpressionContainer() {
          let node = this.startNode();
          this.next();
          node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
          this.expect(tt.braceR);
          return this.finishNode(node, "JSXExpressionContainer");
        }
        jsx_parseAttribute() {
          let node = this.startNode();
          if (this.eat(tt.braceL)) {
            this.expect(tt.ellipsis);
            node.argument = this.parseMaybeAssign();
            this.expect(tt.braceR);
            return this.finishNode(node, "JSXSpreadAttribute");
          }
          node.name = this.jsx_parseNamespacedName();
          node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
          return this.finishNode(node, "JSXAttribute");
        }
        jsx_parseOpeningElementAt(startPos, startLoc) {
          let node = this.startNodeAt(startPos, startLoc);
          node.attributes = [];
          let nodeName = this.jsx_parseElementName();
          if (nodeName)
            node.name = nodeName;
          while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)
            node.attributes.push(this.jsx_parseAttribute());
          node.selfClosing = this.eat(tt.slash);
          this.expect(tok.jsxTagEnd);
          return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
        }
        jsx_parseClosingElementAt(startPos, startLoc) {
          let node = this.startNodeAt(startPos, startLoc);
          let nodeName = this.jsx_parseElementName();
          if (nodeName)
            node.name = nodeName;
          this.expect(tok.jsxTagEnd);
          return this.finishNode(node, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
        }
        jsx_parseElementAt(startPos, startLoc) {
          let node = this.startNodeAt(startPos, startLoc);
          let children = [];
          let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
          let closingElement = null;
          if (!openingElement.selfClosing) {
            contents:
              for (; ; ) {
                switch (this.type) {
                  case tok.jsxTagStart:
                    startPos = this.start;
                    startLoc = this.startLoc;
                    this.next();
                    if (this.eat(tt.slash)) {
                      closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                      break contents;
                    }
                    children.push(this.jsx_parseElementAt(startPos, startLoc));
                    break;
                  case tok.jsxText:
                    children.push(this.parseExprAtom());
                    break;
                  case tt.braceL:
                    children.push(this.jsx_parseExpressionContainer());
                    break;
                  default:
                    this.unexpected();
                }
              }
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
            }
          }
          let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
          node["opening" + fragmentOrElement] = openingElement;
          node["closing" + fragmentOrElement] = closingElement;
          node.children = children;
          if (this.type === tt.relational && this.value === "<") {
            this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
          }
          return this.finishNode(node, "JSX" + fragmentOrElement);
        }
        jsx_parseText() {
          let node = this.parseLiteral(this.value);
          node.type = "JSXText";
          return node;
        }
        jsx_parseElement() {
          let startPos = this.start, startLoc = this.startLoc;
          this.next();
          return this.jsx_parseElementAt(startPos, startLoc);
        }
        parseExprAtom(refShortHandDefaultPos) {
          if (this.type === tok.jsxText)
            return this.jsx_parseText();
          else if (this.type === tok.jsxTagStart)
            return this.jsx_parseElement();
          else
            return super.parseExprAtom(refShortHandDefaultPos);
        }
        readToken(code2) {
          let context = this.curContext();
          if (context === tc_expr)
            return this.jsx_readToken();
          if (context === tc_oTag || context === tc_cTag) {
            if (isIdentifierStart(code2))
              return this.jsx_readWord();
            if (code2 == 62) {
              ++this.pos;
              return this.finishToken(tok.jsxTagEnd);
            }
            if ((code2 === 34 || code2 === 39) && context == tc_oTag)
              return this.jsx_readString(code2);
          }
          if (code2 === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
            ++this.pos;
            return this.finishToken(tok.jsxTagStart);
          }
          return super.readToken(code2);
        }
        updateContext(prevType) {
          if (this.type == tt.braceL) {
            var curContext = this.curContext();
            if (curContext == tc_oTag)
              this.context.push(tokContexts.b_expr);
            else if (curContext == tc_expr)
              this.context.push(tokContexts.b_tmpl);
            else
              super.updateContext(prevType);
            this.exprAllowed = true;
          } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {
            this.context.length -= 2;
            this.context.push(tc_cTag);
            this.exprAllowed = false;
          } else {
            return super.updateContext(prevType);
          }
        }
      };
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/tokenize/partial-blank-line.js
var require_partial_blank_line = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-2.11.4-f7ec94840a-343bfde8ac.zip/node_modules/micromark/dist/tokenize/partial-blank-line.js"(exports, module2) {
    "use strict";
    var markdownLineEnding2 = require_markdown_line_ending();
    var factorySpace2 = require_factory_space();
    var partialBlankLine = {
      tokenize: tokenizePartialBlankLine,
      partial: true
    };
    function tokenizePartialBlankLine(effects, ok2, nok) {
      return factorySpace2(effects, afterWhitespace, "linePrefix");
      function afterWhitespace(code2) {
        return code2 === null || markdownLineEnding2(code2) ? ok2(code2) : nok(code2);
      }
    }
    module2.exports = partialBlankLine;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdxjs-esm-npm-0.3.1-0ac8d5f686-86515d1c87.zip/node_modules/micromark-extension-mdxjs-esm/index.js
var require_micromark_extension_mdxjs_esm = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdxjs-esm-npm-0.3.1-0ac8d5f686-86515d1c87.zip/node_modules/micromark-extension-mdxjs-esm/index.js"(exports, module2) {
    "use strict";
    module2.exports = mdxjs;
    var markdownLineEnding2 = require_markdown_line_ending();
    var unicodeWhitespace2 = require_unicode_whitespace();
    var blank = require_partial_blank_line();
    var eventsToAcorn = require_util_events_to_acorn();
    var VMessage = require_vfile_message();
    var nextBlankConstruct2 = { tokenize: tokenizeNextBlank2, partial: true };
    var allowedAcornTypes = [
      "ExportAllDeclaration",
      "ExportDefaultDeclaration",
      "ExportNamedDeclaration",
      "ImportDeclaration"
    ];
    function mdxjs(options) {
      var exportImportConstruct = { tokenize: tokenizeExportImport, concrete: true };
      var acornOptions;
      var acorn;
      if (!options || !options.acorn || !options.acorn.parse) {
        throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
      }
      acorn = options.acorn;
      acornOptions = Object.assign({ ecmaVersion: 2020, sourceType: "module" }, options.acornOptions || {});
      return { flow: { 101: exportImportConstruct, 105: exportImportConstruct } };
      function tokenizeExportImport(effects, ok2, nok) {
        var self2 = this;
        var definedModuleSpecifiers = self2.parser.definedModuleSpecifiers || (self2.parser.definedModuleSpecifiers = []);
        var eventStart = this.events.length + 1;
        var index2 = 0;
        var buffer2;
        return self2.interrupt ? nok : start;
        function start(code2) {
          if (code2 === 101) {
            buffer2 = "export";
          } else if (code2 === 105) {
            buffer2 = "import";
          } else {
            throw new Error("Expected `e` or `i`");
          }
          if (self2.now().column !== 1)
            return nok(code2);
          effects.enter("mdxjsEsm");
          effects.enter("mdxjsEsmData");
          return keyword(code2);
        }
        function keyword(code2) {
          if (code2 === buffer2.charCodeAt(index2++)) {
            effects.consume(code2);
            return index2 === buffer2.length ? after : keyword;
          }
          return nok(code2);
        }
        function after(code2) {
          if (unicodeWhitespace2(code2)) {
            effects.consume(code2);
            return rest;
          }
          return nok(code2);
        }
        function rest(code2) {
          if (code2 === null) {
            return atEnd(code2);
          }
          if (markdownLineEnding2(code2)) {
            return effects.check(nextBlankConstruct2, atEnd, atEol)(code2);
          }
          effects.consume(code2);
          return rest;
        }
        function atEol(code2) {
          effects.exit("mdxjsEsmData");
          return lineStart(code2);
        }
        function lineStart(code2) {
          if (markdownLineEnding2(code2)) {
            effects.enter("lineEnding");
            effects.consume(code2);
            effects.exit("lineEnding");
            return lineStart;
          }
          effects.enter("mdxjsEsmData");
          return rest(code2);
        }
        function atEnd(code2) {
          var result;
          var index3;
          var offset;
          var token;
          effects.exit("mdxjsEsmData");
          result = eventsToAcorn(acorn, acornOptions, self2.events.slice(eventStart), {
            prefix: definedModuleSpecifiers.length ? "var " + definedModuleSpecifiers.join(",") + "\n" : ""
          });
          if (code2 !== null && result.swallow) {
            return lineStart(code2);
          }
          if (result.error) {
            throw new VMessage("Could not parse import/exports with acorn: " + String(result.error), {
              line: result.error.loc.line,
              column: result.error.loc.column + 1,
              offset: result.error.pos
            }, "micromark-extension-mdxjs-esm:acorn");
          }
          index3 = -1;
          if (definedModuleSpecifiers.length) {
            result.estree.body.shift();
          }
          while (++index3 < result.estree.body.length) {
            token = result.estree.body[index3];
            if (allowedAcornTypes.indexOf(token.type) < 0) {
              throw new VMessage("Unexpected `" + token.type + "` in code: only import/exports are supported", {
                start: {
                  line: token.loc.start.line,
                  column: token.loc.start.column + 1,
                  offset: token.start
                },
                end: {
                  line: token.loc.end.line,
                  column: token.loc.end.column + 1,
                  offset: token.end
                }
              }, "micromark-extension-mdxjs-esm:non-esm");
            } else if (token.type === "ImportDeclaration" && !self2.interrupt) {
              offset = -1;
              while (++offset < token.specifiers.length) {
                definedModuleSpecifiers.push(token.specifiers[offset].local.name);
              }
            }
          }
          token = effects.exit("mdxjsEsm");
          if (options.addResult)
            token.estree = result.estree;
          return ok2(code2);
        }
      }
    }
    function tokenizeNextBlank2(effects, ok2, nok) {
      return start;
      function start(code2) {
        effects.exit("mdxjsEsmData");
        effects.enter("lineEndingBlank");
        effects.consume(code2);
        effects.exit("lineEndingBlank");
        return effects.attempt(blank, ok2, nok);
      }
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdxjs-npm-0.3.0-c6d1b2ce91-8797785450.zip/node_modules/micromark-extension-mdxjs/index.js
var require_micromark_extension_mdxjs = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-extension-mdxjs-npm-0.3.0-c6d1b2ce91-8797785450.zip/node_modules/micromark-extension-mdxjs/index.js"(exports, module2) {
    var acorn = require_acorn();
    var acornJsx = require_acorn_jsx();
    var combine = require_combine_extensions();
    var expression = require_micromark_extension_mdx_expression();
    var jsx = require_micromark_extension_mdx_jsx();
    var md = require_micromark_extension_mdx_md();
    var esm = require_micromark_extension_mdxjs_esm();
    module2.exports = create;
    function create(options) {
      var settings = Object.assign({
        acorn: acorn.Parser.extend(acornJsx()),
        acornOptions: { ecmaVersion: 2020, sourceType: "module" },
        addResult: true
      }, options);
      return combine([esm(settings), expression(settings), jsx(settings), md]);
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/min-indent-npm-1.0.1-77031f50e1-c3aeea46bc.zip/node_modules/min-indent/index.js
var require_min_indent = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/min-indent-npm-1.0.1-77031f50e1-c3aeea46bc.zip/node_modules/min-indent/index.js"(exports, module2) {
    "use strict";
    module2.exports = (string4) => {
      const match = string4.match(/^[ \t]*(?=\S)/gm);
      if (!match) {
        return 0;
      }
      return match.reduce((r, a) => Math.min(r, a.length), Infinity);
    };
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/strip-indent-npm-3.0.0-519e75a28d-4a7860e943.zip/node_modules/strip-indent/index.js
var require_strip_indent = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/strip-indent-npm-3.0.0-519e75a28d-4a7860e943.zip/node_modules/strip-indent/index.js"(exports, module2) {
    "use strict";
    var minIndent = require_min_indent();
    module2.exports = (string4) => {
      const indent2 = minIndent(string4);
      if (indent2 === 0) {
        return string4;
      }
      const regex = new RegExp(`^[ \\t]{${indent2}}`, "gm");
      return string4.replace(regex, "");
    };
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-expression-npm-0.1.1-6e8466fe5d-4684cc22b1.zip/node_modules/mdast-util-mdx-expression/from-markdown.js
var require_from_markdown = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-expression-npm-0.1.1-6e8466fe5d-4684cc22b1.zip/node_modules/mdast-util-mdx-expression/from-markdown.js"(exports) {
    exports.enter = {
      mdxFlowExpression: enterMdxFlowExpression,
      mdxTextExpression: enterMdxTextExpression
    };
    exports.exit = {
      mdxFlowExpression: exitMdxExpression,
      mdxFlowExpressionChunk: exitMdxExpressionData,
      mdxTextExpression: exitMdxExpression,
      mdxTextExpressionChunk: exitMdxExpressionData
    };
    var stripIndent = require_strip_indent();
    function enterMdxFlowExpression(token) {
      this.enter({ type: "mdxFlowExpression", value: "" }, token);
      this.buffer();
    }
    function enterMdxTextExpression(token) {
      this.enter({ type: "mdxTextExpression", value: "" }, token);
      this.buffer();
    }
    function exitMdxExpression(token) {
      var value = this.resume();
      var node = this.exit(token);
      node.value = token.type === "mdxFlowExpression" ? dedent(value) : value;
      if (token.estree) {
        node.data = { estree: token.estree };
      }
    }
    function exitMdxExpressionData(token) {
      this.config.enter.data.call(this, token);
      this.config.exit.data.call(this, token);
    }
    function dedent(value) {
      var firstLineEnding = /\r?\n|\r/.exec(value);
      var position2 = firstLineEnding ? firstLineEnding.index + firstLineEnding[0].length : -1;
      if (position2 > -1) {
        return value.slice(0, position2) + stripIndent(value.slice(position2));
      }
      return value;
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/character-entities-legacy-npm-1.1.4-e3e7c8ee55-bb1e426146.zip/node_modules/character-entities-legacy/index.json
var require_character_entities_legacy = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/character-entities-legacy-npm-1.1.4-e3e7c8ee55-bb1e426146.zip/node_modules/character-entities-legacy/index.json"(exports, module2) {
    module2.exports = {
      AElig: "\xC6",
      AMP: "&",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Agrave: "\xC0",
      Aring: "\xC5",
      Atilde: "\xC3",
      Auml: "\xC4",
      COPY: "\xA9",
      Ccedil: "\xC7",
      ETH: "\xD0",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Egrave: "\xC8",
      Euml: "\xCB",
      GT: ">",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Igrave: "\xCC",
      Iuml: "\xCF",
      LT: "<",
      Ntilde: "\xD1",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Ograve: "\xD2",
      Oslash: "\xD8",
      Otilde: "\xD5",
      Ouml: "\xD6",
      QUOT: '"',
      REG: "\xAE",
      THORN: "\xDE",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Ugrave: "\xD9",
      Uuml: "\xDC",
      Yacute: "\xDD",
      aacute: "\xE1",
      acirc: "\xE2",
      acute: "\xB4",
      aelig: "\xE6",
      agrave: "\xE0",
      amp: "&",
      aring: "\xE5",
      atilde: "\xE3",
      auml: "\xE4",
      brvbar: "\xA6",
      ccedil: "\xE7",
      cedil: "\xB8",
      cent: "\xA2",
      copy: "\xA9",
      curren: "\xA4",
      deg: "\xB0",
      divide: "\xF7",
      eacute: "\xE9",
      ecirc: "\xEA",
      egrave: "\xE8",
      eth: "\xF0",
      euml: "\xEB",
      frac12: "\xBD",
      frac14: "\xBC",
      frac34: "\xBE",
      gt: ">",
      iacute: "\xED",
      icirc: "\xEE",
      iexcl: "\xA1",
      igrave: "\xEC",
      iquest: "\xBF",
      iuml: "\xEF",
      laquo: "\xAB",
      lt: "<",
      macr: "\xAF",
      micro: "\xB5",
      middot: "\xB7",
      nbsp: "\xA0",
      not: "\xAC",
      ntilde: "\xF1",
      oacute: "\xF3",
      ocirc: "\xF4",
      ograve: "\xF2",
      ordf: "\xAA",
      ordm: "\xBA",
      oslash: "\xF8",
      otilde: "\xF5",
      ouml: "\xF6",
      para: "\xB6",
      plusmn: "\xB1",
      pound: "\xA3",
      quot: '"',
      raquo: "\xBB",
      reg: "\xAE",
      sect: "\xA7",
      shy: "\xAD",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      szlig: "\xDF",
      thorn: "\xFE",
      times: "\xD7",
      uacute: "\xFA",
      ucirc: "\xFB",
      ugrave: "\xF9",
      uml: "\xA8",
      uuml: "\xFC",
      yacute: "\xFD",
      yen: "\xA5",
      yuml: "\xFF"
    };
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/character-reference-invalid-npm-1.1.4-e5e17a1a38-82d8ce7828.zip/node_modules/character-reference-invalid/index.json
var require_character_reference_invalid = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/character-reference-invalid-npm-1.1.4-e5e17a1a38-82d8ce7828.zip/node_modules/character-reference-invalid/index.json"(exports, module2) {
    module2.exports = {
      "0": "\uFFFD",
      "128": "\u20AC",
      "130": "\u201A",
      "131": "\u0192",
      "132": "\u201E",
      "133": "\u2026",
      "134": "\u2020",
      "135": "\u2021",
      "136": "\u02C6",
      "137": "\u2030",
      "138": "\u0160",
      "139": "\u2039",
      "140": "\u0152",
      "142": "\u017D",
      "145": "\u2018",
      "146": "\u2019",
      "147": "\u201C",
      "148": "\u201D",
      "149": "\u2022",
      "150": "\u2013",
      "151": "\u2014",
      "152": "\u02DC",
      "153": "\u2122",
      "154": "\u0161",
      "155": "\u203A",
      "156": "\u0153",
      "158": "\u017E",
      "159": "\u0178"
    };
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/is-decimal-npm-1.0.4-e67dbd40dd-57a0e1a87f.zip/node_modules/is-decimal/index.js
var require_is_decimal = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/is-decimal-npm-1.0.4-e67dbd40dd-57a0e1a87f.zip/node_modules/is-decimal/index.js"(exports, module2) {
    "use strict";
    module2.exports = decimal;
    function decimal(character) {
      var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
      return code2 >= 48 && code2 <= 57;
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/is-hexadecimal-npm-1.0.4-b4091da09e-653c1d0115.zip/node_modules/is-hexadecimal/index.js
var require_is_hexadecimal = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/is-hexadecimal-npm-1.0.4-b4091da09e-653c1d0115.zip/node_modules/is-hexadecimal/index.js"(exports, module2) {
    "use strict";
    module2.exports = hexadecimal;
    function hexadecimal(character) {
      var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
      return code2 >= 97 && code2 <= 102 || code2 >= 65 && code2 <= 70 || code2 >= 48 && code2 <= 57;
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/is-alphabetical-npm-1.0.4-94e2e7f984-a4a2afcf65.zip/node_modules/is-alphabetical/index.js
var require_is_alphabetical = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/is-alphabetical-npm-1.0.4-94e2e7f984-a4a2afcf65.zip/node_modules/is-alphabetical/index.js"(exports, module2) {
    "use strict";
    module2.exports = alphabetical;
    function alphabetical(character) {
      var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
      return code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90;
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/is-alphanumerical-npm-1.0.4-c96dc6d674-d97ec38a74.zip/node_modules/is-alphanumerical/index.js
var require_is_alphanumerical = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/is-alphanumerical-npm-1.0.4-c96dc6d674-d97ec38a74.zip/node_modules/is-alphanumerical/index.js"(exports, module2) {
    "use strict";
    var alphabetical = require_is_alphabetical();
    var decimal = require_is_decimal();
    module2.exports = alphanumerical;
    function alphanumerical(character) {
      return alphabetical(character) || decimal(character);
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/character-entities-npm-1.2.4-a5c359383c-6ca8a790a2.zip/node_modules/character-entities/index.json
var require_character_entities = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/character-entities-npm-1.2.4-a5c359383c-6ca8a790a2.zip/node_modules/character-entities/index.json"(exports, module2) {
    module2.exports = {
      AEli: "\xC6",
      AElig: "\xC6",
      AM: "&",
      AMP: "&",
      Aacut: "\xC1",
      Aacute: "\xC1",
      Abreve: "\u0102",
      Acir: "\xC2",
      Acirc: "\xC2",
      Acy: "\u0410",
      Afr: "\u{1D504}",
      Agrav: "\xC0",
      Agrave: "\xC0",
      Alpha: "\u0391",
      Amacr: "\u0100",
      And: "\u2A53",
      Aogon: "\u0104",
      Aopf: "\u{1D538}",
      ApplyFunction: "\u2061",
      Arin: "\xC5",
      Aring: "\xC5",
      Ascr: "\u{1D49C}",
      Assign: "\u2254",
      Atild: "\xC3",
      Atilde: "\xC3",
      Aum: "\xC4",
      Auml: "\xC4",
      Backslash: "\u2216",
      Barv: "\u2AE7",
      Barwed: "\u2306",
      Bcy: "\u0411",
      Because: "\u2235",
      Bernoullis: "\u212C",
      Beta: "\u0392",
      Bfr: "\u{1D505}",
      Bopf: "\u{1D539}",
      Breve: "\u02D8",
      Bscr: "\u212C",
      Bumpeq: "\u224E",
      CHcy: "\u0427",
      COP: "\xA9",
      COPY: "\xA9",
      Cacute: "\u0106",
      Cap: "\u22D2",
      CapitalDifferentialD: "\u2145",
      Cayleys: "\u212D",
      Ccaron: "\u010C",
      Ccedi: "\xC7",
      Ccedil: "\xC7",
      Ccirc: "\u0108",
      Cconint: "\u2230",
      Cdot: "\u010A",
      Cedilla: "\xB8",
      CenterDot: "\xB7",
      Cfr: "\u212D",
      Chi: "\u03A7",
      CircleDot: "\u2299",
      CircleMinus: "\u2296",
      CirclePlus: "\u2295",
      CircleTimes: "\u2297",
      ClockwiseContourIntegral: "\u2232",
      CloseCurlyDoubleQuote: "\u201D",
      CloseCurlyQuote: "\u2019",
      Colon: "\u2237",
      Colone: "\u2A74",
      Congruent: "\u2261",
      Conint: "\u222F",
      ContourIntegral: "\u222E",
      Copf: "\u2102",
      Coproduct: "\u2210",
      CounterClockwiseContourIntegral: "\u2233",
      Cross: "\u2A2F",
      Cscr: "\u{1D49E}",
      Cup: "\u22D3",
      CupCap: "\u224D",
      DD: "\u2145",
      DDotrahd: "\u2911",
      DJcy: "\u0402",
      DScy: "\u0405",
      DZcy: "\u040F",
      Dagger: "\u2021",
      Darr: "\u21A1",
      Dashv: "\u2AE4",
      Dcaron: "\u010E",
      Dcy: "\u0414",
      Del: "\u2207",
      Delta: "\u0394",
      Dfr: "\u{1D507}",
      DiacriticalAcute: "\xB4",
      DiacriticalDot: "\u02D9",
      DiacriticalDoubleAcute: "\u02DD",
      DiacriticalGrave: "`",
      DiacriticalTilde: "\u02DC",
      Diamond: "\u22C4",
      DifferentialD: "\u2146",
      Dopf: "\u{1D53B}",
      Dot: "\xA8",
      DotDot: "\u20DC",
      DotEqual: "\u2250",
      DoubleContourIntegral: "\u222F",
      DoubleDot: "\xA8",
      DoubleDownArrow: "\u21D3",
      DoubleLeftArrow: "\u21D0",
      DoubleLeftRightArrow: "\u21D4",
      DoubleLeftTee: "\u2AE4",
      DoubleLongLeftArrow: "\u27F8",
      DoubleLongLeftRightArrow: "\u27FA",
      DoubleLongRightArrow: "\u27F9",
      DoubleRightArrow: "\u21D2",
      DoubleRightTee: "\u22A8",
      DoubleUpArrow: "\u21D1",
      DoubleUpDownArrow: "\u21D5",
      DoubleVerticalBar: "\u2225",
      DownArrow: "\u2193",
      DownArrowBar: "\u2913",
      DownArrowUpArrow: "\u21F5",
      DownBreve: "\u0311",
      DownLeftRightVector: "\u2950",
      DownLeftTeeVector: "\u295E",
      DownLeftVector: "\u21BD",
      DownLeftVectorBar: "\u2956",
      DownRightTeeVector: "\u295F",
      DownRightVector: "\u21C1",
      DownRightVectorBar: "\u2957",
      DownTee: "\u22A4",
      DownTeeArrow: "\u21A7",
      Downarrow: "\u21D3",
      Dscr: "\u{1D49F}",
      Dstrok: "\u0110",
      ENG: "\u014A",
      ET: "\xD0",
      ETH: "\xD0",
      Eacut: "\xC9",
      Eacute: "\xC9",
      Ecaron: "\u011A",
      Ecir: "\xCA",
      Ecirc: "\xCA",
      Ecy: "\u042D",
      Edot: "\u0116",
      Efr: "\u{1D508}",
      Egrav: "\xC8",
      Egrave: "\xC8",
      Element: "\u2208",
      Emacr: "\u0112",
      EmptySmallSquare: "\u25FB",
      EmptyVerySmallSquare: "\u25AB",
      Eogon: "\u0118",
      Eopf: "\u{1D53C}",
      Epsilon: "\u0395",
      Equal: "\u2A75",
      EqualTilde: "\u2242",
      Equilibrium: "\u21CC",
      Escr: "\u2130",
      Esim: "\u2A73",
      Eta: "\u0397",
      Eum: "\xCB",
      Euml: "\xCB",
      Exists: "\u2203",
      ExponentialE: "\u2147",
      Fcy: "\u0424",
      Ffr: "\u{1D509}",
      FilledSmallSquare: "\u25FC",
      FilledVerySmallSquare: "\u25AA",
      Fopf: "\u{1D53D}",
      ForAll: "\u2200",
      Fouriertrf: "\u2131",
      Fscr: "\u2131",
      GJcy: "\u0403",
      G: ">",
      GT: ">",
      Gamma: "\u0393",
      Gammad: "\u03DC",
      Gbreve: "\u011E",
      Gcedil: "\u0122",
      Gcirc: "\u011C",
      Gcy: "\u0413",
      Gdot: "\u0120",
      Gfr: "\u{1D50A}",
      Gg: "\u22D9",
      Gopf: "\u{1D53E}",
      GreaterEqual: "\u2265",
      GreaterEqualLess: "\u22DB",
      GreaterFullEqual: "\u2267",
      GreaterGreater: "\u2AA2",
      GreaterLess: "\u2277",
      GreaterSlantEqual: "\u2A7E",
      GreaterTilde: "\u2273",
      Gscr: "\u{1D4A2}",
      Gt: "\u226B",
      HARDcy: "\u042A",
      Hacek: "\u02C7",
      Hat: "^",
      Hcirc: "\u0124",
      Hfr: "\u210C",
      HilbertSpace: "\u210B",
      Hopf: "\u210D",
      HorizontalLine: "\u2500",
      Hscr: "\u210B",
      Hstrok: "\u0126",
      HumpDownHump: "\u224E",
      HumpEqual: "\u224F",
      IEcy: "\u0415",
      IJlig: "\u0132",
      IOcy: "\u0401",
      Iacut: "\xCD",
      Iacute: "\xCD",
      Icir: "\xCE",
      Icirc: "\xCE",
      Icy: "\u0418",
      Idot: "\u0130",
      Ifr: "\u2111",
      Igrav: "\xCC",
      Igrave: "\xCC",
      Im: "\u2111",
      Imacr: "\u012A",
      ImaginaryI: "\u2148",
      Implies: "\u21D2",
      Int: "\u222C",
      Integral: "\u222B",
      Intersection: "\u22C2",
      InvisibleComma: "\u2063",
      InvisibleTimes: "\u2062",
      Iogon: "\u012E",
      Iopf: "\u{1D540}",
      Iota: "\u0399",
      Iscr: "\u2110",
      Itilde: "\u0128",
      Iukcy: "\u0406",
      Ium: "\xCF",
      Iuml: "\xCF",
      Jcirc: "\u0134",
      Jcy: "\u0419",
      Jfr: "\u{1D50D}",
      Jopf: "\u{1D541}",
      Jscr: "\u{1D4A5}",
      Jsercy: "\u0408",
      Jukcy: "\u0404",
      KHcy: "\u0425",
      KJcy: "\u040C",
      Kappa: "\u039A",
      Kcedil: "\u0136",
      Kcy: "\u041A",
      Kfr: "\u{1D50E}",
      Kopf: "\u{1D542}",
      Kscr: "\u{1D4A6}",
      LJcy: "\u0409",
      L: "<",
      LT: "<",
      Lacute: "\u0139",
      Lambda: "\u039B",
      Lang: "\u27EA",
      Laplacetrf: "\u2112",
      Larr: "\u219E",
      Lcaron: "\u013D",
      Lcedil: "\u013B",
      Lcy: "\u041B",
      LeftAngleBracket: "\u27E8",
      LeftArrow: "\u2190",
      LeftArrowBar: "\u21E4",
      LeftArrowRightArrow: "\u21C6",
      LeftCeiling: "\u2308",
      LeftDoubleBracket: "\u27E6",
      LeftDownTeeVector: "\u2961",
      LeftDownVector: "\u21C3",
      LeftDownVectorBar: "\u2959",
      LeftFloor: "\u230A",
      LeftRightArrow: "\u2194",
      LeftRightVector: "\u294E",
      LeftTee: "\u22A3",
      LeftTeeArrow: "\u21A4",
      LeftTeeVector: "\u295A",
      LeftTriangle: "\u22B2",
      LeftTriangleBar: "\u29CF",
      LeftTriangleEqual: "\u22B4",
      LeftUpDownVector: "\u2951",
      LeftUpTeeVector: "\u2960",
      LeftUpVector: "\u21BF",
      LeftUpVectorBar: "\u2958",
      LeftVector: "\u21BC",
      LeftVectorBar: "\u2952",
      Leftarrow: "\u21D0",
      Leftrightarrow: "\u21D4",
      LessEqualGreater: "\u22DA",
      LessFullEqual: "\u2266",
      LessGreater: "\u2276",
      LessLess: "\u2AA1",
      LessSlantEqual: "\u2A7D",
      LessTilde: "\u2272",
      Lfr: "\u{1D50F}",
      Ll: "\u22D8",
      Lleftarrow: "\u21DA",
      Lmidot: "\u013F",
      LongLeftArrow: "\u27F5",
      LongLeftRightArrow: "\u27F7",
      LongRightArrow: "\u27F6",
      Longleftarrow: "\u27F8",
      Longleftrightarrow: "\u27FA",
      Longrightarrow: "\u27F9",
      Lopf: "\u{1D543}",
      LowerLeftArrow: "\u2199",
      LowerRightArrow: "\u2198",
      Lscr: "\u2112",
      Lsh: "\u21B0",
      Lstrok: "\u0141",
      Lt: "\u226A",
      Map: "\u2905",
      Mcy: "\u041C",
      MediumSpace: "\u205F",
      Mellintrf: "\u2133",
      Mfr: "\u{1D510}",
      MinusPlus: "\u2213",
      Mopf: "\u{1D544}",
      Mscr: "\u2133",
      Mu: "\u039C",
      NJcy: "\u040A",
      Nacute: "\u0143",
      Ncaron: "\u0147",
      Ncedil: "\u0145",
      Ncy: "\u041D",
      NegativeMediumSpace: "\u200B",
      NegativeThickSpace: "\u200B",
      NegativeThinSpace: "\u200B",
      NegativeVeryThinSpace: "\u200B",
      NestedGreaterGreater: "\u226B",
      NestedLessLess: "\u226A",
      NewLine: "\n",
      Nfr: "\u{1D511}",
      NoBreak: "\u2060",
      NonBreakingSpace: "\xA0",
      Nopf: "\u2115",
      Not: "\u2AEC",
      NotCongruent: "\u2262",
      NotCupCap: "\u226D",
      NotDoubleVerticalBar: "\u2226",
      NotElement: "\u2209",
      NotEqual: "\u2260",
      NotEqualTilde: "\u2242\u0338",
      NotExists: "\u2204",
      NotGreater: "\u226F",
      NotGreaterEqual: "\u2271",
      NotGreaterFullEqual: "\u2267\u0338",
      NotGreaterGreater: "\u226B\u0338",
      NotGreaterLess: "\u2279",
      NotGreaterSlantEqual: "\u2A7E\u0338",
      NotGreaterTilde: "\u2275",
      NotHumpDownHump: "\u224E\u0338",
      NotHumpEqual: "\u224F\u0338",
      NotLeftTriangle: "\u22EA",
      NotLeftTriangleBar: "\u29CF\u0338",
      NotLeftTriangleEqual: "\u22EC",
      NotLess: "\u226E",
      NotLessEqual: "\u2270",
      NotLessGreater: "\u2278",
      NotLessLess: "\u226A\u0338",
      NotLessSlantEqual: "\u2A7D\u0338",
      NotLessTilde: "\u2274",
      NotNestedGreaterGreater: "\u2AA2\u0338",
      NotNestedLessLess: "\u2AA1\u0338",
      NotPrecedes: "\u2280",
      NotPrecedesEqual: "\u2AAF\u0338",
      NotPrecedesSlantEqual: "\u22E0",
      NotReverseElement: "\u220C",
      NotRightTriangle: "\u22EB",
      NotRightTriangleBar: "\u29D0\u0338",
      NotRightTriangleEqual: "\u22ED",
      NotSquareSubset: "\u228F\u0338",
      NotSquareSubsetEqual: "\u22E2",
      NotSquareSuperset: "\u2290\u0338",
      NotSquareSupersetEqual: "\u22E3",
      NotSubset: "\u2282\u20D2",
      NotSubsetEqual: "\u2288",
      NotSucceeds: "\u2281",
      NotSucceedsEqual: "\u2AB0\u0338",
      NotSucceedsSlantEqual: "\u22E1",
      NotSucceedsTilde: "\u227F\u0338",
      NotSuperset: "\u2283\u20D2",
      NotSupersetEqual: "\u2289",
      NotTilde: "\u2241",
      NotTildeEqual: "\u2244",
      NotTildeFullEqual: "\u2247",
      NotTildeTilde: "\u2249",
      NotVerticalBar: "\u2224",
      Nscr: "\u{1D4A9}",
      Ntild: "\xD1",
      Ntilde: "\xD1",
      Nu: "\u039D",
      OElig: "\u0152",
      Oacut: "\xD3",
      Oacute: "\xD3",
      Ocir: "\xD4",
      Ocirc: "\xD4",
      Ocy: "\u041E",
      Odblac: "\u0150",
      Ofr: "\u{1D512}",
      Ograv: "\xD2",
      Ograve: "\xD2",
      Omacr: "\u014C",
      Omega: "\u03A9",
      Omicron: "\u039F",
      Oopf: "\u{1D546}",
      OpenCurlyDoubleQuote: "\u201C",
      OpenCurlyQuote: "\u2018",
      Or: "\u2A54",
      Oscr: "\u{1D4AA}",
      Oslas: "\xD8",
      Oslash: "\xD8",
      Otild: "\xD5",
      Otilde: "\xD5",
      Otimes: "\u2A37",
      Oum: "\xD6",
      Ouml: "\xD6",
      OverBar: "\u203E",
      OverBrace: "\u23DE",
      OverBracket: "\u23B4",
      OverParenthesis: "\u23DC",
      PartialD: "\u2202",
      Pcy: "\u041F",
      Pfr: "\u{1D513}",
      Phi: "\u03A6",
      Pi: "\u03A0",
      PlusMinus: "\xB1",
      Poincareplane: "\u210C",
      Popf: "\u2119",
      Pr: "\u2ABB",
      Precedes: "\u227A",
      PrecedesEqual: "\u2AAF",
      PrecedesSlantEqual: "\u227C",
      PrecedesTilde: "\u227E",
      Prime: "\u2033",
      Product: "\u220F",
      Proportion: "\u2237",
      Proportional: "\u221D",
      Pscr: "\u{1D4AB}",
      Psi: "\u03A8",
      QUO: '"',
      QUOT: '"',
      Qfr: "\u{1D514}",
      Qopf: "\u211A",
      Qscr: "\u{1D4AC}",
      RBarr: "\u2910",
      RE: "\xAE",
      REG: "\xAE",
      Racute: "\u0154",
      Rang: "\u27EB",
      Rarr: "\u21A0",
      Rarrtl: "\u2916",
      Rcaron: "\u0158",
      Rcedil: "\u0156",
      Rcy: "\u0420",
      Re: "\u211C",
      ReverseElement: "\u220B",
      ReverseEquilibrium: "\u21CB",
      ReverseUpEquilibrium: "\u296F",
      Rfr: "\u211C",
      Rho: "\u03A1",
      RightAngleBracket: "\u27E9",
      RightArrow: "\u2192",
      RightArrowBar: "\u21E5",
      RightArrowLeftArrow: "\u21C4",
      RightCeiling: "\u2309",
      RightDoubleBracket: "\u27E7",
      RightDownTeeVector: "\u295D",
      RightDownVector: "\u21C2",
      RightDownVectorBar: "\u2955",
      RightFloor: "\u230B",
      RightTee: "\u22A2",
      RightTeeArrow: "\u21A6",
      RightTeeVector: "\u295B",
      RightTriangle: "\u22B3",
      RightTriangleBar: "\u29D0",
      RightTriangleEqual: "\u22B5",
      RightUpDownVector: "\u294F",
      RightUpTeeVector: "\u295C",
      RightUpVector: "\u21BE",
      RightUpVectorBar: "\u2954",
      RightVector: "\u21C0",
      RightVectorBar: "\u2953",
      Rightarrow: "\u21D2",
      Ropf: "\u211D",
      RoundImplies: "\u2970",
      Rrightarrow: "\u21DB",
      Rscr: "\u211B",
      Rsh: "\u21B1",
      RuleDelayed: "\u29F4",
      SHCHcy: "\u0429",
      SHcy: "\u0428",
      SOFTcy: "\u042C",
      Sacute: "\u015A",
      Sc: "\u2ABC",
      Scaron: "\u0160",
      Scedil: "\u015E",
      Scirc: "\u015C",
      Scy: "\u0421",
      Sfr: "\u{1D516}",
      ShortDownArrow: "\u2193",
      ShortLeftArrow: "\u2190",
      ShortRightArrow: "\u2192",
      ShortUpArrow: "\u2191",
      Sigma: "\u03A3",
      SmallCircle: "\u2218",
      Sopf: "\u{1D54A}",
      Sqrt: "\u221A",
      Square: "\u25A1",
      SquareIntersection: "\u2293",
      SquareSubset: "\u228F",
      SquareSubsetEqual: "\u2291",
      SquareSuperset: "\u2290",
      SquareSupersetEqual: "\u2292",
      SquareUnion: "\u2294",
      Sscr: "\u{1D4AE}",
      Star: "\u22C6",
      Sub: "\u22D0",
      Subset: "\u22D0",
      SubsetEqual: "\u2286",
      Succeeds: "\u227B",
      SucceedsEqual: "\u2AB0",
      SucceedsSlantEqual: "\u227D",
      SucceedsTilde: "\u227F",
      SuchThat: "\u220B",
      Sum: "\u2211",
      Sup: "\u22D1",
      Superset: "\u2283",
      SupersetEqual: "\u2287",
      Supset: "\u22D1",
      THOR: "\xDE",
      THORN: "\xDE",
      TRADE: "\u2122",
      TSHcy: "\u040B",
      TScy: "\u0426",
      Tab: "	",
      Tau: "\u03A4",
      Tcaron: "\u0164",
      Tcedil: "\u0162",
      Tcy: "\u0422",
      Tfr: "\u{1D517}",
      Therefore: "\u2234",
      Theta: "\u0398",
      ThickSpace: "\u205F\u200A",
      ThinSpace: "\u2009",
      Tilde: "\u223C",
      TildeEqual: "\u2243",
      TildeFullEqual: "\u2245",
      TildeTilde: "\u2248",
      Topf: "\u{1D54B}",
      TripleDot: "\u20DB",
      Tscr: "\u{1D4AF}",
      Tstrok: "\u0166",
      Uacut: "\xDA",
      Uacute: "\xDA",
      Uarr: "\u219F",
      Uarrocir: "\u2949",
      Ubrcy: "\u040E",
      Ubreve: "\u016C",
      Ucir: "\xDB",
      Ucirc: "\xDB",
      Ucy: "\u0423",
      Udblac: "\u0170",
      Ufr: "\u{1D518}",
      Ugrav: "\xD9",
      Ugrave: "\xD9",
      Umacr: "\u016A",
      UnderBar: "_",
      UnderBrace: "\u23DF",
      UnderBracket: "\u23B5",
      UnderParenthesis: "\u23DD",
      Union: "\u22C3",
      UnionPlus: "\u228E",
      Uogon: "\u0172",
      Uopf: "\u{1D54C}",
      UpArrow: "\u2191",
      UpArrowBar: "\u2912",
      UpArrowDownArrow: "\u21C5",
      UpDownArrow: "\u2195",
      UpEquilibrium: "\u296E",
      UpTee: "\u22A5",
      UpTeeArrow: "\u21A5",
      Uparrow: "\u21D1",
      Updownarrow: "\u21D5",
      UpperLeftArrow: "\u2196",
      UpperRightArrow: "\u2197",
      Upsi: "\u03D2",
      Upsilon: "\u03A5",
      Uring: "\u016E",
      Uscr: "\u{1D4B0}",
      Utilde: "\u0168",
      Uum: "\xDC",
      Uuml: "\xDC",
      VDash: "\u22AB",
      Vbar: "\u2AEB",
      Vcy: "\u0412",
      Vdash: "\u22A9",
      Vdashl: "\u2AE6",
      Vee: "\u22C1",
      Verbar: "\u2016",
      Vert: "\u2016",
      VerticalBar: "\u2223",
      VerticalLine: "|",
      VerticalSeparator: "\u2758",
      VerticalTilde: "\u2240",
      VeryThinSpace: "\u200A",
      Vfr: "\u{1D519}",
      Vopf: "\u{1D54D}",
      Vscr: "\u{1D4B1}",
      Vvdash: "\u22AA",
      Wcirc: "\u0174",
      Wedge: "\u22C0",
      Wfr: "\u{1D51A}",
      Wopf: "\u{1D54E}",
      Wscr: "\u{1D4B2}",
      Xfr: "\u{1D51B}",
      Xi: "\u039E",
      Xopf: "\u{1D54F}",
      Xscr: "\u{1D4B3}",
      YAcy: "\u042F",
      YIcy: "\u0407",
      YUcy: "\u042E",
      Yacut: "\xDD",
      Yacute: "\xDD",
      Ycirc: "\u0176",
      Ycy: "\u042B",
      Yfr: "\u{1D51C}",
      Yopf: "\u{1D550}",
      Yscr: "\u{1D4B4}",
      Yuml: "\u0178",
      ZHcy: "\u0416",
      Zacute: "\u0179",
      Zcaron: "\u017D",
      Zcy: "\u0417",
      Zdot: "\u017B",
      ZeroWidthSpace: "\u200B",
      Zeta: "\u0396",
      Zfr: "\u2128",
      Zopf: "\u2124",
      Zscr: "\u{1D4B5}",
      aacut: "\xE1",
      aacute: "\xE1",
      abreve: "\u0103",
      ac: "\u223E",
      acE: "\u223E\u0333",
      acd: "\u223F",
      acir: "\xE2",
      acirc: "\xE2",
      acut: "\xB4",
      acute: "\xB4",
      acy: "\u0430",
      aeli: "\xE6",
      aelig: "\xE6",
      af: "\u2061",
      afr: "\u{1D51E}",
      agrav: "\xE0",
      agrave: "\xE0",
      alefsym: "\u2135",
      aleph: "\u2135",
      alpha: "\u03B1",
      amacr: "\u0101",
      amalg: "\u2A3F",
      am: "&",
      amp: "&",
      and: "\u2227",
      andand: "\u2A55",
      andd: "\u2A5C",
      andslope: "\u2A58",
      andv: "\u2A5A",
      ang: "\u2220",
      ange: "\u29A4",
      angle: "\u2220",
      angmsd: "\u2221",
      angmsdaa: "\u29A8",
      angmsdab: "\u29A9",
      angmsdac: "\u29AA",
      angmsdad: "\u29AB",
      angmsdae: "\u29AC",
      angmsdaf: "\u29AD",
      angmsdag: "\u29AE",
      angmsdah: "\u29AF",
      angrt: "\u221F",
      angrtvb: "\u22BE",
      angrtvbd: "\u299D",
      angsph: "\u2222",
      angst: "\xC5",
      angzarr: "\u237C",
      aogon: "\u0105",
      aopf: "\u{1D552}",
      ap: "\u2248",
      apE: "\u2A70",
      apacir: "\u2A6F",
      ape: "\u224A",
      apid: "\u224B",
      apos: "'",
      approx: "\u2248",
      approxeq: "\u224A",
      arin: "\xE5",
      aring: "\xE5",
      ascr: "\u{1D4B6}",
      ast: "*",
      asymp: "\u2248",
      asympeq: "\u224D",
      atild: "\xE3",
      atilde: "\xE3",
      aum: "\xE4",
      auml: "\xE4",
      awconint: "\u2233",
      awint: "\u2A11",
      bNot: "\u2AED",
      backcong: "\u224C",
      backepsilon: "\u03F6",
      backprime: "\u2035",
      backsim: "\u223D",
      backsimeq: "\u22CD",
      barvee: "\u22BD",
      barwed: "\u2305",
      barwedge: "\u2305",
      bbrk: "\u23B5",
      bbrktbrk: "\u23B6",
      bcong: "\u224C",
      bcy: "\u0431",
      bdquo: "\u201E",
      becaus: "\u2235",
      because: "\u2235",
      bemptyv: "\u29B0",
      bepsi: "\u03F6",
      bernou: "\u212C",
      beta: "\u03B2",
      beth: "\u2136",
      between: "\u226C",
      bfr: "\u{1D51F}",
      bigcap: "\u22C2",
      bigcirc: "\u25EF",
      bigcup: "\u22C3",
      bigodot: "\u2A00",
      bigoplus: "\u2A01",
      bigotimes: "\u2A02",
      bigsqcup: "\u2A06",
      bigstar: "\u2605",
      bigtriangledown: "\u25BD",
      bigtriangleup: "\u25B3",
      biguplus: "\u2A04",
      bigvee: "\u22C1",
      bigwedge: "\u22C0",
      bkarow: "\u290D",
      blacklozenge: "\u29EB",
      blacksquare: "\u25AA",
      blacktriangle: "\u25B4",
      blacktriangledown: "\u25BE",
      blacktriangleleft: "\u25C2",
      blacktriangleright: "\u25B8",
      blank: "\u2423",
      blk12: "\u2592",
      blk14: "\u2591",
      blk34: "\u2593",
      block: "\u2588",
      bne: "=\u20E5",
      bnequiv: "\u2261\u20E5",
      bnot: "\u2310",
      bopf: "\u{1D553}",
      bot: "\u22A5",
      bottom: "\u22A5",
      bowtie: "\u22C8",
      boxDL: "\u2557",
      boxDR: "\u2554",
      boxDl: "\u2556",
      boxDr: "\u2553",
      boxH: "\u2550",
      boxHD: "\u2566",
      boxHU: "\u2569",
      boxHd: "\u2564",
      boxHu: "\u2567",
      boxUL: "\u255D",
      boxUR: "\u255A",
      boxUl: "\u255C",
      boxUr: "\u2559",
      boxV: "\u2551",
      boxVH: "\u256C",
      boxVL: "\u2563",
      boxVR: "\u2560",
      boxVh: "\u256B",
      boxVl: "\u2562",
      boxVr: "\u255F",
      boxbox: "\u29C9",
      boxdL: "\u2555",
      boxdR: "\u2552",
      boxdl: "\u2510",
      boxdr: "\u250C",
      boxh: "\u2500",
      boxhD: "\u2565",
      boxhU: "\u2568",
      boxhd: "\u252C",
      boxhu: "\u2534",
      boxminus: "\u229F",
      boxplus: "\u229E",
      boxtimes: "\u22A0",
      boxuL: "\u255B",
      boxuR: "\u2558",
      boxul: "\u2518",
      boxur: "\u2514",
      boxv: "\u2502",
      boxvH: "\u256A",
      boxvL: "\u2561",
      boxvR: "\u255E",
      boxvh: "\u253C",
      boxvl: "\u2524",
      boxvr: "\u251C",
      bprime: "\u2035",
      breve: "\u02D8",
      brvba: "\xA6",
      brvbar: "\xA6",
      bscr: "\u{1D4B7}",
      bsemi: "\u204F",
      bsim: "\u223D",
      bsime: "\u22CD",
      bsol: "\\",
      bsolb: "\u29C5",
      bsolhsub: "\u27C8",
      bull: "\u2022",
      bullet: "\u2022",
      bump: "\u224E",
      bumpE: "\u2AAE",
      bumpe: "\u224F",
      bumpeq: "\u224F",
      cacute: "\u0107",
      cap: "\u2229",
      capand: "\u2A44",
      capbrcup: "\u2A49",
      capcap: "\u2A4B",
      capcup: "\u2A47",
      capdot: "\u2A40",
      caps: "\u2229\uFE00",
      caret: "\u2041",
      caron: "\u02C7",
      ccaps: "\u2A4D",
      ccaron: "\u010D",
      ccedi: "\xE7",
      ccedil: "\xE7",
      ccirc: "\u0109",
      ccups: "\u2A4C",
      ccupssm: "\u2A50",
      cdot: "\u010B",
      cedi: "\xB8",
      cedil: "\xB8",
      cemptyv: "\u29B2",
      cen: "\xA2",
      cent: "\xA2",
      centerdot: "\xB7",
      cfr: "\u{1D520}",
      chcy: "\u0447",
      check: "\u2713",
      checkmark: "\u2713",
      chi: "\u03C7",
      cir: "\u25CB",
      cirE: "\u29C3",
      circ: "\u02C6",
      circeq: "\u2257",
      circlearrowleft: "\u21BA",
      circlearrowright: "\u21BB",
      circledR: "\xAE",
      circledS: "\u24C8",
      circledast: "\u229B",
      circledcirc: "\u229A",
      circleddash: "\u229D",
      cire: "\u2257",
      cirfnint: "\u2A10",
      cirmid: "\u2AEF",
      cirscir: "\u29C2",
      clubs: "\u2663",
      clubsuit: "\u2663",
      colon: ":",
      colone: "\u2254",
      coloneq: "\u2254",
      comma: ",",
      commat: "@",
      comp: "\u2201",
      compfn: "\u2218",
      complement: "\u2201",
      complexes: "\u2102",
      cong: "\u2245",
      congdot: "\u2A6D",
      conint: "\u222E",
      copf: "\u{1D554}",
      coprod: "\u2210",
      cop: "\xA9",
      copy: "\xA9",
      copysr: "\u2117",
      crarr: "\u21B5",
      cross: "\u2717",
      cscr: "\u{1D4B8}",
      csub: "\u2ACF",
      csube: "\u2AD1",
      csup: "\u2AD0",
      csupe: "\u2AD2",
      ctdot: "\u22EF",
      cudarrl: "\u2938",
      cudarrr: "\u2935",
      cuepr: "\u22DE",
      cuesc: "\u22DF",
      cularr: "\u21B6",
      cularrp: "\u293D",
      cup: "\u222A",
      cupbrcap: "\u2A48",
      cupcap: "\u2A46",
      cupcup: "\u2A4A",
      cupdot: "\u228D",
      cupor: "\u2A45",
      cups: "\u222A\uFE00",
      curarr: "\u21B7",
      curarrm: "\u293C",
      curlyeqprec: "\u22DE",
      curlyeqsucc: "\u22DF",
      curlyvee: "\u22CE",
      curlywedge: "\u22CF",
      curre: "\xA4",
      curren: "\xA4",
      curvearrowleft: "\u21B6",
      curvearrowright: "\u21B7",
      cuvee: "\u22CE",
      cuwed: "\u22CF",
      cwconint: "\u2232",
      cwint: "\u2231",
      cylcty: "\u232D",
      dArr: "\u21D3",
      dHar: "\u2965",
      dagger: "\u2020",
      daleth: "\u2138",
      darr: "\u2193",
      dash: "\u2010",
      dashv: "\u22A3",
      dbkarow: "\u290F",
      dblac: "\u02DD",
      dcaron: "\u010F",
      dcy: "\u0434",
      dd: "\u2146",
      ddagger: "\u2021",
      ddarr: "\u21CA",
      ddotseq: "\u2A77",
      de: "\xB0",
      deg: "\xB0",
      delta: "\u03B4",
      demptyv: "\u29B1",
      dfisht: "\u297F",
      dfr: "\u{1D521}",
      dharl: "\u21C3",
      dharr: "\u21C2",
      diam: "\u22C4",
      diamond: "\u22C4",
      diamondsuit: "\u2666",
      diams: "\u2666",
      die: "\xA8",
      digamma: "\u03DD",
      disin: "\u22F2",
      div: "\xF7",
      divid: "\xF7",
      divide: "\xF7",
      divideontimes: "\u22C7",
      divonx: "\u22C7",
      djcy: "\u0452",
      dlcorn: "\u231E",
      dlcrop: "\u230D",
      dollar: "$",
      dopf: "\u{1D555}",
      dot: "\u02D9",
      doteq: "\u2250",
      doteqdot: "\u2251",
      dotminus: "\u2238",
      dotplus: "\u2214",
      dotsquare: "\u22A1",
      doublebarwedge: "\u2306",
      downarrow: "\u2193",
      downdownarrows: "\u21CA",
      downharpoonleft: "\u21C3",
      downharpoonright: "\u21C2",
      drbkarow: "\u2910",
      drcorn: "\u231F",
      drcrop: "\u230C",
      dscr: "\u{1D4B9}",
      dscy: "\u0455",
      dsol: "\u29F6",
      dstrok: "\u0111",
      dtdot: "\u22F1",
      dtri: "\u25BF",
      dtrif: "\u25BE",
      duarr: "\u21F5",
      duhar: "\u296F",
      dwangle: "\u29A6",
      dzcy: "\u045F",
      dzigrarr: "\u27FF",
      eDDot: "\u2A77",
      eDot: "\u2251",
      eacut: "\xE9",
      eacute: "\xE9",
      easter: "\u2A6E",
      ecaron: "\u011B",
      ecir: "\xEA",
      ecirc: "\xEA",
      ecolon: "\u2255",
      ecy: "\u044D",
      edot: "\u0117",
      ee: "\u2147",
      efDot: "\u2252",
      efr: "\u{1D522}",
      eg: "\u2A9A",
      egrav: "\xE8",
      egrave: "\xE8",
      egs: "\u2A96",
      egsdot: "\u2A98",
      el: "\u2A99",
      elinters: "\u23E7",
      ell: "\u2113",
      els: "\u2A95",
      elsdot: "\u2A97",
      emacr: "\u0113",
      empty: "\u2205",
      emptyset: "\u2205",
      emptyv: "\u2205",
      emsp13: "\u2004",
      emsp14: "\u2005",
      emsp: "\u2003",
      eng: "\u014B",
      ensp: "\u2002",
      eogon: "\u0119",
      eopf: "\u{1D556}",
      epar: "\u22D5",
      eparsl: "\u29E3",
      eplus: "\u2A71",
      epsi: "\u03B5",
      epsilon: "\u03B5",
      epsiv: "\u03F5",
      eqcirc: "\u2256",
      eqcolon: "\u2255",
      eqsim: "\u2242",
      eqslantgtr: "\u2A96",
      eqslantless: "\u2A95",
      equals: "=",
      equest: "\u225F",
      equiv: "\u2261",
      equivDD: "\u2A78",
      eqvparsl: "\u29E5",
      erDot: "\u2253",
      erarr: "\u2971",
      escr: "\u212F",
      esdot: "\u2250",
      esim: "\u2242",
      eta: "\u03B7",
      et: "\xF0",
      eth: "\xF0",
      eum: "\xEB",
      euml: "\xEB",
      euro: "\u20AC",
      excl: "!",
      exist: "\u2203",
      expectation: "\u2130",
      exponentiale: "\u2147",
      fallingdotseq: "\u2252",
      fcy: "\u0444",
      female: "\u2640",
      ffilig: "\uFB03",
      fflig: "\uFB00",
      ffllig: "\uFB04",
      ffr: "\u{1D523}",
      filig: "\uFB01",
      fjlig: "fj",
      flat: "\u266D",
      fllig: "\uFB02",
      fltns: "\u25B1",
      fnof: "\u0192",
      fopf: "\u{1D557}",
      forall: "\u2200",
      fork: "\u22D4",
      forkv: "\u2AD9",
      fpartint: "\u2A0D",
      frac1: "\xBC",
      frac12: "\xBD",
      frac13: "\u2153",
      frac14: "\xBC",
      frac15: "\u2155",
      frac16: "\u2159",
      frac18: "\u215B",
      frac23: "\u2154",
      frac25: "\u2156",
      frac3: "\xBE",
      frac34: "\xBE",
      frac35: "\u2157",
      frac38: "\u215C",
      frac45: "\u2158",
      frac56: "\u215A",
      frac58: "\u215D",
      frac78: "\u215E",
      frasl: "\u2044",
      frown: "\u2322",
      fscr: "\u{1D4BB}",
      gE: "\u2267",
      gEl: "\u2A8C",
      gacute: "\u01F5",
      gamma: "\u03B3",
      gammad: "\u03DD",
      gap: "\u2A86",
      gbreve: "\u011F",
      gcirc: "\u011D",
      gcy: "\u0433",
      gdot: "\u0121",
      ge: "\u2265",
      gel: "\u22DB",
      geq: "\u2265",
      geqq: "\u2267",
      geqslant: "\u2A7E",
      ges: "\u2A7E",
      gescc: "\u2AA9",
      gesdot: "\u2A80",
      gesdoto: "\u2A82",
      gesdotol: "\u2A84",
      gesl: "\u22DB\uFE00",
      gesles: "\u2A94",
      gfr: "\u{1D524}",
      gg: "\u226B",
      ggg: "\u22D9",
      gimel: "\u2137",
      gjcy: "\u0453",
      gl: "\u2277",
      glE: "\u2A92",
      gla: "\u2AA5",
      glj: "\u2AA4",
      gnE: "\u2269",
      gnap: "\u2A8A",
      gnapprox: "\u2A8A",
      gne: "\u2A88",
      gneq: "\u2A88",
      gneqq: "\u2269",
      gnsim: "\u22E7",
      gopf: "\u{1D558}",
      grave: "`",
      gscr: "\u210A",
      gsim: "\u2273",
      gsime: "\u2A8E",
      gsiml: "\u2A90",
      g: ">",
      gt: ">",
      gtcc: "\u2AA7",
      gtcir: "\u2A7A",
      gtdot: "\u22D7",
      gtlPar: "\u2995",
      gtquest: "\u2A7C",
      gtrapprox: "\u2A86",
      gtrarr: "\u2978",
      gtrdot: "\u22D7",
      gtreqless: "\u22DB",
      gtreqqless: "\u2A8C",
      gtrless: "\u2277",
      gtrsim: "\u2273",
      gvertneqq: "\u2269\uFE00",
      gvnE: "\u2269\uFE00",
      hArr: "\u21D4",
      hairsp: "\u200A",
      half: "\xBD",
      hamilt: "\u210B",
      hardcy: "\u044A",
      harr: "\u2194",
      harrcir: "\u2948",
      harrw: "\u21AD",
      hbar: "\u210F",
      hcirc: "\u0125",
      hearts: "\u2665",
      heartsuit: "\u2665",
      hellip: "\u2026",
      hercon: "\u22B9",
      hfr: "\u{1D525}",
      hksearow: "\u2925",
      hkswarow: "\u2926",
      hoarr: "\u21FF",
      homtht: "\u223B",
      hookleftarrow: "\u21A9",
      hookrightarrow: "\u21AA",
      hopf: "\u{1D559}",
      horbar: "\u2015",
      hscr: "\u{1D4BD}",
      hslash: "\u210F",
      hstrok: "\u0127",
      hybull: "\u2043",
      hyphen: "\u2010",
      iacut: "\xED",
      iacute: "\xED",
      ic: "\u2063",
      icir: "\xEE",
      icirc: "\xEE",
      icy: "\u0438",
      iecy: "\u0435",
      iexc: "\xA1",
      iexcl: "\xA1",
      iff: "\u21D4",
      ifr: "\u{1D526}",
      igrav: "\xEC",
      igrave: "\xEC",
      ii: "\u2148",
      iiiint: "\u2A0C",
      iiint: "\u222D",
      iinfin: "\u29DC",
      iiota: "\u2129",
      ijlig: "\u0133",
      imacr: "\u012B",
      image: "\u2111",
      imagline: "\u2110",
      imagpart: "\u2111",
      imath: "\u0131",
      imof: "\u22B7",
      imped: "\u01B5",
      in: "\u2208",
      incare: "\u2105",
      infin: "\u221E",
      infintie: "\u29DD",
      inodot: "\u0131",
      int: "\u222B",
      intcal: "\u22BA",
      integers: "\u2124",
      intercal: "\u22BA",
      intlarhk: "\u2A17",
      intprod: "\u2A3C",
      iocy: "\u0451",
      iogon: "\u012F",
      iopf: "\u{1D55A}",
      iota: "\u03B9",
      iprod: "\u2A3C",
      iques: "\xBF",
      iquest: "\xBF",
      iscr: "\u{1D4BE}",
      isin: "\u2208",
      isinE: "\u22F9",
      isindot: "\u22F5",
      isins: "\u22F4",
      isinsv: "\u22F3",
      isinv: "\u2208",
      it: "\u2062",
      itilde: "\u0129",
      iukcy: "\u0456",
      ium: "\xEF",
      iuml: "\xEF",
      jcirc: "\u0135",
      jcy: "\u0439",
      jfr: "\u{1D527}",
      jmath: "\u0237",
      jopf: "\u{1D55B}",
      jscr: "\u{1D4BF}",
      jsercy: "\u0458",
      jukcy: "\u0454",
      kappa: "\u03BA",
      kappav: "\u03F0",
      kcedil: "\u0137",
      kcy: "\u043A",
      kfr: "\u{1D528}",
      kgreen: "\u0138",
      khcy: "\u0445",
      kjcy: "\u045C",
      kopf: "\u{1D55C}",
      kscr: "\u{1D4C0}",
      lAarr: "\u21DA",
      lArr: "\u21D0",
      lAtail: "\u291B",
      lBarr: "\u290E",
      lE: "\u2266",
      lEg: "\u2A8B",
      lHar: "\u2962",
      lacute: "\u013A",
      laemptyv: "\u29B4",
      lagran: "\u2112",
      lambda: "\u03BB",
      lang: "\u27E8",
      langd: "\u2991",
      langle: "\u27E8",
      lap: "\u2A85",
      laqu: "\xAB",
      laquo: "\xAB",
      larr: "\u2190",
      larrb: "\u21E4",
      larrbfs: "\u291F",
      larrfs: "\u291D",
      larrhk: "\u21A9",
      larrlp: "\u21AB",
      larrpl: "\u2939",
      larrsim: "\u2973",
      larrtl: "\u21A2",
      lat: "\u2AAB",
      latail: "\u2919",
      late: "\u2AAD",
      lates: "\u2AAD\uFE00",
      lbarr: "\u290C",
      lbbrk: "\u2772",
      lbrace: "{",
      lbrack: "[",
      lbrke: "\u298B",
      lbrksld: "\u298F",
      lbrkslu: "\u298D",
      lcaron: "\u013E",
      lcedil: "\u013C",
      lceil: "\u2308",
      lcub: "{",
      lcy: "\u043B",
      ldca: "\u2936",
      ldquo: "\u201C",
      ldquor: "\u201E",
      ldrdhar: "\u2967",
      ldrushar: "\u294B",
      ldsh: "\u21B2",
      le: "\u2264",
      leftarrow: "\u2190",
      leftarrowtail: "\u21A2",
      leftharpoondown: "\u21BD",
      leftharpoonup: "\u21BC",
      leftleftarrows: "\u21C7",
      leftrightarrow: "\u2194",
      leftrightarrows: "\u21C6",
      leftrightharpoons: "\u21CB",
      leftrightsquigarrow: "\u21AD",
      leftthreetimes: "\u22CB",
      leg: "\u22DA",
      leq: "\u2264",
      leqq: "\u2266",
      leqslant: "\u2A7D",
      les: "\u2A7D",
      lescc: "\u2AA8",
      lesdot: "\u2A7F",
      lesdoto: "\u2A81",
      lesdotor: "\u2A83",
      lesg: "\u22DA\uFE00",
      lesges: "\u2A93",
      lessapprox: "\u2A85",
      lessdot: "\u22D6",
      lesseqgtr: "\u22DA",
      lesseqqgtr: "\u2A8B",
      lessgtr: "\u2276",
      lesssim: "\u2272",
      lfisht: "\u297C",
      lfloor: "\u230A",
      lfr: "\u{1D529}",
      lg: "\u2276",
      lgE: "\u2A91",
      lhard: "\u21BD",
      lharu: "\u21BC",
      lharul: "\u296A",
      lhblk: "\u2584",
      ljcy: "\u0459",
      ll: "\u226A",
      llarr: "\u21C7",
      llcorner: "\u231E",
      llhard: "\u296B",
      lltri: "\u25FA",
      lmidot: "\u0140",
      lmoust: "\u23B0",
      lmoustache: "\u23B0",
      lnE: "\u2268",
      lnap: "\u2A89",
      lnapprox: "\u2A89",
      lne: "\u2A87",
      lneq: "\u2A87",
      lneqq: "\u2268",
      lnsim: "\u22E6",
      loang: "\u27EC",
      loarr: "\u21FD",
      lobrk: "\u27E6",
      longleftarrow: "\u27F5",
      longleftrightarrow: "\u27F7",
      longmapsto: "\u27FC",
      longrightarrow: "\u27F6",
      looparrowleft: "\u21AB",
      looparrowright: "\u21AC",
      lopar: "\u2985",
      lopf: "\u{1D55D}",
      loplus: "\u2A2D",
      lotimes: "\u2A34",
      lowast: "\u2217",
      lowbar: "_",
      loz: "\u25CA",
      lozenge: "\u25CA",
      lozf: "\u29EB",
      lpar: "(",
      lparlt: "\u2993",
      lrarr: "\u21C6",
      lrcorner: "\u231F",
      lrhar: "\u21CB",
      lrhard: "\u296D",
      lrm: "\u200E",
      lrtri: "\u22BF",
      lsaquo: "\u2039",
      lscr: "\u{1D4C1}",
      lsh: "\u21B0",
      lsim: "\u2272",
      lsime: "\u2A8D",
      lsimg: "\u2A8F",
      lsqb: "[",
      lsquo: "\u2018",
      lsquor: "\u201A",
      lstrok: "\u0142",
      l: "<",
      lt: "<",
      ltcc: "\u2AA6",
      ltcir: "\u2A79",
      ltdot: "\u22D6",
      lthree: "\u22CB",
      ltimes: "\u22C9",
      ltlarr: "\u2976",
      ltquest: "\u2A7B",
      ltrPar: "\u2996",
      ltri: "\u25C3",
      ltrie: "\u22B4",
      ltrif: "\u25C2",
      lurdshar: "\u294A",
      luruhar: "\u2966",
      lvertneqq: "\u2268\uFE00",
      lvnE: "\u2268\uFE00",
      mDDot: "\u223A",
      mac: "\xAF",
      macr: "\xAF",
      male: "\u2642",
      malt: "\u2720",
      maltese: "\u2720",
      map: "\u21A6",
      mapsto: "\u21A6",
      mapstodown: "\u21A7",
      mapstoleft: "\u21A4",
      mapstoup: "\u21A5",
      marker: "\u25AE",
      mcomma: "\u2A29",
      mcy: "\u043C",
      mdash: "\u2014",
      measuredangle: "\u2221",
      mfr: "\u{1D52A}",
      mho: "\u2127",
      micr: "\xB5",
      micro: "\xB5",
      mid: "\u2223",
      midast: "*",
      midcir: "\u2AF0",
      middo: "\xB7",
      middot: "\xB7",
      minus: "\u2212",
      minusb: "\u229F",
      minusd: "\u2238",
      minusdu: "\u2A2A",
      mlcp: "\u2ADB",
      mldr: "\u2026",
      mnplus: "\u2213",
      models: "\u22A7",
      mopf: "\u{1D55E}",
      mp: "\u2213",
      mscr: "\u{1D4C2}",
      mstpos: "\u223E",
      mu: "\u03BC",
      multimap: "\u22B8",
      mumap: "\u22B8",
      nGg: "\u22D9\u0338",
      nGt: "\u226B\u20D2",
      nGtv: "\u226B\u0338",
      nLeftarrow: "\u21CD",
      nLeftrightarrow: "\u21CE",
      nLl: "\u22D8\u0338",
      nLt: "\u226A\u20D2",
      nLtv: "\u226A\u0338",
      nRightarrow: "\u21CF",
      nVDash: "\u22AF",
      nVdash: "\u22AE",
      nabla: "\u2207",
      nacute: "\u0144",
      nang: "\u2220\u20D2",
      nap: "\u2249",
      napE: "\u2A70\u0338",
      napid: "\u224B\u0338",
      napos: "\u0149",
      napprox: "\u2249",
      natur: "\u266E",
      natural: "\u266E",
      naturals: "\u2115",
      nbs: "\xA0",
      nbsp: "\xA0",
      nbump: "\u224E\u0338",
      nbumpe: "\u224F\u0338",
      ncap: "\u2A43",
      ncaron: "\u0148",
      ncedil: "\u0146",
      ncong: "\u2247",
      ncongdot: "\u2A6D\u0338",
      ncup: "\u2A42",
      ncy: "\u043D",
      ndash: "\u2013",
      ne: "\u2260",
      neArr: "\u21D7",
      nearhk: "\u2924",
      nearr: "\u2197",
      nearrow: "\u2197",
      nedot: "\u2250\u0338",
      nequiv: "\u2262",
      nesear: "\u2928",
      nesim: "\u2242\u0338",
      nexist: "\u2204",
      nexists: "\u2204",
      nfr: "\u{1D52B}",
      ngE: "\u2267\u0338",
      nge: "\u2271",
      ngeq: "\u2271",
      ngeqq: "\u2267\u0338",
      ngeqslant: "\u2A7E\u0338",
      nges: "\u2A7E\u0338",
      ngsim: "\u2275",
      ngt: "\u226F",
      ngtr: "\u226F",
      nhArr: "\u21CE",
      nharr: "\u21AE",
      nhpar: "\u2AF2",
      ni: "\u220B",
      nis: "\u22FC",
      nisd: "\u22FA",
      niv: "\u220B",
      njcy: "\u045A",
      nlArr: "\u21CD",
      nlE: "\u2266\u0338",
      nlarr: "\u219A",
      nldr: "\u2025",
      nle: "\u2270",
      nleftarrow: "\u219A",
      nleftrightarrow: "\u21AE",
      nleq: "\u2270",
      nleqq: "\u2266\u0338",
      nleqslant: "\u2A7D\u0338",
      nles: "\u2A7D\u0338",
      nless: "\u226E",
      nlsim: "\u2274",
      nlt: "\u226E",
      nltri: "\u22EA",
      nltrie: "\u22EC",
      nmid: "\u2224",
      nopf: "\u{1D55F}",
      no: "\xAC",
      not: "\xAC",
      notin: "\u2209",
      notinE: "\u22F9\u0338",
      notindot: "\u22F5\u0338",
      notinva: "\u2209",
      notinvb: "\u22F7",
      notinvc: "\u22F6",
      notni: "\u220C",
      notniva: "\u220C",
      notnivb: "\u22FE",
      notnivc: "\u22FD",
      npar: "\u2226",
      nparallel: "\u2226",
      nparsl: "\u2AFD\u20E5",
      npart: "\u2202\u0338",
      npolint: "\u2A14",
      npr: "\u2280",
      nprcue: "\u22E0",
      npre: "\u2AAF\u0338",
      nprec: "\u2280",
      npreceq: "\u2AAF\u0338",
      nrArr: "\u21CF",
      nrarr: "\u219B",
      nrarrc: "\u2933\u0338",
      nrarrw: "\u219D\u0338",
      nrightarrow: "\u219B",
      nrtri: "\u22EB",
      nrtrie: "\u22ED",
      nsc: "\u2281",
      nsccue: "\u22E1",
      nsce: "\u2AB0\u0338",
      nscr: "\u{1D4C3}",
      nshortmid: "\u2224",
      nshortparallel: "\u2226",
      nsim: "\u2241",
      nsime: "\u2244",
      nsimeq: "\u2244",
      nsmid: "\u2224",
      nspar: "\u2226",
      nsqsube: "\u22E2",
      nsqsupe: "\u22E3",
      nsub: "\u2284",
      nsubE: "\u2AC5\u0338",
      nsube: "\u2288",
      nsubset: "\u2282\u20D2",
      nsubseteq: "\u2288",
      nsubseteqq: "\u2AC5\u0338",
      nsucc: "\u2281",
      nsucceq: "\u2AB0\u0338",
      nsup: "\u2285",
      nsupE: "\u2AC6\u0338",
      nsupe: "\u2289",
      nsupset: "\u2283\u20D2",
      nsupseteq: "\u2289",
      nsupseteqq: "\u2AC6\u0338",
      ntgl: "\u2279",
      ntild: "\xF1",
      ntilde: "\xF1",
      ntlg: "\u2278",
      ntriangleleft: "\u22EA",
      ntrianglelefteq: "\u22EC",
      ntriangleright: "\u22EB",
      ntrianglerighteq: "\u22ED",
      nu: "\u03BD",
      num: "#",
      numero: "\u2116",
      numsp: "\u2007",
      nvDash: "\u22AD",
      nvHarr: "\u2904",
      nvap: "\u224D\u20D2",
      nvdash: "\u22AC",
      nvge: "\u2265\u20D2",
      nvgt: ">\u20D2",
      nvinfin: "\u29DE",
      nvlArr: "\u2902",
      nvle: "\u2264\u20D2",
      nvlt: "<\u20D2",
      nvltrie: "\u22B4\u20D2",
      nvrArr: "\u2903",
      nvrtrie: "\u22B5\u20D2",
      nvsim: "\u223C\u20D2",
      nwArr: "\u21D6",
      nwarhk: "\u2923",
      nwarr: "\u2196",
      nwarrow: "\u2196",
      nwnear: "\u2927",
      oS: "\u24C8",
      oacut: "\xF3",
      oacute: "\xF3",
      oast: "\u229B",
      ocir: "\xF4",
      ocirc: "\xF4",
      ocy: "\u043E",
      odash: "\u229D",
      odblac: "\u0151",
      odiv: "\u2A38",
      odot: "\u2299",
      odsold: "\u29BC",
      oelig: "\u0153",
      ofcir: "\u29BF",
      ofr: "\u{1D52C}",
      ogon: "\u02DB",
      ograv: "\xF2",
      ograve: "\xF2",
      ogt: "\u29C1",
      ohbar: "\u29B5",
      ohm: "\u03A9",
      oint: "\u222E",
      olarr: "\u21BA",
      olcir: "\u29BE",
      olcross: "\u29BB",
      oline: "\u203E",
      olt: "\u29C0",
      omacr: "\u014D",
      omega: "\u03C9",
      omicron: "\u03BF",
      omid: "\u29B6",
      ominus: "\u2296",
      oopf: "\u{1D560}",
      opar: "\u29B7",
      operp: "\u29B9",
      oplus: "\u2295",
      or: "\u2228",
      orarr: "\u21BB",
      ord: "\xBA",
      order: "\u2134",
      orderof: "\u2134",
      ordf: "\xAA",
      ordm: "\xBA",
      origof: "\u22B6",
      oror: "\u2A56",
      orslope: "\u2A57",
      orv: "\u2A5B",
      oscr: "\u2134",
      oslas: "\xF8",
      oslash: "\xF8",
      osol: "\u2298",
      otild: "\xF5",
      otilde: "\xF5",
      otimes: "\u2297",
      otimesas: "\u2A36",
      oum: "\xF6",
      ouml: "\xF6",
      ovbar: "\u233D",
      par: "\xB6",
      para: "\xB6",
      parallel: "\u2225",
      parsim: "\u2AF3",
      parsl: "\u2AFD",
      part: "\u2202",
      pcy: "\u043F",
      percnt: "%",
      period: ".",
      permil: "\u2030",
      perp: "\u22A5",
      pertenk: "\u2031",
      pfr: "\u{1D52D}",
      phi: "\u03C6",
      phiv: "\u03D5",
      phmmat: "\u2133",
      phone: "\u260E",
      pi: "\u03C0",
      pitchfork: "\u22D4",
      piv: "\u03D6",
      planck: "\u210F",
      planckh: "\u210E",
      plankv: "\u210F",
      plus: "+",
      plusacir: "\u2A23",
      plusb: "\u229E",
      pluscir: "\u2A22",
      plusdo: "\u2214",
      plusdu: "\u2A25",
      pluse: "\u2A72",
      plusm: "\xB1",
      plusmn: "\xB1",
      plussim: "\u2A26",
      plustwo: "\u2A27",
      pm: "\xB1",
      pointint: "\u2A15",
      popf: "\u{1D561}",
      poun: "\xA3",
      pound: "\xA3",
      pr: "\u227A",
      prE: "\u2AB3",
      prap: "\u2AB7",
      prcue: "\u227C",
      pre: "\u2AAF",
      prec: "\u227A",
      precapprox: "\u2AB7",
      preccurlyeq: "\u227C",
      preceq: "\u2AAF",
      precnapprox: "\u2AB9",
      precneqq: "\u2AB5",
      precnsim: "\u22E8",
      precsim: "\u227E",
      prime: "\u2032",
      primes: "\u2119",
      prnE: "\u2AB5",
      prnap: "\u2AB9",
      prnsim: "\u22E8",
      prod: "\u220F",
      profalar: "\u232E",
      profline: "\u2312",
      profsurf: "\u2313",
      prop: "\u221D",
      propto: "\u221D",
      prsim: "\u227E",
      prurel: "\u22B0",
      pscr: "\u{1D4C5}",
      psi: "\u03C8",
      puncsp: "\u2008",
      qfr: "\u{1D52E}",
      qint: "\u2A0C",
      qopf: "\u{1D562}",
      qprime: "\u2057",
      qscr: "\u{1D4C6}",
      quaternions: "\u210D",
      quatint: "\u2A16",
      quest: "?",
      questeq: "\u225F",
      quo: '"',
      quot: '"',
      rAarr: "\u21DB",
      rArr: "\u21D2",
      rAtail: "\u291C",
      rBarr: "\u290F",
      rHar: "\u2964",
      race: "\u223D\u0331",
      racute: "\u0155",
      radic: "\u221A",
      raemptyv: "\u29B3",
      rang: "\u27E9",
      rangd: "\u2992",
      range: "\u29A5",
      rangle: "\u27E9",
      raqu: "\xBB",
      raquo: "\xBB",
      rarr: "\u2192",
      rarrap: "\u2975",
      rarrb: "\u21E5",
      rarrbfs: "\u2920",
      rarrc: "\u2933",
      rarrfs: "\u291E",
      rarrhk: "\u21AA",
      rarrlp: "\u21AC",
      rarrpl: "\u2945",
      rarrsim: "\u2974",
      rarrtl: "\u21A3",
      rarrw: "\u219D",
      ratail: "\u291A",
      ratio: "\u2236",
      rationals: "\u211A",
      rbarr: "\u290D",
      rbbrk: "\u2773",
      rbrace: "}",
      rbrack: "]",
      rbrke: "\u298C",
      rbrksld: "\u298E",
      rbrkslu: "\u2990",
      rcaron: "\u0159",
      rcedil: "\u0157",
      rceil: "\u2309",
      rcub: "}",
      rcy: "\u0440",
      rdca: "\u2937",
      rdldhar: "\u2969",
      rdquo: "\u201D",
      rdquor: "\u201D",
      rdsh: "\u21B3",
      real: "\u211C",
      realine: "\u211B",
      realpart: "\u211C",
      reals: "\u211D",
      rect: "\u25AD",
      re: "\xAE",
      reg: "\xAE",
      rfisht: "\u297D",
      rfloor: "\u230B",
      rfr: "\u{1D52F}",
      rhard: "\u21C1",
      rharu: "\u21C0",
      rharul: "\u296C",
      rho: "\u03C1",
      rhov: "\u03F1",
      rightarrow: "\u2192",
      rightarrowtail: "\u21A3",
      rightharpoondown: "\u21C1",
      rightharpoonup: "\u21C0",
      rightleftarrows: "\u21C4",
      rightleftharpoons: "\u21CC",
      rightrightarrows: "\u21C9",
      rightsquigarrow: "\u219D",
      rightthreetimes: "\u22CC",
      ring: "\u02DA",
      risingdotseq: "\u2253",
      rlarr: "\u21C4",
      rlhar: "\u21CC",
      rlm: "\u200F",
      rmoust: "\u23B1",
      rmoustache: "\u23B1",
      rnmid: "\u2AEE",
      roang: "\u27ED",
      roarr: "\u21FE",
      robrk: "\u27E7",
      ropar: "\u2986",
      ropf: "\u{1D563}",
      roplus: "\u2A2E",
      rotimes: "\u2A35",
      rpar: ")",
      rpargt: "\u2994",
      rppolint: "\u2A12",
      rrarr: "\u21C9",
      rsaquo: "\u203A",
      rscr: "\u{1D4C7}",
      rsh: "\u21B1",
      rsqb: "]",
      rsquo: "\u2019",
      rsquor: "\u2019",
      rthree: "\u22CC",
      rtimes: "\u22CA",
      rtri: "\u25B9",
      rtrie: "\u22B5",
      rtrif: "\u25B8",
      rtriltri: "\u29CE",
      ruluhar: "\u2968",
      rx: "\u211E",
      sacute: "\u015B",
      sbquo: "\u201A",
      sc: "\u227B",
      scE: "\u2AB4",
      scap: "\u2AB8",
      scaron: "\u0161",
      sccue: "\u227D",
      sce: "\u2AB0",
      scedil: "\u015F",
      scirc: "\u015D",
      scnE: "\u2AB6",
      scnap: "\u2ABA",
      scnsim: "\u22E9",
      scpolint: "\u2A13",
      scsim: "\u227F",
      scy: "\u0441",
      sdot: "\u22C5",
      sdotb: "\u22A1",
      sdote: "\u2A66",
      seArr: "\u21D8",
      searhk: "\u2925",
      searr: "\u2198",
      searrow: "\u2198",
      sec: "\xA7",
      sect: "\xA7",
      semi: ";",
      seswar: "\u2929",
      setminus: "\u2216",
      setmn: "\u2216",
      sext: "\u2736",
      sfr: "\u{1D530}",
      sfrown: "\u2322",
      sharp: "\u266F",
      shchcy: "\u0449",
      shcy: "\u0448",
      shortmid: "\u2223",
      shortparallel: "\u2225",
      sh: "\xAD",
      shy: "\xAD",
      sigma: "\u03C3",
      sigmaf: "\u03C2",
      sigmav: "\u03C2",
      sim: "\u223C",
      simdot: "\u2A6A",
      sime: "\u2243",
      simeq: "\u2243",
      simg: "\u2A9E",
      simgE: "\u2AA0",
      siml: "\u2A9D",
      simlE: "\u2A9F",
      simne: "\u2246",
      simplus: "\u2A24",
      simrarr: "\u2972",
      slarr: "\u2190",
      smallsetminus: "\u2216",
      smashp: "\u2A33",
      smeparsl: "\u29E4",
      smid: "\u2223",
      smile: "\u2323",
      smt: "\u2AAA",
      smte: "\u2AAC",
      smtes: "\u2AAC\uFE00",
      softcy: "\u044C",
      sol: "/",
      solb: "\u29C4",
      solbar: "\u233F",
      sopf: "\u{1D564}",
      spades: "\u2660",
      spadesuit: "\u2660",
      spar: "\u2225",
      sqcap: "\u2293",
      sqcaps: "\u2293\uFE00",
      sqcup: "\u2294",
      sqcups: "\u2294\uFE00",
      sqsub: "\u228F",
      sqsube: "\u2291",
      sqsubset: "\u228F",
      sqsubseteq: "\u2291",
      sqsup: "\u2290",
      sqsupe: "\u2292",
      sqsupset: "\u2290",
      sqsupseteq: "\u2292",
      squ: "\u25A1",
      square: "\u25A1",
      squarf: "\u25AA",
      squf: "\u25AA",
      srarr: "\u2192",
      sscr: "\u{1D4C8}",
      ssetmn: "\u2216",
      ssmile: "\u2323",
      sstarf: "\u22C6",
      star: "\u2606",
      starf: "\u2605",
      straightepsilon: "\u03F5",
      straightphi: "\u03D5",
      strns: "\xAF",
      sub: "\u2282",
      subE: "\u2AC5",
      subdot: "\u2ABD",
      sube: "\u2286",
      subedot: "\u2AC3",
      submult: "\u2AC1",
      subnE: "\u2ACB",
      subne: "\u228A",
      subplus: "\u2ABF",
      subrarr: "\u2979",
      subset: "\u2282",
      subseteq: "\u2286",
      subseteqq: "\u2AC5",
      subsetneq: "\u228A",
      subsetneqq: "\u2ACB",
      subsim: "\u2AC7",
      subsub: "\u2AD5",
      subsup: "\u2AD3",
      succ: "\u227B",
      succapprox: "\u2AB8",
      succcurlyeq: "\u227D",
      succeq: "\u2AB0",
      succnapprox: "\u2ABA",
      succneqq: "\u2AB6",
      succnsim: "\u22E9",
      succsim: "\u227F",
      sum: "\u2211",
      sung: "\u266A",
      sup: "\u2283",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      supE: "\u2AC6",
      supdot: "\u2ABE",
      supdsub: "\u2AD8",
      supe: "\u2287",
      supedot: "\u2AC4",
      suphsol: "\u27C9",
      suphsub: "\u2AD7",
      suplarr: "\u297B",
      supmult: "\u2AC2",
      supnE: "\u2ACC",
      supne: "\u228B",
      supplus: "\u2AC0",
      supset: "\u2283",
      supseteq: "\u2287",
      supseteqq: "\u2AC6",
      supsetneq: "\u228B",
      supsetneqq: "\u2ACC",
      supsim: "\u2AC8",
      supsub: "\u2AD4",
      supsup: "\u2AD6",
      swArr: "\u21D9",
      swarhk: "\u2926",
      swarr: "\u2199",
      swarrow: "\u2199",
      swnwar: "\u292A",
      szli: "\xDF",
      szlig: "\xDF",
      target: "\u2316",
      tau: "\u03C4",
      tbrk: "\u23B4",
      tcaron: "\u0165",
      tcedil: "\u0163",
      tcy: "\u0442",
      tdot: "\u20DB",
      telrec: "\u2315",
      tfr: "\u{1D531}",
      there4: "\u2234",
      therefore: "\u2234",
      theta: "\u03B8",
      thetasym: "\u03D1",
      thetav: "\u03D1",
      thickapprox: "\u2248",
      thicksim: "\u223C",
      thinsp: "\u2009",
      thkap: "\u2248",
      thksim: "\u223C",
      thor: "\xFE",
      thorn: "\xFE",
      tilde: "\u02DC",
      time: "\xD7",
      times: "\xD7",
      timesb: "\u22A0",
      timesbar: "\u2A31",
      timesd: "\u2A30",
      tint: "\u222D",
      toea: "\u2928",
      top: "\u22A4",
      topbot: "\u2336",
      topcir: "\u2AF1",
      topf: "\u{1D565}",
      topfork: "\u2ADA",
      tosa: "\u2929",
      tprime: "\u2034",
      trade: "\u2122",
      triangle: "\u25B5",
      triangledown: "\u25BF",
      triangleleft: "\u25C3",
      trianglelefteq: "\u22B4",
      triangleq: "\u225C",
      triangleright: "\u25B9",
      trianglerighteq: "\u22B5",
      tridot: "\u25EC",
      trie: "\u225C",
      triminus: "\u2A3A",
      triplus: "\u2A39",
      trisb: "\u29CD",
      tritime: "\u2A3B",
      trpezium: "\u23E2",
      tscr: "\u{1D4C9}",
      tscy: "\u0446",
      tshcy: "\u045B",
      tstrok: "\u0167",
      twixt: "\u226C",
      twoheadleftarrow: "\u219E",
      twoheadrightarrow: "\u21A0",
      uArr: "\u21D1",
      uHar: "\u2963",
      uacut: "\xFA",
      uacute: "\xFA",
      uarr: "\u2191",
      ubrcy: "\u045E",
      ubreve: "\u016D",
      ucir: "\xFB",
      ucirc: "\xFB",
      ucy: "\u0443",
      udarr: "\u21C5",
      udblac: "\u0171",
      udhar: "\u296E",
      ufisht: "\u297E",
      ufr: "\u{1D532}",
      ugrav: "\xF9",
      ugrave: "\xF9",
      uharl: "\u21BF",
      uharr: "\u21BE",
      uhblk: "\u2580",
      ulcorn: "\u231C",
      ulcorner: "\u231C",
      ulcrop: "\u230F",
      ultri: "\u25F8",
      umacr: "\u016B",
      um: "\xA8",
      uml: "\xA8",
      uogon: "\u0173",
      uopf: "\u{1D566}",
      uparrow: "\u2191",
      updownarrow: "\u2195",
      upharpoonleft: "\u21BF",
      upharpoonright: "\u21BE",
      uplus: "\u228E",
      upsi: "\u03C5",
      upsih: "\u03D2",
      upsilon: "\u03C5",
      upuparrows: "\u21C8",
      urcorn: "\u231D",
      urcorner: "\u231D",
      urcrop: "\u230E",
      uring: "\u016F",
      urtri: "\u25F9",
      uscr: "\u{1D4CA}",
      utdot: "\u22F0",
      utilde: "\u0169",
      utri: "\u25B5",
      utrif: "\u25B4",
      uuarr: "\u21C8",
      uum: "\xFC",
      uuml: "\xFC",
      uwangle: "\u29A7",
      vArr: "\u21D5",
      vBar: "\u2AE8",
      vBarv: "\u2AE9",
      vDash: "\u22A8",
      vangrt: "\u299C",
      varepsilon: "\u03F5",
      varkappa: "\u03F0",
      varnothing: "\u2205",
      varphi: "\u03D5",
      varpi: "\u03D6",
      varpropto: "\u221D",
      varr: "\u2195",
      varrho: "\u03F1",
      varsigma: "\u03C2",
      varsubsetneq: "\u228A\uFE00",
      varsubsetneqq: "\u2ACB\uFE00",
      varsupsetneq: "\u228B\uFE00",
      varsupsetneqq: "\u2ACC\uFE00",
      vartheta: "\u03D1",
      vartriangleleft: "\u22B2",
      vartriangleright: "\u22B3",
      vcy: "\u0432",
      vdash: "\u22A2",
      vee: "\u2228",
      veebar: "\u22BB",
      veeeq: "\u225A",
      vellip: "\u22EE",
      verbar: "|",
      vert: "|",
      vfr: "\u{1D533}",
      vltri: "\u22B2",
      vnsub: "\u2282\u20D2",
      vnsup: "\u2283\u20D2",
      vopf: "\u{1D567}",
      vprop: "\u221D",
      vrtri: "\u22B3",
      vscr: "\u{1D4CB}",
      vsubnE: "\u2ACB\uFE00",
      vsubne: "\u228A\uFE00",
      vsupnE: "\u2ACC\uFE00",
      vsupne: "\u228B\uFE00",
      vzigzag: "\u299A",
      wcirc: "\u0175",
      wedbar: "\u2A5F",
      wedge: "\u2227",
      wedgeq: "\u2259",
      weierp: "\u2118",
      wfr: "\u{1D534}",
      wopf: "\u{1D568}",
      wp: "\u2118",
      wr: "\u2240",
      wreath: "\u2240",
      wscr: "\u{1D4CC}",
      xcap: "\u22C2",
      xcirc: "\u25EF",
      xcup: "\u22C3",
      xdtri: "\u25BD",
      xfr: "\u{1D535}",
      xhArr: "\u27FA",
      xharr: "\u27F7",
      xi: "\u03BE",
      xlArr: "\u27F8",
      xlarr: "\u27F5",
      xmap: "\u27FC",
      xnis: "\u22FB",
      xodot: "\u2A00",
      xopf: "\u{1D569}",
      xoplus: "\u2A01",
      xotime: "\u2A02",
      xrArr: "\u27F9",
      xrarr: "\u27F6",
      xscr: "\u{1D4CD}",
      xsqcup: "\u2A06",
      xuplus: "\u2A04",
      xutri: "\u25B3",
      xvee: "\u22C1",
      xwedge: "\u22C0",
      yacut: "\xFD",
      yacute: "\xFD",
      yacy: "\u044F",
      ycirc: "\u0177",
      ycy: "\u044B",
      ye: "\xA5",
      yen: "\xA5",
      yfr: "\u{1D536}",
      yicy: "\u0457",
      yopf: "\u{1D56A}",
      yscr: "\u{1D4CE}",
      yucy: "\u044E",
      yum: "\xFF",
      yuml: "\xFF",
      zacute: "\u017A",
      zcaron: "\u017E",
      zcy: "\u0437",
      zdot: "\u017C",
      zeetrf: "\u2128",
      zeta: "\u03B6",
      zfr: "\u{1D537}",
      zhcy: "\u0436",
      zigrarr: "\u21DD",
      zopf: "\u{1D56B}",
      zscr: "\u{1D4CF}",
      zwj: "\u200D",
      zwnj: "\u200C"
    };
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/parse-entities-npm-2.0.0-b7b4f46ff6-6a9213216b.zip/node_modules/parse-entities/decode-entity.js
var require_decode_entity = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/parse-entities-npm-2.0.0-b7b4f46ff6-6a9213216b.zip/node_modules/parse-entities/decode-entity.js"(exports, module2) {
    "use strict";
    var characterEntities2 = require_character_entities();
    module2.exports = decodeEntity2;
    var own9 = {}.hasOwnProperty;
    function decodeEntity2(characters2) {
      return own9.call(characterEntities2, characters2) ? characterEntities2[characters2] : false;
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/parse-entities-npm-2.0.0-b7b4f46ff6-6a9213216b.zip/node_modules/parse-entities/index.js
var require_parse_entities = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/parse-entities-npm-2.0.0-b7b4f46ff6-6a9213216b.zip/node_modules/parse-entities/index.js"(exports, module2) {
    "use strict";
    var legacy = require_character_entities_legacy();
    var invalid2 = require_character_reference_invalid();
    var decimal = require_is_decimal();
    var hexadecimal = require_is_hexadecimal();
    var alphanumerical = require_is_alphanumerical();
    var decodeEntity2 = require_decode_entity();
    module2.exports = parseEntities2;
    var own9 = {}.hasOwnProperty;
    var fromCharCode2 = String.fromCharCode;
    var noop = Function.prototype;
    var defaults = {
      warning: null,
      reference: null,
      text: null,
      warningContext: null,
      referenceContext: null,
      textContext: null,
      position: {},
      additional: null,
      attribute: false,
      nonTerminated: true
    };
    var tab = 9;
    var lineFeed = 10;
    var formFeed = 12;
    var space = 32;
    var ampersand = 38;
    var semicolon = 59;
    var lessThan = 60;
    var equalsTo = 61;
    var numberSign = 35;
    var uppercaseX = 88;
    var lowercaseX = 120;
    var replacementCharacter = 65533;
    var name2 = "named";
    var hexa = "hexadecimal";
    var deci = "decimal";
    var bases = {};
    bases[hexa] = 16;
    bases[deci] = 10;
    var tests = {};
    tests[name2] = alphanumerical;
    tests[deci] = decimal;
    tests[hexa] = hexadecimal;
    var namedNotTerminated = 1;
    var numericNotTerminated = 2;
    var namedEmpty = 3;
    var numericEmpty = 4;
    var namedUnknown = 5;
    var numericDisallowed = 6;
    var numericProhibited = 7;
    var messages = {};
    messages[namedNotTerminated] = "Named character references must be terminated by a semicolon";
    messages[numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
    messages[namedEmpty] = "Named character references cannot be empty";
    messages[numericEmpty] = "Numeric character references cannot be empty";
    messages[namedUnknown] = "Named character references must be known";
    messages[numericDisallowed] = "Numeric character references cannot be disallowed";
    messages[numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
    function parseEntities2(value, options) {
      var settings = {};
      var option;
      var key2;
      if (!options) {
        options = {};
      }
      for (key2 in defaults) {
        option = options[key2];
        settings[key2] = option === null || option === void 0 ? defaults[key2] : option;
      }
      if (settings.position.indent || settings.position.start) {
        settings.indent = settings.position.indent || [];
        settings.position = settings.position.start;
      }
      return parse3(value, settings);
    }
    function parse3(value, settings) {
      var additional = settings.additional;
      var nonTerminated = settings.nonTerminated;
      var handleText = settings.text;
      var handleReference = settings.reference;
      var handleWarning = settings.warning;
      var textContext = settings.textContext;
      var referenceContext = settings.referenceContext;
      var warningContext = settings.warningContext;
      var pos = settings.position;
      var indent2 = settings.indent || [];
      var length = value.length;
      var index2 = 0;
      var lines = -1;
      var column = pos.column || 1;
      var line = pos.line || 1;
      var queue = "";
      var result = [];
      var entityCharacters;
      var namedEntity;
      var terminated;
      var characters2;
      var character;
      var reference;
      var following;
      var warning;
      var reason;
      var output;
      var entity;
      var begin;
      var start;
      var type;
      var test;
      var prev;
      var next;
      var diff;
      var end;
      if (typeof additional === "string") {
        additional = additional.charCodeAt(0);
      }
      prev = now();
      warning = handleWarning ? parseError : noop;
      index2--;
      length++;
      while (++index2 < length) {
        if (character === lineFeed) {
          column = indent2[lines] || 1;
        }
        character = value.charCodeAt(index2);
        if (character === ampersand) {
          following = value.charCodeAt(index2 + 1);
          if (following === tab || following === lineFeed || following === formFeed || following === space || following === ampersand || following === lessThan || following !== following || additional && following === additional) {
            queue += fromCharCode2(character);
            column++;
            continue;
          }
          start = index2 + 1;
          begin = start;
          end = start;
          if (following === numberSign) {
            end = ++begin;
            following = value.charCodeAt(end);
            if (following === uppercaseX || following === lowercaseX) {
              type = hexa;
              end = ++begin;
            } else {
              type = deci;
            }
          } else {
            type = name2;
          }
          entityCharacters = "";
          entity = "";
          characters2 = "";
          test = tests[type];
          end--;
          while (++end < length) {
            following = value.charCodeAt(end);
            if (!test(following)) {
              break;
            }
            characters2 += fromCharCode2(following);
            if (type === name2 && own9.call(legacy, characters2)) {
              entityCharacters = characters2;
              entity = legacy[characters2];
            }
          }
          terminated = value.charCodeAt(end) === semicolon;
          if (terminated) {
            end++;
            namedEntity = type === name2 ? decodeEntity2(characters2) : false;
            if (namedEntity) {
              entityCharacters = characters2;
              entity = namedEntity;
            }
          }
          diff = 1 + end - start;
          if (!terminated && !nonTerminated) {
          } else if (!characters2) {
            if (type !== name2) {
              warning(numericEmpty, diff);
            }
          } else if (type === name2) {
            if (terminated && !entity) {
              warning(namedUnknown, 1);
            } else {
              if (entityCharacters !== characters2) {
                end = begin + entityCharacters.length;
                diff = 1 + end - begin;
                terminated = false;
              }
              if (!terminated) {
                reason = entityCharacters ? namedNotTerminated : namedEmpty;
                if (settings.attribute) {
                  following = value.charCodeAt(end);
                  if (following === equalsTo) {
                    warning(reason, diff);
                    entity = null;
                  } else if (alphanumerical(following)) {
                    entity = null;
                  } else {
                    warning(reason, diff);
                  }
                } else {
                  warning(reason, diff);
                }
              }
            }
            reference = entity;
          } else {
            if (!terminated) {
              warning(numericNotTerminated, diff);
            }
            reference = parseInt(characters2, bases[type]);
            if (prohibited(reference)) {
              warning(numericProhibited, diff);
              reference = fromCharCode2(replacementCharacter);
            } else if (reference in invalid2) {
              warning(numericDisallowed, diff);
              reference = invalid2[reference];
            } else {
              output = "";
              if (disallowed(reference)) {
                warning(numericDisallowed, diff);
              }
              if (reference > 65535) {
                reference -= 65536;
                output += fromCharCode2(reference >>> (10 & 1023) | 55296);
                reference = 56320 | reference & 1023;
              }
              reference = output + fromCharCode2(reference);
            }
          }
          if (reference) {
            flush();
            prev = now();
            index2 = end - 1;
            column += end - start + 1;
            result.push(reference);
            next = now();
            next.offset++;
            if (handleReference) {
              handleReference.call(referenceContext, reference, { start: prev, end: next }, value.slice(start - 1, end));
            }
            prev = next;
          } else {
            characters2 = value.slice(start - 1, end);
            queue += characters2;
            column += characters2.length;
            index2 = end - 1;
          }
        } else {
          if (character === 10) {
            line++;
            lines++;
            column = 0;
          }
          if (character === character) {
            queue += fromCharCode2(character);
            column++;
          } else {
            flush();
          }
        }
      }
      return result.join("");
      function now() {
        return {
          line,
          column,
          offset: index2 + (pos.offset || 0)
        };
      }
      function parseError(code2, offset) {
        var position2 = now();
        position2.column += offset;
        position2.offset += offset;
        handleWarning.call(warningContext, messages[code2], position2, code2);
      }
      function flush() {
        if (queue) {
          result.push(queue);
          if (handleText) {
            handleText.call(textContext, queue, { start: prev, end: now() });
          }
          queue = "";
        }
      }
    }
    function prohibited(code2) {
      return code2 >= 55296 && code2 <= 57343 || code2 > 1114111;
    }
    function disallowed(code2) {
      return code2 >= 1 && code2 <= 8 || code2 === 11 || code2 >= 13 && code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 64976 && code2 <= 65007 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534;
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-jsx-npm-0.1.4-9b3b528ea4-4696aafb01.zip/node_modules/mdast-util-mdx-jsx/from-markdown.js
var require_from_markdown2 = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-jsx-npm-0.1.4-9b3b528ea4-4696aafb01.zip/node_modules/mdast-util-mdx-jsx/from-markdown.js"(exports) {
    exports.canContainEols = ["mdxJsxTextElement"];
    exports.enter = {
      mdxJsxFlowTag: enterMdxJsxTag,
      mdxJsxFlowTagClosingMarker: enterMdxJsxTagClosingMarker,
      mdxJsxFlowTagAttribute: enterMdxJsxTagAttribute,
      mdxJsxFlowTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
      mdxJsxFlowTagAttributeValueLiteral: buffer2,
      mdxJsxFlowTagAttributeValueExpression: buffer2,
      mdxJsxFlowTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker,
      mdxJsxTextTag: enterMdxJsxTag,
      mdxJsxTextTagClosingMarker: enterMdxJsxTagClosingMarker,
      mdxJsxTextTagAttribute: enterMdxJsxTagAttribute,
      mdxJsxTextTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
      mdxJsxTextTagAttributeValueLiteral: buffer2,
      mdxJsxTextTagAttributeValueExpression: buffer2,
      mdxJsxTextTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker
    };
    exports.exit = {
      mdxJsxFlowTagClosingMarker: exitMdxJsxTagClosingMarker,
      mdxJsxFlowTagNamePrimary: exitMdxJsxTagNamePrimary,
      mdxJsxFlowTagNameMember: exitMdxJsxTagNameMember,
      mdxJsxFlowTagNameLocal: exitMdxJsxTagNameLocal,
      mdxJsxFlowTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
      mdxJsxFlowTagExpressionAttributeValue: data,
      mdxJsxFlowTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
      mdxJsxFlowTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
      mdxJsxFlowTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
      mdxJsxFlowTagAttributeValueLiteralValue: data,
      mdxJsxFlowTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
      mdxJsxFlowTagAttributeValueExpressionValue: data,
      mdxJsxFlowTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
      mdxJsxFlowTag: exitMdxJsxTag,
      mdxJsxTextTagClosingMarker: exitMdxJsxTagClosingMarker,
      mdxJsxTextTagNamePrimary: exitMdxJsxTagNamePrimary,
      mdxJsxTextTagNameMember: exitMdxJsxTagNameMember,
      mdxJsxTextTagNameLocal: exitMdxJsxTagNameLocal,
      mdxJsxTextTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
      mdxJsxTextTagExpressionAttributeValue: data,
      mdxJsxTextTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
      mdxJsxTextTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
      mdxJsxTextTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
      mdxJsxTextTagAttributeValueLiteralValue: data,
      mdxJsxTextTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
      mdxJsxTextTagAttributeValueExpressionValue: data,
      mdxJsxTextTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
      mdxJsxTextTag: exitMdxJsxTag
    };
    var parseEntities2 = require_parse_entities();
    var stringifyPosition2 = require_unist_util_stringify_position();
    var VMessage = require_vfile_message();
    function buffer2() {
      this.buffer();
    }
    function data(token) {
      this.config.enter.data.call(this, token);
      this.config.exit.data.call(this, token);
    }
    function enterMdxJsxTag(token) {
      if (!this.getData("mdxJsxTagStack"))
        this.setData("mdxJsxTagStack", []);
      this.setData("mdxJsxTag", {
        name: null,
        attributes: [],
        start: token.start,
        end: token.end
      });
      this.buffer();
    }
    function enterMdxJsxTagClosingMarker(token) {
      if (!this.getData("mdxJsxTagStack").length) {
        throw new VMessage("Unexpected closing slash `/` in tag, expected an open tag first", { start: token.start, end: token.end }, "mdast-util-mdx-jsx:unexpected-closing-slash");
      }
    }
    function enterMdxJsxTagAnyAttribute(token) {
      if (this.getData("mdxJsxTag").close) {
        throw new VMessage("Unexpected attribute in closing tag, expected the end of the tag", { start: token.start, end: token.end }, "mdast-util-mdx-jsx:unexpected-attribute");
      }
    }
    function enterMdxJsxTagSelfClosingMarker(token) {
      if (this.getData("mdxJsxTag").close) {
        throw new VMessage("Unexpected self-closing slash `/` in closing tag, expected the end of the tag", { start: token.start, end: token.end }, "mdast-util-mdx-jsx:unexpected-self-closing-slash");
      }
    }
    function exitMdxJsxTagClosingMarker() {
      this.getData("mdxJsxTag").close = true;
    }
    function exitMdxJsxTagNamePrimary(token) {
      this.getData("mdxJsxTag").name = this.sliceSerialize(token);
    }
    function exitMdxJsxTagNameMember(token) {
      this.getData("mdxJsxTag").name += "." + this.sliceSerialize(token);
    }
    function exitMdxJsxTagNameLocal(token) {
      this.getData("mdxJsxTag").name += ":" + this.sliceSerialize(token);
    }
    function enterMdxJsxTagAttribute(token) {
      enterMdxJsxTagAnyAttribute.call(this, token);
      this.getData("mdxJsxTag").attributes.push({
        type: "mdxJsxAttribute",
        name: null,
        value: null
      });
    }
    function enterMdxJsxTagExpressionAttribute(token) {
      enterMdxJsxTagAnyAttribute.call(this, token);
      this.getData("mdxJsxTag").attributes.push({
        type: "mdxJsxExpressionAttribute",
        value: null
      });
      this.buffer();
    }
    function exitMdxJsxTagExpressionAttribute(token) {
      var attributes = this.getData("mdxJsxTag").attributes;
      attributes[attributes.length - 1].value = this.resume();
      if (token.estree) {
        attributes[attributes.length - 1].data = { estree: token.estree };
      }
    }
    function exitMdxJsxTagAttributeNamePrimary(token) {
      var attributes = this.getData("mdxJsxTag").attributes;
      attributes[attributes.length - 1].name = this.sliceSerialize(token);
    }
    function exitMdxJsxTagAttributeNameLocal(token) {
      var attributes = this.getData("mdxJsxTag").attributes;
      attributes[attributes.length - 1].name += ":" + this.sliceSerialize(token);
    }
    function exitMdxJsxTagAttributeValueLiteral() {
      var attributes = this.getData("mdxJsxTag").attributes;
      attributes[attributes.length - 1].value = parseEntities2(this.resume(), {
        nonTerminated: false
      });
    }
    function exitMdxJsxTagAttributeValueExpression(token) {
      var attributes = this.getData("mdxJsxTag").attributes;
      attributes[attributes.length - 1].value = {
        type: "mdxJsxAttributeValueExpression",
        value: this.resume()
      };
      if (token.estree) {
        attributes[attributes.length - 1].value.data = { estree: token.estree };
      }
    }
    function exitMdxJsxTagSelfClosingMarker() {
      this.getData("mdxJsxTag").selfClosing = true;
    }
    function exitMdxJsxTag(token) {
      var tag = this.getData("mdxJsxTag");
      var stack = this.getData("mdxJsxTagStack");
      var tail = stack[stack.length - 1];
      if (tag.close && tail.name !== tag.name) {
        throw new VMessage("Unexpected closing tag `" + serializeAbbreviatedTag(tag) + "`, expected corresponding closing tag for `" + serializeAbbreviatedTag(tail) + "` (" + stringifyPosition2(tail) + ")", { start: token.start, end: token.end }, "mdast-util-mdx-jsx:end-tag-mismatch");
      }
      this.resume();
      if (tag.close) {
        stack.pop();
      } else {
        this.enter({
          type: token.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
          name: tag.name,
          attributes: tag.attributes,
          children: []
        }, token);
      }
      if (tag.selfClosing || tag.close) {
        this.exit(token);
      } else {
        stack.push(tag);
      }
    }
    function serializeAbbreviatedTag(tag) {
      return "<" + (tag.close ? "/" : "") + (tag.name || "") + ">";
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdxjs-esm-npm-0.1.1-6ed831297c-1e7d1fad93.zip/node_modules/mdast-util-mdxjs-esm/from-markdown.js
var require_from_markdown3 = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdxjs-esm-npm-0.1.1-6ed831297c-1e7d1fad93.zip/node_modules/mdast-util-mdxjs-esm/from-markdown.js"(exports) {
    exports.enter = { mdxjsEsm: enterMdxjsEsm };
    exports.exit = { mdxjsEsm: exitMdxjsEsm, mdxjsEsmData: exitMdxjsEsmData };
    function enterMdxjsEsm(token) {
      this.enter({ type: "mdxjsEsm", value: "" }, token);
      this.buffer();
    }
    function exitMdxjsEsm(token) {
      var value = this.resume();
      var node = this.exit(token);
      node.value = value;
      if (token.estree) {
        node.data = { estree: token.estree };
      }
    }
    function exitMdxjsEsmData(token) {
      this.config.enter.data.call(this, token);
      this.config.exit.data.call(this, token);
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-npm-0.1.1-b4302a7b4b-936cb35650.zip/node_modules/mdast-util-mdx/from-markdown.js
var require_from_markdown4 = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-npm-0.1.1-b4302a7b4b-936cb35650.zip/node_modules/mdast-util-mdx/from-markdown.js"(exports, module2) {
    var expression = require_from_markdown();
    var jsx = require_from_markdown2();
    var esm = require_from_markdown3();
    var own9 = {}.hasOwnProperty;
    module2.exports = configure3([expression, jsx, esm]);
    function configure3(extensions) {
      var config = { canContainEols: [] };
      var index2 = -1;
      while (++index2 < extensions.length) {
        extension2(config, extensions[index2]);
      }
      return config;
    }
    function extension2(config, extension3) {
      var key2;
      var left;
      var right;
      for (key2 in extension3) {
        left = own9.call(config, key2) ? config[key2] : config[key2] = {};
        right = extension3[key2];
        if (key2 === "canContainEols") {
          config[key2] = [].concat(left, right);
        } else {
          Object.assign(left, right);
        }
      }
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-expression-npm-0.1.1-6e8466fe5d-4684cc22b1.zip/node_modules/mdast-util-mdx-expression/to-markdown.js
var require_to_markdown = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-expression-npm-0.1.1-6e8466fe5d-4684cc22b1.zip/node_modules/mdast-util-mdx-expression/to-markdown.js"(exports) {
    exports.handlers = {
      mdxFlowExpression: handleMdxExpression2,
      mdxTextExpression: handleMdxExpression2
    };
    exports.unsafe = [
      { character: "{", inConstruct: ["phrasing"] },
      { atBreak: true, character: "{" }
    ];
    var eol2 = /\r?\n|\r/g;
    function handleMdxExpression2(node) {
      var value = node.value || "";
      return "{" + (node.type === "mdxFlowExpression" ? indent2(value) : value) + "}";
    }
    function indent2(value) {
      var result = [];
      var start = 0;
      var line = 0;
      var match;
      while (match = eol2.exec(value)) {
        one2(value.slice(start, match.index));
        result.push(match[0]);
        start = match.index + match[0].length;
        line++;
      }
      one2(value.slice(start));
      return result.join("");
      function one2(slice) {
        result.push((line && slice ? "  " : "") + slice);
      }
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-3.1.0-78dc656761-4d33442e56.zip/node_modules/stringify-entities/lib/core.js
var require_core = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-3.1.0-78dc656761-4d33442e56.zip/node_modules/stringify-entities/lib/core.js"(exports, module2) {
    "use strict";
    module2.exports = encode;
    function encode(value, options) {
      value = value.replace(options.subset ? charactersToExpression2(options.subset) : /["&'<>`]/g, basic);
      if (options.subset || options.escapeOnly) {
        return value;
      }
      return value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(/[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g, basic);
      function surrogate(pair, index2, all2) {
        return options.format((pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536, all2.charCodeAt(index2 + 2), options);
      }
      function basic(character, index2, all2) {
        return options.format(character.charCodeAt(0), all2.charCodeAt(index2 + 1), options);
      }
    }
    function charactersToExpression2(subset) {
      var groups = [];
      var index2 = -1;
      while (++index2 < subset.length) {
        groups.push(subset[index2].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
      }
      return new RegExp("(?:" + groups.join("|") + ")", "g");
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-3.1.0-78dc656761-4d33442e56.zip/node_modules/stringify-entities/lib/constant/assign.js
var require_assign = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-3.1.0-78dc656761-4d33442e56.zip/node_modules/stringify-entities/lib/constant/assign.js"(exports, module2) {
    module2.exports = Object.assign;
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-3.1.0-78dc656761-4d33442e56.zip/node_modules/stringify-entities/lib/util/format-basic.js
var require_format_basic = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-3.1.0-78dc656761-4d33442e56.zip/node_modules/stringify-entities/lib/util/format-basic.js"(exports, module2) {
    module2.exports = formatBasic2;
    function formatBasic2(code2) {
      return "&#x" + code2.toString(16).toUpperCase() + ";";
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-3.1.0-78dc656761-4d33442e56.zip/node_modules/stringify-entities/lib/encode-hexadecimal.js
var require_encode_hexadecimal = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-3.1.0-78dc656761-4d33442e56.zip/node_modules/stringify-entities/lib/encode-hexadecimal.js"(exports, module2) {
    "use strict";
    var core2 = require_core();
    var assign = require_assign();
    var basic = require_format_basic();
    module2.exports = encodeHexadecimal;
    function encodeHexadecimal(value, options) {
      return core2(value, assign({ format: basic }, options));
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-3.1.0-78dc656761-4d33442e56.zip/node_modules/stringify-entities/light.js
var require_light = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-3.1.0-78dc656761-4d33442e56.zip/node_modules/stringify-entities/light.js"(exports, module2) {
    "use strict";
    module2.exports = require_encode_hexadecimal();
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/repeat-string-npm-1.6.1-bc8e388655-99c431ba7b.zip/node_modules/repeat-string/index.js
var require_repeat_string = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/repeat-string-npm-1.6.1-bc8e388655-99c431ba7b.zip/node_modules/repeat-string/index.js"(exports, module2) {
    "use strict";
    var res = "";
    var cache;
    module2.exports = repeat;
    function repeat(str, num) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (num === 1)
        return str;
      if (num === 2)
        return str + str;
      var max = str.length * num;
      if (cache !== str || typeof cache === "undefined") {
        cache = str;
        res = "";
      } else if (res.length >= max) {
        return res.substr(0, max);
      }
      while (max > res.length && num > 1) {
        if (num & 1) {
          res += str;
        }
        num >>= 1;
        str += str;
      }
      res += str;
      res = res.substr(0, max);
      return res;
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-0.6.5-6da59c9db9-c5db77398c.zip/node_modules/mdast-util-to-markdown/lib/util/container-flow.js
var require_container_flow = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-0.6.5-6da59c9db9-c5db77398c.zip/node_modules/mdast-util-to-markdown/lib/util/container-flow.js"(exports, module2) {
    module2.exports = flow3;
    var repeat = require_repeat_string();
    function flow3(parent, context) {
      var children = parent.children || [];
      var results = [];
      var index2 = -1;
      var child;
      while (++index2 < children.length) {
        child = children[index2];
        results.push(context.handle(child, parent, context, { before: "\n", after: "\n" }));
        if (index2 + 1 < children.length) {
          results.push(between(child, children[index2 + 1]));
        }
      }
      return results.join("");
      function between(left, right) {
        var index3 = -1;
        var result;
        while (++index3 < context.join.length) {
          result = context.join[index3](left, right, parent, context);
          if (result === true || result === 1) {
            break;
          }
          if (typeof result === "number") {
            return repeat("\n", 1 + Number(result));
          }
          if (result === false) {
            return "\n\n<!---->\n\n";
          }
        }
        return "\n\n";
      }
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-0.6.5-6da59c9db9-c5db77398c.zip/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
var require_container_phrasing = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-0.6.5-6da59c9db9-c5db77398c.zip/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js"(exports, module2) {
    module2.exports = phrasing;
    function phrasing(parent, context, safeOptions) {
      var children = parent.children || [];
      var results = [];
      var index2 = -1;
      var before = safeOptions.before;
      var after;
      var handle2;
      var child;
      while (++index2 < children.length) {
        child = children[index2];
        if (index2 + 1 < children.length) {
          handle2 = context.handle.handlers[children[index2 + 1].type];
          if (handle2 && handle2.peek)
            handle2 = handle2.peek;
          after = handle2 ? handle2(children[index2 + 1], parent, context, {
            before: "",
            after: ""
          }).charAt(0) : "";
        } else {
          after = safeOptions.after;
        }
        if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
          results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, " ");
          before = " ";
        }
        results.push(context.handle(child, parent, context, {
          before,
          after
        }));
        before = results[results.length - 1].slice(-1);
      }
      return results.join("");
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-0.6.5-6da59c9db9-c5db77398c.zip/node_modules/mdast-util-to-markdown/lib/util/check-quote.js
var require_check_quote = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-0.6.5-6da59c9db9-c5db77398c.zip/node_modules/mdast-util-to-markdown/lib/util/check-quote.js"(exports, module2) {
    module2.exports = checkQuote2;
    function checkQuote2(context) {
      var marker = context.options.quote || '"';
      if (marker !== '"' && marker !== "'") {
        throw new Error("Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`");
      }
      return marker;
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-jsx-npm-0.1.4-9b3b528ea4-4696aafb01.zip/node_modules/mdast-util-mdx-jsx/to-markdown.js
var require_to_markdown2 = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-jsx-npm-0.1.4-9b3b528ea4-4696aafb01.zip/node_modules/mdast-util-mdx-jsx/to-markdown.js"(exports) {
    exports.handlers = {
      mdxJsxFlowElement: mdxElement2,
      mdxJsxTextElement: mdxElement2
    };
    exports.unsafe = [
      { character: "<", inConstruct: ["phrasing"] },
      { atBreak: true, character: "<" }
    ];
    exports.fences = true;
    exports.resourceLink = true;
    mdxElement2.peek = peekElement2;
    var encode = require_light();
    var flow3 = require_container_flow();
    var phrasing = require_container_phrasing();
    var checkQuote2 = require_check_quote();
    var eol2 = /\r?\n|\r/g;
    function mdxElement2(node, _6, context) {
      var selfClosing = node.name && (!node.children || !node.children.length);
      var quote = checkQuote2(context);
      var exit2 = context.enter(node.type);
      var index2 = -1;
      var attributes = [];
      var attribute;
      var result;
      var value;
      if (node.attributes && node.attributes.length) {
        if (!node.name) {
          throw new Error("Cannot serialize fragment w/ attributes");
        }
        while (++index2 < node.attributes.length) {
          attribute = node.attributes[index2];
          if (attribute.type === "mdxJsxExpressionAttribute") {
            result = "{" + (attribute.value || "") + "}";
          } else {
            if (!attribute.name) {
              throw new Error("Cannot serialize attribute w/o name");
            }
            result = attribute.name + (attribute.value == null ? "" : "=" + (typeof attribute.value === "object" ? "{" + (attribute.value.value || "") + "}" : quote + encode(attribute.value, { subset: [quote] }) + quote));
          }
          attributes.push(result);
        }
      }
      value = "<" + (node.name || "") + (node.type === "mdxJsxFlowElement" && attributes.length > 1 ? "\n" + indent2(attributes.join("\n")) + "\n" : attributes.length ? " " + dedentStart(indent2(attributes.join(" "))) : "") + (selfClosing ? "/" : "") + ">" + (node.children && node.children.length ? node.type === "mdxJsxFlowElement" ? "\n" + indent2(flow3(node, context)) + "\n" : phrasing(node, context, { before: "<", after: ">" }) : "") + (selfClosing ? "" : "</" + (node.name || "") + ">");
      exit2();
      return value;
    }
    function peekElement2() {
      return "<";
    }
    function dedentStart(value) {
      return value.replace(/^ +/, "");
    }
    function indent2(value) {
      var result = [];
      var start = 0;
      var match;
      while (match = eol2.exec(value)) {
        one2(value.slice(start, match.index));
        result.push(match[0]);
        start = match.index + match[0].length;
      }
      one2(value.slice(start));
      return result.join("");
      function one2(slice) {
        result.push((slice ? "  " : "") + slice);
      }
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdxjs-esm-npm-0.1.1-6ed831297c-1e7d1fad93.zip/node_modules/mdast-util-mdxjs-esm/to-markdown.js
var require_to_markdown3 = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdxjs-esm-npm-0.1.1-6ed831297c-1e7d1fad93.zip/node_modules/mdast-util-mdxjs-esm/to-markdown.js"(exports) {
    exports.handlers = { mdxjsEsm: handleMdxjsEsm2 };
    function handleMdxjsEsm2(node) {
      return node.value || "";
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-0.6.5-6da59c9db9-c5db77398c.zip/node_modules/mdast-util-to-markdown/lib/configure.js
var require_configure = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-0.6.5-6da59c9db9-c5db77398c.zip/node_modules/mdast-util-to-markdown/lib/configure.js"(exports, module2) {
    module2.exports = configure3;
    function configure3(base2, extension2) {
      var index2 = -1;
      var key2;
      if (extension2.extensions) {
        while (++index2 < extension2.extensions.length) {
          configure3(base2, extension2.extensions[index2]);
        }
      }
      for (key2 in extension2) {
        if (key2 === "extensions") {
        } else if (key2 === "unsafe" || key2 === "join") {
          base2[key2] = base2[key2].concat(extension2[key2] || []);
        } else if (key2 === "handlers") {
          base2[key2] = Object.assign(base2[key2], extension2[key2] || {});
        } else {
          base2.options[key2] = extension2[key2];
        }
      }
      return base2;
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-npm-0.1.1-b4302a7b4b-936cb35650.zip/node_modules/mdast-util-mdx/to-markdown.js
var require_to_markdown4 = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-npm-0.1.1-b4302a7b4b-936cb35650.zip/node_modules/mdast-util-mdx/to-markdown.js"(exports, module2) {
    var expression = require_to_markdown();
    var jsx = require_to_markdown2();
    var esm = require_to_markdown3();
    var configure3 = require_configure();
    var base2 = configure3({ handlers: {}, join: [], unsafe: [], options: {} }, { extensions: [expression, jsx, esm] });
    module2.exports = Object.assign(base2.options, {
      handlers: base2.handlers,
      join: base2.join,
      unsafe: base2.unsafe
    });
  }
});

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/remark-mdx-npm-2.0.0-next.9-5ab0d4aa88-ce8463ab6c.zip/node_modules/remark-mdx/index.js
var require_remark_mdx = __commonJS({
  "pnp:/Users/jeffsee/code/tinacms/.yarn/cache/remark-mdx-npm-2.0.0-next.9-5ab0d4aa88-ce8463ab6c.zip/node_modules/remark-mdx/index.js"(exports, module2) {
    "use strict";
    var syntaxMdx = require_micromark_extension_mdx();
    var syntaxMdxjs = require_micromark_extension_mdxjs();
    var fromMarkdown2 = require_from_markdown4();
    var toMarkdown2 = require_to_markdown4();
    var warningIssued;
    module2.exports = mdx2;
    function mdx2(options) {
      let settings = options || {};
      let syntax = settings.js === false ? syntaxMdx : syntaxMdxjs;
      let data = this.data();
      if (!warningIssued && (this.Parser && this.Parser.prototype && this.Parser.prototype.blockTokenizers || this.Compiler && this.Compiler.prototype && this.Compiler.prototype.visitors)) {
        warningIssued = true;
        console.warn("[remark-mdx] Warning: please upgrade to remark 13 to use this plugin");
      }
      add("micromarkExtensions", syntax(options));
      add("fromMarkdownExtensions", fromMarkdown2);
      add("toMarkdownExtensions", toMarkdown2);
      function add(field, value) {
        if (data[field])
          data[field].push(value);
        else
          data[field] = [value];
      }
    }
  }
});

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/index.ts
__export(exports, {
  assertShape: () => assertShape,
  buildSchema: () => buildSchema,
  createDatabase: () => createDatabase,
  indexDB: () => indexDB,
  parseFile: () => parseFile,
  resolve: () => resolve,
  sequential: () => sequential,
  stringifyFile: () => stringifyFile
});
var import_fs_extra2 = __toModule(require("fs-extra"));
var import_path5 = __toModule(require("path"));
var import_graphql5 = __toModule(require("graphql"));

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/build.ts
var import_lodash3 = __toModule(require("lodash"));
var import_fs_extra = __toModule(require("fs-extra"));
var import_graphql2 = __toModule(require("graphql"));

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/ast-builder/index.ts
var import_lodash = __toModule(require("lodash"));
var SysFieldDefinition = {
  kind: "Field",
  name: {
    kind: "Name",
    value: "sys"
  },
  arguments: [],
  directives: [],
  selectionSet: {
    kind: "SelectionSet",
    selections: [
      {
        kind: "Field",
        name: {
          kind: "Name",
          value: "filename"
        },
        arguments: [],
        directives: []
      },
      {
        kind: "Field",
        name: {
          kind: "Name",
          value: "basename"
        },
        arguments: [],
        directives: []
      },
      {
        kind: "Field",
        name: {
          kind: "Name",
          value: "breadcrumbs"
        },
        arguments: [],
        directives: []
      },
      {
        kind: "Field",
        name: {
          kind: "Name",
          value: "path"
        },
        arguments: [],
        directives: []
      },
      {
        kind: "Field",
        name: {
          kind: "Name",
          value: "relativePath"
        },
        arguments: [],
        directives: []
      },
      {
        kind: "Field",
        name: {
          kind: "Name",
          value: "extension"
        },
        arguments: [],
        directives: []
      }
    ]
  }
};
var astBuilder = {
  FormFieldBuilder: ({
    name: name2,
    additionalFields
  }) => {
    return astBuilder.ObjectTypeDefinition({
      name: name2,
      interfaces: [astBuilder.NamedType({ name: "FormField" })],
      fields: [
        astBuilder.FieldDefinition({
          name: "name",
          required: true,
          type: astBuilder.TYPES.String
        }),
        astBuilder.FieldDefinition({
          name: "label",
          required: true,
          type: astBuilder.TYPES.String
        }),
        astBuilder.FieldDefinition({
          name: "component",
          required: true,
          type: astBuilder.TYPES.String
        }),
        ...additionalFields || []
      ]
    });
  },
  ScalarTypeDefinition: ({
    name: name2,
    description
  }) => {
    return {
      kind: "ScalarTypeDefinition",
      name: {
        kind: "Name",
        value: name2
      },
      description: {
        kind: "StringValue",
        value: description || ""
      },
      directives: []
    };
  },
  InputValueDefinition: ({
    name: name2,
    type,
    list: list3,
    required
  }) => {
    let res = {};
    const namedType = {
      kind: "NamedType",
      name: {
        kind: "Name",
        value: type
      }
    };
    const def = {
      kind: "InputValueDefinition",
      name: {
        kind: "Name",
        value: name2
      }
    };
    if (list3) {
      if (required) {
        res = __spreadProps(__spreadValues({}, def), {
          type: {
            kind: "ListType",
            type: {
              kind: "NonNullType",
              type: namedType
            }
          }
        });
      } else {
        res = __spreadProps(__spreadValues({}, def), {
          type: {
            kind: "ListType",
            type: namedType
          }
        });
      }
    } else {
      if (required) {
        res = __spreadProps(__spreadValues({}, def), {
          type: {
            kind: "NonNullType",
            type: namedType
          }
        });
      } else {
        res = __spreadProps(__spreadValues({}, def), {
          type: namedType
        });
      }
    }
    return res;
  },
  EnumDefinition: (props) => {
    return {
      kind: "EnumTypeDefinition",
      name: {
        kind: "Name",
        value: props.name
      },
      values: props.values.map((val) => {
        return {
          kind: "EnumValueDefinition",
          name: {
            kind: "Name",
            value: val
          }
        };
      })
    };
  },
  FieldNodeDefinition: ({
    name: name2,
    type,
    args = [],
    list: list3,
    required
  }) => ({
    name: { kind: "Name", value: name2 },
    kind: "Field"
  }),
  FieldDefinition: ({
    name: name2,
    type,
    args = [],
    list: list3,
    required
  }) => {
    let res = {};
    const namedType = {
      kind: "NamedType",
      name: {
        kind: "Name",
        value: type
      }
    };
    const def = {
      kind: "FieldDefinition",
      name: {
        kind: "Name",
        value: name2
      },
      arguments: args
    };
    if (list3) {
      if (required) {
        res = __spreadProps(__spreadValues({}, def), {
          type: {
            kind: "NonNullType",
            type: {
              kind: "ListType",
              type: {
                kind: "NonNullType",
                type: namedType
              }
            }
          }
        });
      } else {
        res = __spreadProps(__spreadValues({}, def), {
          type: {
            kind: "ListType",
            type: namedType
          }
        });
      }
    } else {
      if (required) {
        res = __spreadProps(__spreadValues({}, def), {
          type: {
            kind: "NonNullType",
            type: namedType
          }
        });
      } else {
        res = __spreadProps(__spreadValues({}, def), {
          type: namedType
        });
      }
    }
    return res;
  },
  InterfaceTypeDefinition: ({
    name: name2,
    fields,
    description = ""
  }) => {
    return {
      kind: "InterfaceTypeDefinition",
      description: { kind: "StringValue", value: description },
      name: {
        kind: "Name",
        value: name2
      },
      interfaces: [],
      directives: [],
      fields
    };
  },
  InputObjectTypeDefinition: ({
    name: name2,
    fields
  }) => ({
    kind: "InputObjectTypeDefinition",
    name: {
      kind: "Name",
      value: name2
    },
    fields
  }),
  UnionTypeDefinition: ({
    name: name2,
    types
  }) => ({
    kind: "UnionTypeDefinition",
    name: {
      kind: "Name",
      value: name2
    },
    directives: [],
    types: types.map((name3) => ({
      kind: "NamedType",
      name: {
        kind: "Name",
        value: name3
      }
    }))
  }),
  NamedType: ({ name: name2 }) => {
    return {
      kind: "NamedType",
      name: {
        kind: "Name",
        value: name2
      }
    };
  },
  ObjectTypeDefinition: ({
    name: name2,
    fields,
    interfaces = [],
    directives = [],
    args = []
  }) => ({
    kind: "ObjectTypeDefinition",
    interfaces,
    directives,
    name: {
      kind: "Name",
      value: name2
    },
    fields
  }),
  FieldWithSelectionSetDefinition: ({
    name: name2,
    selections
  }) => {
    return {
      name: { kind: "Name", value: name2 },
      kind: "Field",
      selectionSet: {
        kind: "SelectionSet",
        selections
      }
    };
  },
  InlineFragmentDefinition: ({
    name: name2,
    selections
  }) => {
    return {
      kind: "InlineFragment",
      selectionSet: {
        kind: "SelectionSet",
        selections
      },
      typeCondition: {
        kind: "NamedType",
        name: {
          kind: "Name",
          value: name2
        }
      }
    };
  },
  FragmentDefinition: ({
    name: name2,
    fragmentName,
    selections
  }) => {
    return {
      kind: "FragmentDefinition",
      name: {
        kind: "Name",
        value: fragmentName
      },
      typeCondition: {
        kind: "NamedType",
        name: {
          kind: "Name",
          value: name2
        }
      },
      directives: [],
      selectionSet: {
        kind: "SelectionSet",
        selections
      }
    };
  },
  TYPES: {
    Scalar: (type) => {
      const scalars = {
        string: "String",
        boolean: "Boolean",
        number: "Int",
        datetime: "String",
        image: "String",
        text: "String"
      };
      return scalars[type];
    },
    MultiCollectionDocument: "DocumentNode",
    CollectionDocumentUnion: "DocumentUnion",
    String: "String",
    Reference: "Reference",
    Collection: "Collection",
    ID: "ID",
    SystemInfo: "SystemInfo",
    Boolean: "Boolean",
    JSON: "JSON",
    Node: "Node",
    PageInfo: "PageInfo",
    Connection: "Connection",
    Number: "Int",
    Document: "Document"
  },
  QueryOperationDefinition: ({
    queryName,
    fragName
  }) => {
    return {
      kind: "OperationDefinition",
      operation: "query",
      name: {
        kind: "Name",
        value: queryName
      },
      variableDefinitions: [
        {
          kind: "VariableDefinition",
          type: {
            kind: "NonNullType",
            type: {
              kind: "NamedType",
              name: { kind: "Name", value: "String" }
            }
          },
          variable: {
            kind: "Variable",
            name: { kind: "Name", value: "relativePath" }
          }
        }
      ],
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "Field",
            name: {
              kind: "Name",
              value: queryName
            },
            arguments: [
              {
                kind: "Argument",
                name: {
                  kind: "Name",
                  value: "relativePath"
                },
                value: {
                  kind: "Variable",
                  name: {
                    kind: "Name",
                    value: "relativePath"
                  }
                }
              }
            ],
            directives: [],
            selectionSet: {
              kind: "SelectionSet",
              selections: [
                SysFieldDefinition,
                {
                  kind: "Field",
                  name: {
                    kind: "Name",
                    value: "id"
                  },
                  arguments: [],
                  directives: []
                },
                {
                  kind: "Field",
                  name: {
                    kind: "Name",
                    value: "data"
                  },
                  arguments: [],
                  directives: [],
                  selectionSet: {
                    kind: "SelectionSet",
                    selections: [
                      {
                        kind: "FragmentSpread",
                        name: {
                          kind: "Name",
                          value: fragName
                        },
                        directives: []
                      }
                    ]
                  }
                }
              ]
            }
          }
        ]
      }
    };
  },
  ListQueryOperationDefinition: ({
    queryName,
    fragName
  }) => {
    return {
      kind: "OperationDefinition",
      operation: "query",
      name: {
        kind: "Name",
        value: queryName
      },
      variableDefinitions: [],
      directives: [],
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "Field",
            name: {
              kind: "Name",
              value: queryName
            },
            arguments: [],
            directives: [],
            selectionSet: {
              kind: "SelectionSet",
              selections: [
                {
                  kind: "Field",
                  name: {
                    kind: "Name",
                    value: "totalCount"
                  },
                  arguments: [],
                  directives: []
                },
                {
                  kind: "Field",
                  name: {
                    kind: "Name",
                    value: "edges"
                  },
                  arguments: [],
                  directives: [],
                  selectionSet: {
                    kind: "SelectionSet",
                    selections: [
                      {
                        kind: "Field",
                        name: {
                          kind: "Name",
                          value: "node"
                        },
                        arguments: [],
                        directives: [],
                        selectionSet: {
                          kind: "SelectionSet",
                          selections: [
                            {
                              kind: "Field",
                              name: {
                                kind: "Name",
                                value: "id"
                              },
                              arguments: [],
                              directives: []
                            },
                            SysFieldDefinition,
                            {
                              kind: "Field",
                              name: {
                                kind: "Name",
                                value: "data"
                              },
                              arguments: [],
                              directives: [],
                              selectionSet: {
                                kind: "SelectionSet",
                                selections: [
                                  {
                                    kind: "FragmentSpread",
                                    name: {
                                      kind: "Name",
                                      value: fragName
                                    },
                                    directives: []
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                }
              ]
            }
          }
        ]
      }
    };
  },
  toGraphQLAst: (ast) => {
    const definitions = import_lodash.default.uniqBy([
      ...extractInlineTypes(ast.query),
      ...extractInlineTypes(ast.globalTemplates),
      ...ast.definitions
    ], (field) => field.name.value);
    return {
      kind: "Document",
      definitions
    };
  }
};
var capitalize = (s) => {
  if (typeof s !== "string")
    return "";
  return s.charAt(0).toUpperCase() + s.slice(1);
};
var extractInlineTypes = (item) => {
  if (Array.isArray(item)) {
    const accumulator = item.map((i) => {
      return extractInlineTypes(i);
    });
    return import_lodash.default.flattenDeep(accumulator);
  } else {
    const accumulator = [item];
    for (const node of walk(item)) {
      if (node.kind === "UnionTypeDefinition") {
        node.types = import_lodash.default.uniqBy(node.types, (type) => type.name.value);
      }
      if (node.kind === "NamedType") {
        if (typeof node.name.value !== "string") {
          accumulator.push(node.name.value);
          node.name.value = node.name.value.name.value;
        }
      }
    }
    return accumulator;
  }
};
function* walk(maybeNode, visited = new WeakSet()) {
  if (typeof maybeNode === "string") {
    return;
  }
  if (visited.has(maybeNode)) {
    return;
  }
  for (const value of Object.values(maybeNode)) {
    if (Array.isArray(value)) {
      for (const element of value) {
        yield* walk(element, visited);
      }
    } else {
      yield* walk(value, visited);
    }
  }
  yield maybeNode;
  visited.add(maybeNode);
}
function addNamespaceToSchema(maybeNode, namespace = []) {
  if (typeof maybeNode === "string") {
    return maybeNode;
  }
  if (typeof maybeNode === "boolean") {
    return maybeNode;
  }
  const newNode = maybeNode;
  const keys2 = Object.keys(maybeNode);
  Object.values(maybeNode).map((m, index2) => {
    const key2 = keys2[index2];
    if (Array.isArray(m)) {
      newNode[key2] = m.map((element) => {
        if (!element) {
          return;
        }
        if (!element.hasOwnProperty("name")) {
          return element;
        }
        const value = element.name || element.value;
        return addNamespaceToSchema(element, [...namespace, value]);
      });
    } else {
      if (!m) {
        return;
      }
      if (!m.hasOwnProperty("name")) {
        newNode[key2] = m;
      } else {
        newNode[key2] = addNamespaceToSchema(m, [...namespace, m.name]);
      }
    }
  });
  return __spreadProps(__spreadValues({}, newNode), { namespace });
}
var generateNamespacedFieldName = (names, suffix = "") => {
  return (suffix ? [...names, suffix] : names).map(capitalize).join("");
};
var NAMER = {
  dataFilterTypeNameOn: (namespace) => {
    return generateNamespacedFieldName(namespace, "_FilterOn");
  },
  dataFilterTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Filter");
  },
  dataMutationTypeNameOn: (namespace) => {
    return generateNamespacedFieldName(namespace, "_MutationOn");
  },
  dataMutationTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Mutation");
  },
  updateName: (namespace) => {
    return "update" + generateNamespacedFieldName(namespace, "Document");
  },
  createName: (namespace) => {
    return "create" + generateNamespacedFieldName(namespace, "Document");
  },
  queryName: (namespace) => {
    return "get" + generateNamespacedFieldName(namespace, "Document");
  },
  generateQueryListName: (namespace) => {
    return "get" + generateNamespacedFieldName(namespace, "List");
  },
  fragmentName: (namespace) => {
    return generateNamespacedFieldName(namespace, "") + "Parts";
  },
  collectionTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Collection");
  },
  documentTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Document");
  },
  dataTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "");
  },
  referenceConnectionType: (namespace) => {
    return generateNamespacedFieldName(namespace, "Connection");
  },
  referenceConnectionEdgesTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "ConnectionEdges");
  }
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/util.ts
var yup = __toModule(require("yup"));
var import_graphql = __toModule(require("graphql"));
var sequential = async (items, callback) => {
  const accum = [];
  if (!items) {
    return [];
  }
  const reducePromises = async (previous2, endpoint) => {
    const prev = await previous2;
    if (prev) {
      accum.push(prev);
    }
    return callback(endpoint, accum.length);
  };
  const result = await items.reduce(reducePromises, Promise.resolve());
  if (result) {
    accum.push(result);
  }
  return accum;
};
function assertShape(value, yupSchema, errorMessage) {
  const shape = yupSchema(yup);
  try {
    shape.validateSync(value);
  } catch (e) {
    const message = errorMessage || `Failed to assertShape - ${e.message}`;
    throw new import_graphql.GraphQLError(message, null, null, null, null, null, {
      stack: e.stack
    });
  }
}
var lastItem = (arr) => {
  return arr[arr.length - 1];
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/builder/static-definitions.ts
var interfaceDefinitions = [
  astBuilder.InterfaceTypeDefinition({
    name: "Node",
    fields: [
      astBuilder.FieldDefinition({
        name: "id",
        type: astBuilder.TYPES.ID,
        required: true
      })
    ]
  }),
  astBuilder.InterfaceTypeDefinition({
    name: "Document",
    fields: [
      astBuilder.FieldDefinition({
        name: "sys",
        type: astBuilder.TYPES.SystemInfo
      }),
      astBuilder.FieldDefinition({
        name: "id",
        type: astBuilder.TYPES.ID,
        required: true
      }),
      astBuilder.FieldDefinition({
        name: "form",
        type: astBuilder.TYPES.JSON,
        required: true
      }),
      astBuilder.FieldDefinition({
        name: "values",
        type: astBuilder.TYPES.JSON,
        required: true
      })
    ]
  }),
  astBuilder.InterfaceTypeDefinition({
    name: "Connection",
    description: "A relay-compliant pagination connection",
    fields: [
      astBuilder.FieldDefinition({
        name: "totalCount",
        required: true,
        type: astBuilder.TYPES.Number
      })
    ]
  })
];
var scalarDefinitions = [
  astBuilder.ScalarTypeDefinition({
    name: "Reference",
    description: "References another document, used as a foreign key"
  }),
  astBuilder.ScalarTypeDefinition({ name: "JSON" }),
  astBuilder.ObjectTypeDefinition({
    name: "SystemInfo",
    fields: [
      astBuilder.FieldDefinition({
        name: "filename",
        required: true,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "basename",
        required: true,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "breadcrumbs",
        required: true,
        type: astBuilder.TYPES.String,
        list: true,
        args: [
          astBuilder.InputValueDefinition({
            name: "excludeExtension",
            type: astBuilder.TYPES.Boolean
          })
        ]
      }),
      astBuilder.FieldDefinition({
        name: "path",
        required: true,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "relativePath",
        required: true,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "extension",
        required: true,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "template",
        required: true,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "collection",
        required: true,
        type: astBuilder.TYPES.Collection
      })
    ]
  }),
  astBuilder.ObjectTypeDefinition({
    name: "PageInfo",
    fields: [
      astBuilder.FieldDefinition({
        name: "hasPreviousPage",
        required: true,
        type: astBuilder.TYPES.Boolean
      }),
      astBuilder.FieldDefinition({
        name: "hasNextPage",
        required: true,
        type: astBuilder.TYPES.Boolean
      }),
      astBuilder.FieldDefinition({
        name: "startCursor",
        required: true,
        type: astBuilder.TYPES.String
      }),
      astBuilder.FieldDefinition({
        name: "endCursor",
        required: true,
        type: astBuilder.TYPES.String
      })
    ]
  })
];
var staticDefinitions = [...scalarDefinitions, interfaceDefinitions];

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/builder/index.ts
var createBuilder = async ({
  database,
  tinaSchema
}) => {
  return new Builder({ database, tinaSchema });
};
var Builder = class {
  constructor(config) {
    this.config = config;
    this.buildCollectionDefinition = async (collections) => {
      const name2 = "getCollection";
      const typeName = "Collection";
      const args = [
        astBuilder.InputValueDefinition({
          name: "collection",
          type: astBuilder.TYPES.String
        })
      ];
      const documentsType = await this._buildMultiCollectionDocumentListDefinition({
        fieldName: "documents",
        namespace: ["document"],
        nodeType: astBuilder.TYPES.MultiCollectionDocument,
        collections,
        connectionNamespace: ["document"]
      });
      const type = astBuilder.ObjectTypeDefinition({
        name: typeName,
        fields: [
          astBuilder.FieldDefinition({
            name: "name",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.FieldDefinition({
            name: "slug",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.FieldDefinition({
            name: "label",
            required: false,
            type: astBuilder.TYPES.String
          }),
          astBuilder.FieldDefinition({
            name: "path",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.FieldDefinition({
            name: "format",
            required: false,
            type: astBuilder.TYPES.String
          }),
          astBuilder.FieldDefinition({
            name: "matches",
            required: false,
            type: astBuilder.TYPES.String
          }),
          astBuilder.FieldDefinition({
            name: "templates",
            list: true,
            type: "JSON"
          }),
          astBuilder.FieldDefinition({
            name: "fields",
            list: true,
            type: "JSON"
          }),
          documentsType
        ]
      });
      return astBuilder.FieldDefinition({ type, name: name2, args, required: true });
    };
    this.buildMultiCollectionDefinition = async (collections) => {
      const name2 = "getCollections";
      const typeName = "Collection";
      return astBuilder.FieldDefinition({
        type: typeName,
        name: name2,
        list: true,
        required: true
      });
    };
    this.multiNodeDocument = async () => {
      const name2 = "node";
      const args = [
        astBuilder.InputValueDefinition({
          name: "id",
          type: astBuilder.TYPES.String
        })
      ];
      await this.database.addToLookupMap({
        type: astBuilder.TYPES.Node,
        resolveType: "nodeDocument"
      });
      return astBuilder.FieldDefinition({
        name: name2,
        args,
        list: false,
        type: astBuilder.TYPES.Node,
        required: true
      });
    };
    this.multiCollectionDocument = async (collections) => {
      const name2 = "getDocument";
      const args = [
        astBuilder.InputValueDefinition({
          name: "collection",
          type: astBuilder.TYPES.String
        }),
        astBuilder.InputValueDefinition({
          name: "relativePath",
          type: astBuilder.TYPES.String
        })
      ];
      const type = await this._buildMultiCollectionDocumentDefinition({
        fieldName: astBuilder.TYPES.MultiCollectionDocument,
        collections
      });
      return astBuilder.FieldDefinition({
        name: name2,
        args,
        list: false,
        type,
        required: true
      });
    };
    this.multiCollectionDocumentFields = async () => {
      return astBuilder.FieldDefinition({
        name: "getDocumentFields",
        required: true,
        type: "JSON"
      });
    };
    this.addMultiCollectionDocumentMutation = async () => {
      return astBuilder.FieldDefinition({
        name: "addPendingDocument",
        args: [
          astBuilder.InputValueDefinition({
            name: "collection",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "relativePath",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "template",
            required: false,
            type: astBuilder.TYPES.String
          })
        ],
        required: true,
        type: astBuilder.TYPES.MultiCollectionDocument
      });
    };
    this.buildCreateCollectionDocumentMutation = async (collections) => {
      return astBuilder.FieldDefinition({
        name: "createDocument",
        args: [
          astBuilder.InputValueDefinition({
            name: "collection",
            required: false,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "relativePath",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "params",
            required: true,
            type: await this._buildReferenceMutation({
              namespace: ["document"],
              collections: collections.map((collection) => collection.name)
            })
          })
        ],
        required: true,
        type: astBuilder.TYPES.MultiCollectionDocument
      });
    };
    this.buildUpdateCollectionDocumentMutation = async (collections) => {
      return astBuilder.FieldDefinition({
        name: "updateDocument",
        args: [
          astBuilder.InputValueDefinition({
            name: "collection",
            required: false,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "relativePath",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "params",
            required: true,
            type: await this._buildReferenceMutation({
              namespace: ["document"],
              collections: collections.map((collection) => collection.name)
            })
          })
        ],
        required: true,
        type: astBuilder.TYPES.MultiCollectionDocument
      });
    };
    this.multiCollectionDocumentList = async (collections) => {
      return this._buildMultiCollectionDocumentListDefinition({
        fieldName: "getDocumentList",
        namespace: ["document"],
        nodeType: astBuilder.TYPES.MultiCollectionDocument,
        collections,
        connectionNamespace: ["document"]
      });
    };
    this.collectionDocument = async (collection) => {
      const name2 = NAMER.queryName([collection.name]);
      const type = await this._buildCollectionDocumentType(collection);
      const args = [
        astBuilder.InputValueDefinition({
          name: "relativePath",
          type: astBuilder.TYPES.String
        })
      ];
      await this.database.addToLookupMap({
        type: type.name.value,
        resolveType: "collectionDocument",
        collection: collection.name,
        [NAMER.createName([collection.name])]: "create",
        [NAMER.updateName([collection.name])]: "update"
      });
      return astBuilder.FieldDefinition({ type, name: name2, args, required: true });
    };
    this.collectionFragment = async (collection) => {
      const name2 = NAMER.dataTypeName(collection.namespace);
      const fragmentName = NAMER.fragmentName(collection.namespace);
      if (typeof collection.fields === "object") {
        const selections = [];
        await sequential(collection.fields, async (x) => {
          const field = await this._buildFieldNodeForFragments(x);
          selections.push(field);
        });
        return astBuilder.FragmentDefinition({
          name: name2,
          fragmentName,
          selections: filterSelections(selections)
        });
      } else {
        const selections = [];
        await sequential(collection.templates, async (tem) => {
          if (typeof tem === "object") {
            selections.push(await this.buildTemplateFragments(tem));
          }
        });
        return astBuilder.FragmentDefinition({
          name: name2,
          fragmentName,
          selections: filterSelections(selections)
        });
      }
    };
    this._buildFieldNodeForFragments = async (field) => {
      switch (field.type) {
        case "string":
        case "image":
        case "datetime":
        case "number":
        case "boolean":
        case "rich-text":
          return astBuilder.FieldNodeDefinition(field);
        case "object":
          if (typeof field.fields === "object") {
            const selections = [];
            await sequential(field.fields, async (item) => {
              const field2 = await this._buildFieldNodeForFragments(item);
              selections.push(field2);
            });
            return astBuilder.FieldWithSelectionSetDefinition({
              name: field.name,
              selections: [
                { kind: "Field", name: { kind: "Name", value: "__typename" } },
                ...filterSelections(selections)
              ]
            });
          } else if (typeof field.templates === "object") {
            const selections = [];
            await sequential(field.templates, async (tem) => {
              if (typeof tem === "object") {
                selections.push(await this.buildTemplateFragments(tem));
              }
            });
            return astBuilder.FieldWithSelectionSetDefinition({
              name: field.name,
              selections: [
                { kind: "Field", name: { kind: "Name", value: "__typename" } },
                ...filterSelections(selections)
              ]
            });
          }
        case "reference":
          return astBuilder.FieldWithSelectionSetDefinition({
            name: field.name,
            selections: [
              {
                kind: "InlineFragment",
                typeCondition: {
                  kind: "NamedType",
                  name: {
                    kind: "Name",
                    value: "Document"
                  }
                },
                directives: [],
                selectionSet: {
                  kind: "SelectionSet",
                  selections: [
                    {
                      kind: "Field",
                      name: {
                        kind: "Name",
                        value: "id"
                      },
                      arguments: [],
                      directives: []
                    }
                  ]
                }
              }
            ]
          });
      }
    };
    this.updateCollectionDocumentMutation = async (collection) => {
      return astBuilder.FieldDefinition({
        type: await this._buildCollectionDocumentType(collection),
        name: NAMER.updateName([collection.name]),
        required: true,
        args: [
          astBuilder.InputValueDefinition({
            name: "relativePath",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "params",
            required: true,
            type: await this._updateCollectionDocumentMutationType(collection)
          })
        ]
      });
    };
    this.createCollectionDocumentMutation = async (collection) => {
      return astBuilder.FieldDefinition({
        type: await this._buildCollectionDocumentType(collection),
        name: NAMER.createName([collection.name]),
        required: true,
        args: [
          astBuilder.InputValueDefinition({
            name: "relativePath",
            required: true,
            type: astBuilder.TYPES.String
          }),
          astBuilder.InputValueDefinition({
            name: "params",
            required: true,
            type: await this._updateCollectionDocumentMutationType(collection)
          })
        ]
      });
    };
    this.collectionDocumentList = async (collection) => {
      const connectionName = NAMER.referenceConnectionType(collection.namespace);
      await this.database.addToLookupMap({
        type: connectionName,
        resolveType: "collectionDocumentList",
        collection: collection.name
      });
      return this._connectionFieldBuilder({
        fieldName: NAMER.generateQueryListName(collection.namespace),
        connectionName,
        nodeType: NAMER.documentTypeName(collection.namespace),
        namespace: collection.namespace,
        collection
      });
    };
    this.buildStaticDefinitions = () => staticDefinitions;
    this._buildCollectionDocumentType = async (collection) => {
      const documentTypeName = NAMER.documentTypeName(collection.namespace);
      return astBuilder.ObjectTypeDefinition({
        name: documentTypeName,
        interfaces: [
          astBuilder.NamedType({ name: astBuilder.TYPES.Node }),
          astBuilder.NamedType({ name: astBuilder.TYPES.Document })
        ],
        fields: [
          astBuilder.FieldDefinition({
            name: "id",
            required: true,
            type: astBuilder.TYPES.ID
          }),
          astBuilder.FieldDefinition({
            name: "sys",
            required: true,
            type: astBuilder.TYPES.SystemInfo
          }),
          astBuilder.FieldDefinition({
            name: "data",
            required: true,
            type: await this._buildObjectOrUnionData(this.tinaSchema.getTemplatesForCollectable(collection))
          }),
          astBuilder.FieldDefinition({
            name: "form",
            required: true,
            type: "JSON"
          }),
          astBuilder.FieldDefinition({
            name: "values",
            required: true,
            type: "JSON"
          }),
          astBuilder.FieldDefinition({
            name: "dataJSON",
            required: true,
            type: "JSON"
          })
        ]
      });
    };
    this._filterCollectionDocumentType = async (collection) => {
      const t = this.tinaSchema.getTemplatesForCollectable(collection);
      if (t.type === "union") {
        return astBuilder.InputObjectTypeDefinition({
          name: NAMER.dataFilterTypeName(t.namespace),
          fields: await sequential(t.templates, async (template) => {
            return astBuilder.InputValueDefinition({
              name: template.namespace[template.namespace.length - 1],
              type: await this._buildTemplateFilter(template)
            });
          })
        });
      }
      return this._buildTemplateFilter(t.template);
    };
    this._buildTemplateFilter = async (template) => {
      const fields = [];
      await sequential(template.fields, async (field) => {
        const f = await this._buildFieldFilter(field);
        if (f) {
          fields.push(f);
        }
        return true;
      });
      return astBuilder.InputObjectTypeDefinition({
        name: NAMER.dataFilterTypeName(template.namespace),
        fields
      });
    };
    this._updateCollectionDocumentMutationType = async (collection) => {
      const t = this.tinaSchema.getTemplatesForCollectable(collection);
      if (t.type === "union") {
        return astBuilder.InputObjectTypeDefinition({
          name: NAMER.dataMutationTypeName(t.namespace),
          fields: await sequential(t.templates, async (template) => {
            return astBuilder.InputValueDefinition({
              name: template.namespace[template.namespace.length - 1],
              type: await this._buildTemplateMutation(template)
            });
          })
        });
      }
      return this._buildTemplateMutation(t.template);
    };
    this._buildTemplateMutation = async (template) => {
      return astBuilder.InputObjectTypeDefinition({
        name: NAMER.dataMutationTypeName(template.namespace),
        fields: await sequential(template.fields, (field) => {
          return this._buildFieldMutation(field);
        })
      });
    };
    this._buildMultiCollectionDocumentDefinition = async ({
      fieldName,
      collections
    }) => {
      const types = collections.map((collection) => {
        const typeName = NAMER.documentTypeName(collection.namespace);
        return typeName;
      });
      const type = astBuilder.UnionTypeDefinition({
        name: fieldName,
        types
      });
      await this.database.addToLookupMap({
        type: type.name.value,
        resolveType: "multiCollectionDocument",
        createDocument: "create",
        updateDocument: "update"
      });
      return type;
    };
    this._buildMultiCollectionDocumentListDefinition = async ({
      fieldName,
      namespace,
      nodeType,
      collections,
      connectionNamespace
    }) => {
      const connectionName = NAMER.referenceConnectionType(namespace);
      await this.database.addToLookupMap({
        type: connectionName,
        resolveType: "multiCollectionDocumentList",
        collections: collections.map((collection) => collection.name)
      });
      return this._connectionFieldBuilder({
        fieldName,
        namespace: connectionNamespace,
        connectionName,
        nodeType,
        collections
      });
    };
    this._buildFieldFilter = async (field) => {
      switch (field.type) {
        case "boolean":
          return astBuilder.InputValueDefinition({
            name: field.name,
            type: astBuilder.InputObjectTypeDefinition({
              name: NAMER.dataFilterTypeName([field.type]),
              fields: [
                astBuilder.InputValueDefinition({
                  name: "eq",
                  type: astBuilder.TYPES.Boolean
                }),
                astBuilder.InputValueDefinition({
                  name: "exists",
                  type: astBuilder.TYPES.Boolean
                })
              ]
            })
          });
        case "number":
          return astBuilder.InputValueDefinition({
            name: field.name,
            type: astBuilder.InputObjectTypeDefinition({
              name: NAMER.dataFilterTypeName([field.type]),
              fields: [
                astBuilder.InputValueDefinition({
                  name: "lt",
                  type: astBuilder.TYPES.Number
                }),
                astBuilder.InputValueDefinition({
                  name: "lte",
                  type: astBuilder.TYPES.Number
                }),
                astBuilder.InputValueDefinition({
                  name: "gte",
                  type: astBuilder.TYPES.Number
                }),
                astBuilder.InputValueDefinition({
                  name: "gt",
                  type: astBuilder.TYPES.Number
                }),
                astBuilder.InputValueDefinition({
                  name: "eq",
                  type: astBuilder.TYPES.Number
                }),
                astBuilder.InputValueDefinition({
                  name: "exists",
                  type: astBuilder.TYPES.Boolean
                })
              ]
            })
          });
        case "datetime":
          return astBuilder.InputValueDefinition({
            name: field.name,
            type: astBuilder.InputObjectTypeDefinition({
              name: NAMER.dataFilterTypeName([field.type]),
              fields: [
                astBuilder.InputValueDefinition({
                  name: "after",
                  type: astBuilder.TYPES.String
                }),
                astBuilder.InputValueDefinition({
                  name: "before",
                  type: astBuilder.TYPES.String
                }),
                astBuilder.InputValueDefinition({
                  name: "eq",
                  type: astBuilder.TYPES.String
                }),
                astBuilder.InputValueDefinition({
                  name: "exists",
                  type: astBuilder.TYPES.Boolean
                })
              ]
            })
          });
        case "image":
        case "string":
          return astBuilder.InputValueDefinition({
            name: field.name,
            type: astBuilder.InputObjectTypeDefinition({
              name: NAMER.dataFilterTypeName([field.type]),
              fields: [
                astBuilder.InputValueDefinition({
                  name: "startsWith",
                  type: astBuilder.TYPES.String
                }),
                astBuilder.InputValueDefinition({
                  name: "eq",
                  type: astBuilder.TYPES.String
                }),
                astBuilder.InputValueDefinition({
                  name: "exists",
                  type: astBuilder.TYPES.Boolean
                })
              ]
            })
          });
        case "object":
          return astBuilder.InputValueDefinition({
            name: field.name,
            type: await this._filterCollectionDocumentType(field)
          });
        case "rich-text":
          if (!field.templates) {
            return astBuilder.InputValueDefinition({
              name: field.name,
              type: astBuilder.InputObjectTypeDefinition({
                name: NAMER.dataFilterTypeName(["richText"]),
                fields: [
                  astBuilder.InputValueDefinition({
                    name: "startsWith",
                    type: astBuilder.TYPES.String
                  }),
                  astBuilder.InputValueDefinition({
                    name: "eq",
                    type: astBuilder.TYPES.String
                  }),
                  astBuilder.InputValueDefinition({
                    name: "exists",
                    type: astBuilder.TYPES.Boolean
                  })
                ]
              })
            });
          }
          return astBuilder.InputValueDefinition({
            name: field.name,
            type: await this._filterCollectionDocumentType(field)
          });
        case "reference":
          const filter = await this._connectionFilterBuilder({
            fieldName: field.name,
            namespace: field.namespace,
            collections: await this.tinaSchema.getCollectionsByName(field.collections)
          });
          return astBuilder.InputValueDefinition({
            name: field.name,
            type: astBuilder.InputObjectTypeDefinition({
              name: NAMER.dataFilterTypeName(field.namespace),
              fields: [filter]
            })
          });
      }
    };
    this._buildFieldMutation = async (field) => {
      switch (field.type) {
        case "boolean":
          return astBuilder.InputValueDefinition({
            name: field.name,
            list: field.list,
            type: astBuilder.TYPES.Boolean
          });
        case "number":
          return astBuilder.InputValueDefinition({
            name: field.name,
            list: field.list,
            type: astBuilder.TYPES.Number
          });
        case "datetime":
        case "image":
        case "string":
          return astBuilder.InputValueDefinition({
            name: field.name,
            list: field.list,
            type: astBuilder.TYPES.String
          });
        case "object":
          return astBuilder.InputValueDefinition({
            name: field.name,
            list: field.list,
            type: await this._updateCollectionDocumentMutationType(field)
          });
        case "rich-text":
          return astBuilder.InputValueDefinition({
            name: field.name,
            list: field.list,
            type: astBuilder.TYPES.JSON
          });
        case "reference":
          return astBuilder.InputValueDefinition({
            name: field.name,
            list: field.list,
            type: astBuilder.TYPES.String
          });
      }
    };
    this._buildReferenceMutation = async (field) => {
      return astBuilder.InputObjectTypeDefinition({
        name: NAMER.dataMutationTypeName(field.namespace),
        fields: await sequential(this.tinaSchema.getCollectionsByName(field.collections), async (collection) => {
          return astBuilder.InputValueDefinition({
            name: collection.name,
            type: NAMER.dataMutationTypeName([collection.name])
          });
        })
      });
    };
    this._buildObjectOrUnionData = async (collectableTemplate) => {
      if (collectableTemplate.type === "union") {
        const name2 = NAMER.dataTypeName(collectableTemplate.namespace);
        const typeMap = {};
        const types = await sequential(collectableTemplate.templates, async (template) => {
          const type = await this._buildTemplateData(template);
          typeMap[template.namespace[template.namespace.length - 1]] = type.name.value;
          return type;
        });
        await this.database.addToLookupMap({
          type: name2,
          resolveType: "unionData",
          typeMap
        });
        return astBuilder.UnionTypeDefinition({ name: name2, types });
      }
      return this._buildTemplateData(collectableTemplate.template);
    };
    this._connectionFilterBuilder = async ({
      fieldName,
      namespace,
      collection,
      collections
    }) => {
      let filter;
      if (collections) {
        filter = astBuilder.InputValueDefinition({
          name: "filter",
          type: astBuilder.InputObjectTypeDefinition({
            name: NAMER.dataFilterTypeName(namespace),
            fields: await sequential(collections, async (collection2) => {
              return astBuilder.InputValueDefinition({
                name: collection2.name,
                type: await this._filterCollectionDocumentType(collection2)
              });
            })
          })
        });
      } else if (collection) {
        filter = astBuilder.InputValueDefinition({
          name: "filter",
          type: await this._filterCollectionDocumentType(collection)
        });
      } else {
        throw new Error(`Must provide either collection or collections to filter field builder`);
      }
      return filter;
    };
    this._connectionFieldBuilder = async ({
      fieldName,
      namespace,
      connectionName,
      nodeType,
      collection,
      collections
    }) => {
      const extra = this.database.store.supportsIndexing() ? [
        await this._connectionFilterBuilder({
          fieldName,
          namespace,
          collection,
          collections
        })
      ] : [];
      return astBuilder.FieldDefinition({
        name: fieldName,
        required: true,
        args: [...listArgs, ...extra],
        type: astBuilder.ObjectTypeDefinition({
          name: connectionName,
          interfaces: [
            astBuilder.NamedType({ name: astBuilder.TYPES.Connection })
          ],
          fields: [
            astBuilder.FieldDefinition({
              name: "pageInfo",
              type: astBuilder.TYPES.PageInfo
            }),
            astBuilder.FieldDefinition({
              name: "totalCount",
              required: true,
              type: astBuilder.TYPES.Number
            }),
            astBuilder.FieldDefinition({
              name: "edges",
              list: true,
              type: astBuilder.ObjectTypeDefinition({
                name: NAMER.referenceConnectionEdgesTypeName(namespace),
                fields: [
                  astBuilder.FieldDefinition({
                    name: "cursor",
                    type: astBuilder.TYPES.String
                  }),
                  astBuilder.FieldDefinition({ name: "node", type: nodeType })
                ]
              })
            })
          ]
        })
      });
    };
    this._buildDataField = async (field) => {
      const listWarningMsg = `
WARNING: The user interface for ${field.type} does not support \`list: true\`
Visit https://tina.io/docs/errors/ui-not-supported/ for more information

`;
      switch (field.type) {
        case "boolean":
        case "datetime":
        case "image":
        case "number":
          if (field.list) {
            console.warn(listWarningMsg);
          }
        case "string":
          return astBuilder.FieldDefinition({
            name: field.name,
            list: field.list,
            required: field.required,
            type: astBuilder.TYPES.Scalar(field.type)
          });
        case "object":
          return astBuilder.FieldDefinition({
            name: field.name,
            list: field.list,
            required: field.required,
            type: await this._buildObjectOrUnionData(this.tinaSchema.getTemplatesForCollectable(field))
          });
        case "rich-text":
          return astBuilder.FieldDefinition({
            name: field.name,
            list: field.list,
            required: field.required,
            type: astBuilder.TYPES.JSON
          });
        case "reference":
          const name2 = NAMER.documentTypeName(field.namespace);
          if (field.list) {
            console.warn(listWarningMsg);
            return this._buildMultiCollectionDocumentListDefinition({
              fieldName: field.name,
              namespace: field.namespace,
              nodeType: astBuilder.UnionTypeDefinition({
                name: name2,
                types: field.collections.map((collectionName) => NAMER.documentTypeName([collectionName]))
              }),
              collections: this.tinaSchema.getCollectionsByName(field.collections),
              connectionNamespace: field.namespace
            });
          } else {
            const type = await this._buildMultiCollectionDocumentDefinition({
              fieldName: name2,
              collections: this.tinaSchema.getCollectionsByName(field.collections)
            });
            return astBuilder.FieldDefinition({
              name: field.name,
              required: field.required,
              list: false,
              type
            });
          }
      }
    };
    this._buildTemplateData = async ({ namespace, fields }) => {
      return astBuilder.ObjectTypeDefinition({
        name: NAMER.dataTypeName(namespace),
        fields: await sequential(fields, async (field) => {
          return this._buildDataField(field);
        })
      });
    };
    this.tinaSchema = config.tinaSchema;
    this.database = config.database;
  }
  async buildTemplateFragments(template) {
    const selections = [];
    await sequential(template.fields || [], async (item) => {
      const field = await this._buildFieldNodeForFragments(item);
      selections.push(field);
    });
    return astBuilder.InlineFragmentDefinition({
      selections: filterSelections(selections),
      name: NAMER.dataTypeName(template.namespace)
    });
  }
};
var listArgs = [
  astBuilder.InputValueDefinition({
    name: "before",
    type: astBuilder.TYPES.String
  }),
  astBuilder.InputValueDefinition({
    name: "after",
    type: astBuilder.TYPES.String
  }),
  astBuilder.InputValueDefinition({
    name: "first",
    type: astBuilder.TYPES.Number
  }),
  astBuilder.InputValueDefinition({
    name: "last",
    type: astBuilder.TYPES.Number
  })
];
var filterSelections = (arr) => {
  return arr.filter(Boolean);
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/schema/validate.ts
var import_lodash2 = __toModule(require("lodash"));
var yup2 = __toModule(require("yup"));
var FIELD_TYPES = [
  "string",
  "number",
  "boolean",
  "datetime",
  "image",
  "reference",
  "object",
  "rich-text"
];
var validateSchema = async (schema) => {
  const schema2 = addNamespaceToSchema(import_lodash2.default.cloneDeep(schema));
  const collections = await sequential(schema2.collections, async (collection) => validateCollection(collection));
  validationCollectionsPathAndMatch(collections);
  return {
    collections
  };
};
var validationCollectionsPathAndMatch = (collections) => {
  const paths = collections.map((x) => x.path);
  if (paths.length === new Set(paths).size) {
    return;
  }
  const noMatchCollections = collections.filter((x) => {
    return typeof (x == null ? void 0 : x.match) === "undefined";
  }).map((x) => x.path);
  if (noMatchCollections.length !== new Set(noMatchCollections).size) {
    throw new Error("path must be unique when no `match` is provided");
  }
  const hasMatchAndPath = collections.filter((x) => {
    return typeof x.path !== "undefined" && typeof x.match !== "undefined";
  }).map((x) => `${x.path}|${x.match}`);
  if (hasMatchAndPath.length !== new Set(hasMatchAndPath).size) {
    throw new Error("Both `match` and `path` can not be the same");
  }
  const groupbyPath = collections.reduce((r, a) => {
    r[a.path] = r[a.path] || [];
    r[a.path].push(a);
    return r;
  }, Object.create(null));
  Object.keys(groupbyPath).forEach((key2) => {
    const collectionsArr = groupbyPath[key2];
    if (collectionsArr.length === 1) {
      return;
    }
    const matches = collectionsArr.filter((x) => {
      return typeof x.match !== "undefined";
    });
    if (matches.length !== collections.length) {
      throw new Error("path must be unique when no `match` is provided");
    }
  });
};
var validateCollection = async (collection) => {
  let templates = [];
  let fields = [];
  const messageName = collection.namespace.join(".");
  const collectionSchema = yup2.object({
    name: yup2.string().matches(/^[a-zA-Z0-9_]*$/, {
      message: (obj) => `Collection's "name" must match ${obj.regex} at ${messageName}`
    }).required(),
    path: yup2.string().required().transform((value) => {
      return value.replace(/^\/|\/$/g, "");
    })
  });
  await collectionSchema.validate(collection);
  const validCollection = await collectionSchema.cast(collection);
  if (validCollection.templates) {
    templates = await sequential(validCollection.templates, async (template) => {
      if (typeof template === "string") {
        throw new Error(`Global templates are not yet supported`);
      }
      const fields2 = await sequential(template.fields, async (field) => {
        return validateField(field);
      });
      return __spreadValues(__spreadValues({}, validCollection), fields2);
    });
  }
  if (validCollection.fields) {
    if (typeof validCollection.fields === "string") {
      throw new Error(`Global templates are not yet supported`);
    }
    fields = await sequential(validCollection.fields, async (field) => {
      return validateField(field);
    });
    return __spreadProps(__spreadValues({}, validCollection), {
      fields
    });
  }
  return collection;
};
var validateField = async (field) => {
  const messageName = field.namespace.join(".");
  const schema = yup2.object({
    name: yup2.string().matches(/^[a-zA-Z0-9_]*$/, {
      message: (obj) => `Field's 'name' must match ${obj.regex} at ${messageName}`
    }).required(),
    type: yup2.string().oneOf(FIELD_TYPES, (obj) => `'type' must be one of: ${obj.values}, but got '${obj.value}' at ${messageName}`)
  });
  await schema.validate(field);
  return field;
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/package.json
var name = "@tinacms/graphql";
var version = "0.59.3";
var main = "dist/index.js";
var typings = "dist/index.d.ts";
var files = [
  "package.json",
  "dist"
];
var license = "Apache-2.0";
var buildConfig = {
  entryPoints: [
    {
      name: "src/index.ts",
      target: "node",
      bundle: [
        "mdast",
        "mdast-util-from-markdown",
        "mdast-util-mdx",
        "mdast-util-mdx-expression",
        "mdast-util-to-markdown",
        "micromark-extension-mdxjs",
        "rehype-format",
        "rehype-stringify",
        "remark",
        "remark-frontmatter",
        "remark-mdx",
        "remark-parse",
        "remark-rehype",
        "remark-slate",
        "remark-stringify",
        "unified",
        "unist-util-remove-position",
        "unist-util-visit",
        "vfile"
      ]
    }
  ]
};
var scripts = {
  types: "yarn tsc",
  build: 'echo "Run `yarn build` from the root of the repository instead"',
  docs: "yarn typedoc",
  serve: "yarn nodemon dist/server.js",
  test: "jest"
};
var dependencies = {
  "body-parser": "^1.19.0",
  cors: "^2.8.5",
  dataloader: "^2.0.0",
  "date-fns": "^2.21.1",
  "encoding-down": "^7.1.0",
  esbuild: "^0.12.25",
  "esbuild-jest": "^0.5.0",
  "estree-walker": "^3.0.0",
  "fast-glob": "^3.2.5",
  flat: "^5.0.2",
  "fs-extra": "^9.0.1",
  graphql: "^15.3.0",
  "graphql-type-json": "^0.3.2",
  "gray-matter": "^4.0.2",
  "js-yaml": "^3.14.0",
  lodash: "^4.17.20",
  mdast: "^3.0.0",
  "mdast-util-from-markdown": "^1.0.0",
  "mdast-util-mdx": "^1.1.0",
  "mdast-util-mdx-expression": "^1.1.0",
  "mdast-util-to-markdown": "^1.2.1",
  "micromark-extension-mdxjs": "^1.0.0",
  mocha: "^9.1.1",
  "normalize-path": "^3.0.0",
  prettier: "^2.2.1",
  "rehype-format": "^3.1.0",
  "rehype-stringify": "^8.0.0",
  remark: "^13.0.0",
  "remark-frontmatter": "^3.0.0",
  "remark-mdx": "next",
  "remark-parse": "^10.0.0",
  "remark-rehype": "^8.0.0",
  "remark-slate": "^1.8.0",
  "remark-stringify": "^8.1.1",
  unified: "^10.1.0",
  "unist-util-remove-position": "^3.0.0",
  "unist-util-visit": "^4.0.0",
  vfile: "^4.2.0",
  ws: "^7.3.1",
  yup: "^0.32.9"
};
var publishConfig = {
  registry: "https://registry.npmjs.org"
};
var repository = {
  url: "https://github.com/tinacms/tinacms.git",
  directory: "packages/tina-graphql"
};
var devDependencies = {
  "@tinacms/datalayer": "workspace:*",
  "@tinacms/scripts": "workspace:*",
  "@types/cors": "^2.8.7",
  "@types/estree": "^0.0.50",
  "@types/express": "^4.17.8",
  "@types/fs-extra": "^9.0.2",
  "@types/jest": "^26.0.4",
  "@types/js-yaml": "^3.12.5",
  "@types/level": "^6.0.0",
  "@types/lodash": "^4.14.161",
  "@types/lodash.camelcase": "^4.3.6",
  "@types/lodash.upperfirst": "^4.3.6",
  "@types/lru-cache": "^5.1.0",
  "@types/mdast": "^3.0.10",
  "@types/node": "^14.17.34",
  "@types/normalize-path": "^3.0.0",
  "@types/ws": "^7.2.6",
  "@types/yup": "^0.29.7",
  jest: "27.0.6",
  "jest-diff": "27.0.6",
  "jest-file-snapshot": "^0.5.0",
  "jest-matcher-utils": "27.0.6",
  nodemon: "^2.0.4",
  typescript: "^4.3.5"
};
var package_default = {
  name,
  version,
  main,
  typings,
  files,
  license,
  buildConfig,
  scripts,
  dependencies,
  publishConfig,
  repository,
  devDependencies
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/resolver/error.ts
var TinaError = class extends Error {
  constructor(message, extensions) {
    super(message);
    if (!this.name) {
      Object.defineProperty(this, "name", { value: "TinaError" });
    }
    this.extensions = __spreadValues({}, extensions);
  }
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/schema/index.ts
var createSchema = async ({
  schema,
  flags = []
}) => {
  const validSchema = await validateSchema(schema);
  const [major, minor, patch] = package_default.version.split(".");
  const meta = {};
  if (flags && flags.length > 0) {
    meta["flags"] = flags;
  }
  return new TinaSchema(__spreadValues({
    version: {
      fullVersion: package_default.version,
      major,
      minor,
      patch
    },
    meta
  }, validSchema));
};
var TinaSchema = class {
  constructor(config) {
    this.config = config;
    this.getCollectionsByName = (collectionNames) => {
      return this.schema.collections.filter((collection) => collectionNames.includes(collection.name));
    };
    this.getAllCollectionPaths = () => {
      const paths = this.getCollections().map((collection) => `${collection.path}${collection.match || ""}`);
      return paths;
    };
    this.getCollection = (collectionName) => {
      const collection = this.schema.collections.find((collection2) => collection2.name === collectionName);
      if (!collection) {
        throw new Error(`Expected to find collection named ${collectionName}`);
      }
      const extraFields = {};
      const templateInfo = this.getTemplatesForCollectable(collection);
      switch (templateInfo.type) {
        case "object":
          extraFields["fields"] = templateInfo.template.fields;
          break;
        case "union":
          extraFields["templates"] = templateInfo.templates;
          break;
      }
      return __spreadProps(__spreadValues(__spreadValues({
        slug: collection.name
      }, extraFields), collection), {
        format: collection.format || "md"
      });
    };
    this.getCollections = () => {
      return this.schema.collections.map((collection) => this.getCollection(collection.name)) || [];
    };
    this.getGlobalTemplate = (templateName) => {
      var _a;
      const globalTemplate = (_a = this.schema.templates) == null ? void 0 : _a.find((template) => template.name === templateName);
      if (!globalTemplate) {
        throw new Error(`Expected to find global template of name ${templateName}`);
      }
      return globalTemplate;
    };
    this.getCollectionByFullPath = async (filepath) => {
      const collection = this.getCollections().find((collection2) => {
        return filepath.replace("\\", "/").startsWith(collection2.path);
      });
      if (!collection) {
        throw new Error(`Unable to find collection for file at ${filepath}`);
      }
      return collection;
    };
    this.getCollectionAndTemplateByFullPath = async (filepath, templateName) => {
      let template;
      const collection = this.getCollections().find((collection2) => {
        return filepath.replace("\\", "/").startsWith(collection2.path);
      });
      if (!collection) {
        throw new Error(`Unable to find collection for file at ${filepath}`);
      }
      const templates = this.getTemplatesForCollectable(collection);
      if (templates.type === "union") {
        if (templateName) {
          template = templates.templates.find((template2) => lastItem(template2.namespace) === templateName);
          if (!template) {
            throw new Error(`Unable to determine template for item at ${filepath}`);
          }
        } else {
          throw new Error(`Unable to determine template for item at ${filepath}, no template name provided for collection with multiple templates`);
        }
      }
      if (templates.type === "object") {
        template = templates.template;
      }
      if (!template) {
        throw new Error(`Something went wrong while trying to determine template for ${filepath}`);
      }
      return { collection, template };
    };
    this.getTemplateForData = async ({
      data,
      collection
    }) => {
      const templateInfo = this.getTemplatesForCollectable(collection);
      switch (templateInfo.type) {
        case "object":
          return templateInfo.template;
        case "union":
          assertShape(data, (yup3) => yup3.object({ _template: yup3.string().required() }));
          const template = templateInfo.templates.find((template2) => template2.namespace[template2.namespace.length - 1] === data._template);
          if (!template) {
            throw new TinaError(`Expected to find template named '${data._template}' for collection '${lastItem(collection.namespace)}'`, {
              collection: lastItem(collection.namespace),
              possibleTemplates: templateInfo.templates.map((template2) => lastItem(template2.namespace)),
              data
            });
          }
          return template;
      }
    };
    this.isMarkdownCollection = (collectionName) => {
      const collection = this.getCollection(collectionName);
      const format = collection.format;
      if (!format) {
        return true;
      }
      if (["markdown", "md"].includes(format)) {
        return true;
      }
      return false;
    };
    this.getTemplatesForCollectable = (collection) => {
      let extraFields = [];
      if (collection.references) {
        extraFields = collection.references;
      }
      if (collection.fields) {
        const template = typeof collection.fields === "string" ? this.getGlobalTemplate(collection.fields) : collection;
        if (typeof template.fields === "string" || typeof template.fields === "undefined") {
          throw new Error("Exptected template to have fields but none were found");
        }
        return {
          namespace: collection.namespace,
          type: "object",
          template: __spreadProps(__spreadValues({}, template), {
            fields: [...template.fields, ...extraFields]
          })
        };
      } else {
        if (collection.templates) {
          return {
            namespace: collection.namespace,
            type: "union",
            templates: collection.templates.map((templateOrTemplateString) => {
              const template = typeof templateOrTemplateString === "string" ? this.getGlobalTemplate(templateOrTemplateString) : templateOrTemplateString;
              return __spreadProps(__spreadValues({}, template), {
                fields: [...template.fields, ...extraFields]
              });
            })
          };
        } else {
          throw new Error(`Expected either fields or templates array to be defined on collection ${collection.namespace.join("_")}`);
        }
      }
    };
    this.schema = config;
  }
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/build.ts
var import_path = __toModule(require("path"));
var indexDB = async ({
  database,
  config,
  buildSDK = true
}) => {
  const flags = [];
  if (database.store.supportsIndexing()) {
    flags.push("experimentalData");
  }
  const tinaSchema = await createSchema({ schema: config, flags });
  const builder = await createBuilder({
    database,
    tinaSchema
  });
  const graphQLSchema = await _buildSchema(builder, tinaSchema);
  await database.indexData({ graphQLSchema, tinaSchema });
  if (buildSDK) {
    await _buildFragments(builder, tinaSchema, database.bridge.rootPath);
    await _buildQueries(builder, tinaSchema, database.bridge.rootPath);
  }
};
var _buildFragments = async (builder, tinaSchema, rootPath) => {
  const fragmentDefinitionsFields = [];
  const collections = tinaSchema.getCollections();
  await sequential(collections, async (collection) => {
    const frag = await builder.collectionFragment(collection);
    fragmentDefinitionsFields.push(frag);
  });
  const fragDoc = {
    kind: "Document",
    definitions: import_lodash3.default.uniqBy(extractInlineTypes(fragmentDefinitionsFields), (node) => node.name.value)
  };
  const fragPath = import_path.default.join(rootPath, ".tina", "__generated__");
  await import_fs_extra.default.outputFileSync(import_path.default.join(fragPath, "frags.gql"), (0, import_graphql2.print)(fragDoc));
};
var _buildQueries = async (builder, tinaSchema, rootPath) => {
  const operationsDefinitions = [];
  const collections = tinaSchema.getCollections();
  await sequential(collections, async (collection) => {
    const queryName = NAMER.queryName(collection.namespace);
    const queryListName = NAMER.generateQueryListName(collection.namespace);
    const fragName = NAMER.fragmentName(collection.namespace);
    operationsDefinitions.push(astBuilder.QueryOperationDefinition({ fragName, queryName }));
    operationsDefinitions.push(astBuilder.ListQueryOperationDefinition({
      fragName,
      queryName: queryListName
    }));
  });
  const queryDoc = {
    kind: "Document",
    definitions: import_lodash3.default.uniqBy(extractInlineTypes(operationsDefinitions), (node) => node.name.value)
  };
  const fragPath = import_path.default.join(rootPath, ".tina", "__generated__");
  await import_fs_extra.default.outputFileSync(import_path.default.join(fragPath, "queries.gql"), (0, import_graphql2.print)(queryDoc));
};
var _buildSchema = async (builder, tinaSchema) => {
  const definitions = [];
  definitions.push(await builder.buildStaticDefinitions());
  const queryTypeDefinitionFields = [];
  const mutationTypeDefinitionFields = [];
  const collections = tinaSchema.getCollections();
  queryTypeDefinitionFields.push(await builder.buildCollectionDefinition(collections));
  queryTypeDefinitionFields.push(await builder.buildMultiCollectionDefinition(collections));
  queryTypeDefinitionFields.push(await builder.multiNodeDocument());
  queryTypeDefinitionFields.push(await builder.multiCollectionDocument(collections));
  mutationTypeDefinitionFields.push(await builder.addMultiCollectionDocumentMutation());
  mutationTypeDefinitionFields.push(await builder.buildUpdateCollectionDocumentMutation(collections));
  mutationTypeDefinitionFields.push(await builder.buildCreateCollectionDocumentMutation(collections));
  queryTypeDefinitionFields.push(await builder.multiCollectionDocumentList(collections));
  queryTypeDefinitionFields.push(await builder.multiCollectionDocumentFields());
  await sequential(collections, async (collection) => {
    queryTypeDefinitionFields.push(await builder.collectionDocument(collection));
    mutationTypeDefinitionFields.push(await builder.updateCollectionDocumentMutation(collection));
    mutationTypeDefinitionFields.push(await builder.createCollectionDocumentMutation(collection));
    queryTypeDefinitionFields.push(await builder.collectionDocumentList(collection));
  });
  definitions.push(astBuilder.ObjectTypeDefinition({
    name: "Query",
    fields: queryTypeDefinitionFields
  }));
  definitions.push(astBuilder.ObjectTypeDefinition({
    name: "Mutation",
    fields: mutationTypeDefinitionFields
  }));
  const doc = {
    kind: "Document",
    definitions: import_lodash3.default.uniqBy(extractInlineTypes(definitions), (node) => node.name.value)
  };
  return doc;
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/resolve.ts
var import_lodash6 = __toModule(require("lodash"));
var import_graphql3 = __toModule(require("graphql"));

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/resolver/index.ts
var import_lodash5 = __toModule(require("lodash"));
var import_path3 = __toModule(require("path"));
var import_isValid = __toModule(require_isValid());

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/bail-npm-2.0.1-faf99b7186-eab36a71a1.zip/node_modules/bail/index.js
function bail(error) {
  if (error) {
    throw error;
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/unified-npm-10.1.0-d9f1f63894-dc12b62fd1.zip/node_modules/unified/lib/index.js
var import_is_buffer2 = __toModule(require_is_buffer());
var import_extend = __toModule(require_extend());

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/is-plain-obj-npm-4.0.0-5401ea0d12-038d9cd004.zip/node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/trough-npm-2.0.2-8482cac42b-35f021ad91.zip/node_modules/trough/index.js
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values[index2];
        }
      }
      values = output;
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError("Expected `middelware` to be a function, not " + middelware);
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware(...parameters);
    } catch (error) {
      const exception = error;
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result instanceof Promise) {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/vfile-npm-5.1.0-4fbf325323-b36786f162.zip/node_modules/vfile/lib/index.js
var import_is_buffer = __toModule(require_is_buffer());

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/unist-util-stringify-position-npm-3.0.0-c58b9a941e-189255b241.zip/node_modules/unist-util-stringify-position/index.js
var own = {}.hasOwnProperty;
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if (own.call(value, "position") || own.call(value, "type")) {
    return position(value.position);
  }
  if (own.call(value, "start") || own.call(value, "end")) {
    return position(value);
  }
  if (own.call(value, "line") || own.call(value, "column")) {
    return point(value);
  }
  return "";
}
function point(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/vfile-message-npm-3.0.2-7ab93a669e-276974ee27.zip/node_modules/vfile-message/index.js
var VFileMessage = class extends Error {
  constructor(reason, place, origin) {
    var parts = [null, null];
    var position2 = {
      start: { line: null, column: null },
      end: { line: null, column: null }
    };
    var index2;
    super();
    if (typeof place === "string") {
      origin = place;
      place = null;
    }
    if (typeof origin === "string") {
      index2 = origin.indexOf(":");
      if (index2 === -1) {
        parts[1] = origin;
      } else {
        parts[0] = origin.slice(0, index2);
        parts[1] = origin.slice(index2 + 1);
      }
    }
    if (place) {
      if ("type" in place || "position" in place) {
        if (place.position) {
          position2 = place.position;
        }
      } else if ("start" in place || "end" in place) {
        position2 = place;
      } else if ("line" in place || "column" in place) {
        position2.start = place;
      }
    }
    this.name = stringifyPosition(place) || "1:1";
    this.message = typeof reason === "object" ? reason.message : reason;
    this.stack = typeof reason === "object" ? reason.stack : "";
    this.reason = this.message;
    this.line = position2.start.line;
    this.column = position2.start.column;
    this.source = parts[0];
    this.ruleId = parts[1];
    this.position = position2;
    this.file;
    this.fatal;
    this.url;
    this.note;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/vfile-npm-5.1.0-4fbf325323-b36786f162.zip/node_modules/vfile/lib/minpath.js
var import_path2 = __toModule(require("path"));

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/vfile-npm-5.1.0-4fbf325323-b36786f162.zip/node_modules/vfile/lib/minproc.js
var import_process = __toModule(require("process"));
var proc = import_process.default;

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/vfile-npm-5.1.0-4fbf325323-b36786f162.zip/node_modules/vfile/lib/minurl.js
var import_url = __toModule(require("url"));

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/vfile-npm-5.1.0-4fbf325323-b36786f162.zip/node_modules/vfile/lib/minurl.shared.js
function isUrl(fileURLOrPath) {
  return fileURLOrPath !== null && typeof fileURLOrPath === "object" && fileURLOrPath.href && fileURLOrPath.origin;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/vfile-npm-5.1.0-4fbf325323-b36786f162.zip/node_modules/vfile/lib/index.js
var order = ["history", "path", "basename", "stem", "extname", "dirname"];
var VFile = class {
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (typeof value === "string" || (0, import_is_buffer.default)(value)) {
      options = { value };
    } else if (isUrl(value)) {
      options = { path: value };
    } else {
      options = value;
    }
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = proc.cwd();
    this.value;
    this.stored;
    this.result;
    this.map;
    let index2 = -1;
    while (++index2 < order.length) {
      const prop2 = order[index2];
      if (prop2 in options && options[prop2] !== void 0) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order.includes(prop))
        this[prop] = options[prop];
    }
  }
  get path() {
    return this.history[this.history.length - 1];
  }
  set path(path6) {
    if (isUrl(path6)) {
      path6 = (0, import_url.fileURLToPath)(path6);
    }
    assertNonEmpty(path6, "path");
    if (this.path !== path6) {
      this.history.push(path6);
    }
  }
  get dirname() {
    return typeof this.path === "string" ? import_path2.default.dirname(this.path) : void 0;
  }
  set dirname(dirname) {
    assertPath(this.basename, "dirname");
    this.path = import_path2.default.join(dirname || "", this.basename);
  }
  get basename() {
    return typeof this.path === "string" ? import_path2.default.basename(this.path) : void 0;
  }
  set basename(basename) {
    assertNonEmpty(basename, "basename");
    assertPart(basename, "basename");
    this.path = import_path2.default.join(this.dirname || "", basename);
  }
  get extname() {
    return typeof this.path === "string" ? import_path2.default.extname(this.path) : void 0;
  }
  set extname(extname) {
    assertPart(extname, "extname");
    assertPath(this.dirname, "extname");
    if (extname) {
      if (extname.charCodeAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = import_path2.default.join(this.dirname, this.stem + (extname || ""));
  }
  get stem() {
    return typeof this.path === "string" ? import_path2.default.basename(this.path, this.extname) : void 0;
  }
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = import_path2.default.join(this.dirname || "", stem + (this.extname || ""));
  }
  toString(encoding) {
    return (this.value || "").toString(encoding);
  }
  message(reason, place, origin) {
    const message = new VFileMessage(reason, place, origin);
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  info(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = null;
    return message;
  }
  fail(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = true;
    throw message;
  }
};
function assertPart(part, name2) {
  if (part && part.includes(import_path2.default.sep)) {
    throw new Error("`" + name2 + "` cannot be a path: did not expect `" + import_path2.default.sep + "`");
  }
}
function assertNonEmpty(part, name2) {
  if (!part) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath(path6, name2) {
  if (!path6) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/unified-npm-10.1.0-d9f1f63894-dc12b62fd1.zip/node_modules/unified/lib/index.js
var unified = base().freeze();
var own2 = {}.hasOwnProperty;
function base() {
  const transformers = trough();
  const attachers = [];
  let namespace = {};
  let frozen;
  let freezeIndex = -1;
  processor.data = data;
  processor.Parser = void 0;
  processor.Compiler = void 0;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse3;
  processor.stringify = stringify2;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process2;
  processor.processSync = processSync;
  return processor;
  function processor() {
    const destination = base();
    let index2 = -1;
    while (++index2 < attachers.length) {
      destination.use(...attachers[index2]);
    }
    destination.data((0, import_extend.default)(true, {}, namespace));
    return destination;
  }
  function data(key2, value) {
    if (typeof key2 === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key2] = value;
        return processor;
      }
      return own2.call(namespace, key2) && namespace[key2] || null;
    }
    if (key2) {
      assertUnfrozen("data", frozen);
      namespace = key2;
      return processor;
    }
    return namespace;
  }
  function freeze() {
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      const [attacher, ...options] = attachers[freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[1] = void 0;
      }
      const transformer = attacher.call(processor, ...options);
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Number.POSITIVE_INFINITY;
    return processor;
  }
  function use(value, ...options) {
    let settings;
    assertUnfrozen("use", frozen);
    if (value === null || value === void 0) {
    } else if (typeof value === "function") {
      addPlugin(value, ...options);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace.settings = Object.assign(namespace.settings || {}, settings);
    }
    return processor;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...options2] = value2;
          addPlugin(plugin, ...options2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value2) {
      let index2 = -1;
      let entry;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entry = attachers[index2];
          break;
        }
      }
      if (entry) {
        if (isPlainObject(entry[1]) && isPlainObject(value2)) {
          value2 = (0, import_extend.default)(true, entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push([...arguments]);
      }
    }
  }
  function parse3(doc) {
    processor.freeze();
    const file = vfile(doc);
    const Parser = processor.Parser;
    assertParser("parse", Parser);
    if (newable(Parser, "parse")) {
      return new Parser(String(file), file).parse();
    }
    return Parser(String(file), file);
  }
  function stringify2(node, doc) {
    processor.freeze();
    const file = vfile(doc);
    const Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node);
    if (newable(Compiler, "compile")) {
      return new Compiler(node, file).compile();
    }
    return Compiler(node, file);
  }
  function run(node, doc, callback) {
    assertNode(node);
    processor.freeze();
    if (!callback && typeof doc === "function") {
      callback = doc;
      doc = void 0;
    }
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve2, reject) {
      transformers.run(node, vfile(doc), done);
      function done(error, tree, file) {
        tree = tree || node;
        if (error) {
          reject(error);
        } else if (resolve2) {
          resolve2(tree);
        } else {
          callback(null, tree, file);
        }
      }
    }
  }
  function runSync(node, file) {
    let result;
    let complete;
    processor.run(node, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(error, tree) {
      bail(error);
      result = tree;
      complete = true;
    }
  }
  function process2(doc, callback) {
    processor.freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve2, reject) {
      const file = vfile(doc);
      processor.run(processor.parse(file), file, (error, tree, file2) => {
        if (error || !tree || !file2) {
          done(error);
        } else {
          const result = processor.stringify(tree, file2);
          if (result === void 0 || result === null) {
          } else if (looksLikeAVFileValue(result)) {
            file2.value = result;
          } else {
            file2.result = result;
          }
          done(error, file2);
        }
      });
      function done(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve2) {
          resolve2(file2);
        } else {
          callback(null, file2);
        }
      }
    }
  }
  function processSync(doc) {
    let complete;
    processor.freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    const file = vfile(doc);
    processor.process(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(error) {
      complete = true;
      bail(error);
    }
  }
}
function newable(value, name2) {
  return typeof value === "function" && value.prototype && (keys(value.prototype) || name2 in value.prototype);
}
function keys(value) {
  let key2;
  for (key2 in value) {
    if (own2.call(value, key2)) {
      return true;
    }
  }
  return false;
}
function assertParser(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `Parser`");
  }
}
function assertCompiler(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `Compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error("Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.");
  }
}
function assertNode(node) {
  if (!isPlainObject(node) || typeof node.type !== "string") {
    throw new TypeError("Expected node, got `" + node + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error("`" + name2 + "` finished async. Use `" + asyncName + "` instead");
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(value && typeof value === "object" && "message" in value && "messages" in value);
}
function looksLikeAVFileValue(value) {
  return typeof value === "string" || (0, import_is_buffer2.default)(value);
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-string-npm-3.1.0-d888f00663-0669bc25c0.zip/node_modules/mdast-util-to-string/index.js
function toString(node, options) {
  var { includeImageAlt = true } = options || {};
  return one(node, includeImageAlt);
}
function one(node, includeImageAlt) {
  return node && typeof node === "object" && (node.value || (includeImageAlt ? node.alt : "") || "children" in node && all(node.children, includeImageAlt) || Array.isArray(node) && all(node, includeImageAlt)) || "";
}
function all(values, includeImageAlt) {
  var result = [];
  var index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one(values[index2], includeImageAlt);
  }
  return result.join("");
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-util-chunked-npm-1.0.0-456e2b513f-0d05f0a76a.zip/node_modules/micromark-util-chunked/index.js
function splice(list3, start, remove, items) {
  const end = list3.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    [].splice.apply(list3, parameters);
  } else {
    if (remove)
      [].splice.apply(list3, [start, remove]);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      [].splice.apply(list3, parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push(list3, items) {
  if (list3.length > 0) {
    splice(list3, list3.length, 0, items);
    return list3;
  }
  return items;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-util-combine-extensions-npm-1.0.0-f13e57de5b-0b6ade34a9.zip/node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code2;
    for (code2 in right) {
      if (!hasOwnProperty.call(left, code2))
        left[code2] = [];
      const value = right[code2];
      constructs(left[code2], Array.isArray(value) ? value : value ? [value] : []);
    }
  }
}
function constructs(existing, list3) {
  let index2 = -1;
  const before = [];
  while (++index2 < list3.length) {
    ;
    (list3[index2].add === "after" ? existing : before).push(list3[index2]);
  }
  splice(existing, 0, 0, before);
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-util-character-npm-1.1.0-fe6b5d2ff8-53f740a106.zip/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js
var unicodePunctuationRegex = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-util-character-npm-1.1.0-fe6b5d2ff8-53f740a106.zip/node_modules/micromark-util-character/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return code2 !== null && (code2 < 32 || code2 === 127);
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
var unicodeWhitespace = regexCheck(/\s/);
var unicodePunctuation = regexCheck(unicodePunctuationRegex);
function regexCheck(regex) {
  return check;
  function check(code2) {
    return code2 !== null && regex.test(String.fromCharCode(code2));
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-factory-space-npm-1.0.0-e5fee5c60c-0dabcced79.zip/node_modules/micromark-factory-space/index.js
function factorySpace(effects, ok2, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type);
      return prefix(code2);
    }
    return ok2(code2);
  }
  function prefix(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type);
    return ok2(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-3.0.7-da94deb9a9-741af00392.zip/node_modules/micromark/lib/initialize/content.js
var content = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code2) {
    effects.enter("paragraph");
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-3.0.7-da94deb9a9-741af00392.zip/node_modules/micromark/lib/initialize/document.js
var document = {
  tokenize: initializeDocument
};
var containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          point2 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
      self2.events.length = index2;
      return checkNewContainers(code2);
    }
    return start(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self2.interrupt = Boolean(childFlow.currentConstruct);
    }
    self2.containerState = {};
    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self2.containerState = {};
    return effects.attempt(containerConstruct, containerContinue, flowStart)(code2);
  }
  function containerContinue(code2) {
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === null) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self2.interrupt = void 0;
      return start;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    const stream = self2.sliceStream(token);
    if (eof)
      stream.push(null);
    token.previous = childToken;
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (childFlow.events[index2][1].start.offset < lineStartOffset && (!childFlow.events[index2][1].end || childFlow.events[index2][1].end.offset > lineStartOffset)) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point2 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-util-classify-character-npm-1.0.0-68787d9dc2-151d6ae297.zip/node_modules/micromark-util-classify-character/index.js
function classifyCharacter(code2) {
  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return 1;
  }
  if (unicodePunctuation(code2)) {
    return 2;
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-util-resolve-all-npm-1.0.0-cb1a6324ae-f0b434e666.zip/node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve2 = constructs2[index2].resolveAll;
    if (resolve2 && !called.includes(resolve2)) {
      events = resolve2(events, context);
      called.push(resolve2);
    }
  }
  return events;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/attention.js
var attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text4;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index2][1].start);
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index2][1].start),
            end
          };
          text4 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text4, context]
          ]);
          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
          nextEvents = push(nextEvents, [
            ["exit", text4, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter(previous2);
  let marker;
  return start;
  function start(code2) {
    effects.enter("attentionSequence");
    marker = code2;
    return sequence(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return sequence;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
    const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
    token._open = Boolean(marker === 42 ? open : open && (before || !close));
    token._close = Boolean(marker === 42 ? close : close && (after || !open));
    return ok2(code2);
  }
}
function movePoint(point2, offset) {
  point2.column += offset;
  point2.offset += offset;
  point2._bufferIndex += offset;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/autolink.js
var autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  let size = 1;
  return start;
  function start(code2) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    return asciiAtext(code2) ? emailAtext(code2) : nok(code2);
  }
  function schemeOrEmailAtext(code2) {
    return code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2) ? schemeInsideOrEmailAtext(code2) : emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      return urlInside;
    }
    if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === 62) {
      effects.exit("autolinkProtocol");
      return end(code2);
    }
    if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === 64) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      return end(code2);
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
      effects.consume(code2);
      return code2 === 45 ? emailValue : emailLabel;
    }
    return nok(code2);
  }
  function end(code2) {
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.exit("autolink");
    return ok2;
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/blank-line.js
var blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok2, nok) {
  return factorySpace(effects, afterWhitespace, "linePrefix");
  function afterWhitespace(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/block-quote.js
var blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 === 62) {
      const state = self2.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code2);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code2);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok2;
    }
    effects.exit("blockQuotePrefix");
    return ok2(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  return factorySpace(effects, effects.attempt(blockQuote, ok2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function exit(effects) {
  effects.exit("blockQuote");
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    effects.exit("escapeMarker");
    return open;
  }
  function open(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter("characterEscapeValue");
      effects.consume(code2);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok2;
    }
    return nok(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/character-entities-npm-2.0.0-a1231c818e-f2c7ced245.zip/node_modules/character-entities/index.js
var characterEntities = {
  AEli: "\xC6",
  AElig: "\xC6",
  AM: "&",
  AMP: "&",
  Aacut: "\xC1",
  Aacute: "\xC1",
  Abreve: "\u0102",
  Acir: "\xC2",
  Acirc: "\xC2",
  Acy: "\u0410",
  Afr: "\u{1D504}",
  Agrav: "\xC0",
  Agrave: "\xC0",
  Alpha: "\u0391",
  Amacr: "\u0100",
  And: "\u2A53",
  Aogon: "\u0104",
  Aopf: "\u{1D538}",
  ApplyFunction: "\u2061",
  Arin: "\xC5",
  Aring: "\xC5",
  Ascr: "\u{1D49C}",
  Assign: "\u2254",
  Atild: "\xC3",
  Atilde: "\xC3",
  Aum: "\xC4",
  Auml: "\xC4",
  Backslash: "\u2216",
  Barv: "\u2AE7",
  Barwed: "\u2306",
  Bcy: "\u0411",
  Because: "\u2235",
  Bernoullis: "\u212C",
  Beta: "\u0392",
  Bfr: "\u{1D505}",
  Bopf: "\u{1D539}",
  Breve: "\u02D8",
  Bscr: "\u212C",
  Bumpeq: "\u224E",
  CHcy: "\u0427",
  COP: "\xA9",
  COPY: "\xA9",
  Cacute: "\u0106",
  Cap: "\u22D2",
  CapitalDifferentialD: "\u2145",
  Cayleys: "\u212D",
  Ccaron: "\u010C",
  Ccedi: "\xC7",
  Ccedil: "\xC7",
  Ccirc: "\u0108",
  Cconint: "\u2230",
  Cdot: "\u010A",
  Cedilla: "\xB8",
  CenterDot: "\xB7",
  Cfr: "\u212D",
  Chi: "\u03A7",
  CircleDot: "\u2299",
  CircleMinus: "\u2296",
  CirclePlus: "\u2295",
  CircleTimes: "\u2297",
  ClockwiseContourIntegral: "\u2232",
  CloseCurlyDoubleQuote: "\u201D",
  CloseCurlyQuote: "\u2019",
  Colon: "\u2237",
  Colone: "\u2A74",
  Congruent: "\u2261",
  Conint: "\u222F",
  ContourIntegral: "\u222E",
  Copf: "\u2102",
  Coproduct: "\u2210",
  CounterClockwiseContourIntegral: "\u2233",
  Cross: "\u2A2F",
  Cscr: "\u{1D49E}",
  Cup: "\u22D3",
  CupCap: "\u224D",
  DD: "\u2145",
  DDotrahd: "\u2911",
  DJcy: "\u0402",
  DScy: "\u0405",
  DZcy: "\u040F",
  Dagger: "\u2021",
  Darr: "\u21A1",
  Dashv: "\u2AE4",
  Dcaron: "\u010E",
  Dcy: "\u0414",
  Del: "\u2207",
  Delta: "\u0394",
  Dfr: "\u{1D507}",
  DiacriticalAcute: "\xB4",
  DiacriticalDot: "\u02D9",
  DiacriticalDoubleAcute: "\u02DD",
  DiacriticalGrave: "`",
  DiacriticalTilde: "\u02DC",
  Diamond: "\u22C4",
  DifferentialD: "\u2146",
  Dopf: "\u{1D53B}",
  Dot: "\xA8",
  DotDot: "\u20DC",
  DotEqual: "\u2250",
  DoubleContourIntegral: "\u222F",
  DoubleDot: "\xA8",
  DoubleDownArrow: "\u21D3",
  DoubleLeftArrow: "\u21D0",
  DoubleLeftRightArrow: "\u21D4",
  DoubleLeftTee: "\u2AE4",
  DoubleLongLeftArrow: "\u27F8",
  DoubleLongLeftRightArrow: "\u27FA",
  DoubleLongRightArrow: "\u27F9",
  DoubleRightArrow: "\u21D2",
  DoubleRightTee: "\u22A8",
  DoubleUpArrow: "\u21D1",
  DoubleUpDownArrow: "\u21D5",
  DoubleVerticalBar: "\u2225",
  DownArrow: "\u2193",
  DownArrowBar: "\u2913",
  DownArrowUpArrow: "\u21F5",
  DownBreve: "\u0311",
  DownLeftRightVector: "\u2950",
  DownLeftTeeVector: "\u295E",
  DownLeftVector: "\u21BD",
  DownLeftVectorBar: "\u2956",
  DownRightTeeVector: "\u295F",
  DownRightVector: "\u21C1",
  DownRightVectorBar: "\u2957",
  DownTee: "\u22A4",
  DownTeeArrow: "\u21A7",
  Downarrow: "\u21D3",
  Dscr: "\u{1D49F}",
  Dstrok: "\u0110",
  ENG: "\u014A",
  ET: "\xD0",
  ETH: "\xD0",
  Eacut: "\xC9",
  Eacute: "\xC9",
  Ecaron: "\u011A",
  Ecir: "\xCA",
  Ecirc: "\xCA",
  Ecy: "\u042D",
  Edot: "\u0116",
  Efr: "\u{1D508}",
  Egrav: "\xC8",
  Egrave: "\xC8",
  Element: "\u2208",
  Emacr: "\u0112",
  EmptySmallSquare: "\u25FB",
  EmptyVerySmallSquare: "\u25AB",
  Eogon: "\u0118",
  Eopf: "\u{1D53C}",
  Epsilon: "\u0395",
  Equal: "\u2A75",
  EqualTilde: "\u2242",
  Equilibrium: "\u21CC",
  Escr: "\u2130",
  Esim: "\u2A73",
  Eta: "\u0397",
  Eum: "\xCB",
  Euml: "\xCB",
  Exists: "\u2203",
  ExponentialE: "\u2147",
  Fcy: "\u0424",
  Ffr: "\u{1D509}",
  FilledSmallSquare: "\u25FC",
  FilledVerySmallSquare: "\u25AA",
  Fopf: "\u{1D53D}",
  ForAll: "\u2200",
  Fouriertrf: "\u2131",
  Fscr: "\u2131",
  GJcy: "\u0403",
  G: ">",
  GT: ">",
  Gamma: "\u0393",
  Gammad: "\u03DC",
  Gbreve: "\u011E",
  Gcedil: "\u0122",
  Gcirc: "\u011C",
  Gcy: "\u0413",
  Gdot: "\u0120",
  Gfr: "\u{1D50A}",
  Gg: "\u22D9",
  Gopf: "\u{1D53E}",
  GreaterEqual: "\u2265",
  GreaterEqualLess: "\u22DB",
  GreaterFullEqual: "\u2267",
  GreaterGreater: "\u2AA2",
  GreaterLess: "\u2277",
  GreaterSlantEqual: "\u2A7E",
  GreaterTilde: "\u2273",
  Gscr: "\u{1D4A2}",
  Gt: "\u226B",
  HARDcy: "\u042A",
  Hacek: "\u02C7",
  Hat: "^",
  Hcirc: "\u0124",
  Hfr: "\u210C",
  HilbertSpace: "\u210B",
  Hopf: "\u210D",
  HorizontalLine: "\u2500",
  Hscr: "\u210B",
  Hstrok: "\u0126",
  HumpDownHump: "\u224E",
  HumpEqual: "\u224F",
  IEcy: "\u0415",
  IJlig: "\u0132",
  IOcy: "\u0401",
  Iacut: "\xCD",
  Iacute: "\xCD",
  Icir: "\xCE",
  Icirc: "\xCE",
  Icy: "\u0418",
  Idot: "\u0130",
  Ifr: "\u2111",
  Igrav: "\xCC",
  Igrave: "\xCC",
  Im: "\u2111",
  Imacr: "\u012A",
  ImaginaryI: "\u2148",
  Implies: "\u21D2",
  Int: "\u222C",
  Integral: "\u222B",
  Intersection: "\u22C2",
  InvisibleComma: "\u2063",
  InvisibleTimes: "\u2062",
  Iogon: "\u012E",
  Iopf: "\u{1D540}",
  Iota: "\u0399",
  Iscr: "\u2110",
  Itilde: "\u0128",
  Iukcy: "\u0406",
  Ium: "\xCF",
  Iuml: "\xCF",
  Jcirc: "\u0134",
  Jcy: "\u0419",
  Jfr: "\u{1D50D}",
  Jopf: "\u{1D541}",
  Jscr: "\u{1D4A5}",
  Jsercy: "\u0408",
  Jukcy: "\u0404",
  KHcy: "\u0425",
  KJcy: "\u040C",
  Kappa: "\u039A",
  Kcedil: "\u0136",
  Kcy: "\u041A",
  Kfr: "\u{1D50E}",
  Kopf: "\u{1D542}",
  Kscr: "\u{1D4A6}",
  LJcy: "\u0409",
  L: "<",
  LT: "<",
  Lacute: "\u0139",
  Lambda: "\u039B",
  Lang: "\u27EA",
  Laplacetrf: "\u2112",
  Larr: "\u219E",
  Lcaron: "\u013D",
  Lcedil: "\u013B",
  Lcy: "\u041B",
  LeftAngleBracket: "\u27E8",
  LeftArrow: "\u2190",
  LeftArrowBar: "\u21E4",
  LeftArrowRightArrow: "\u21C6",
  LeftCeiling: "\u2308",
  LeftDoubleBracket: "\u27E6",
  LeftDownTeeVector: "\u2961",
  LeftDownVector: "\u21C3",
  LeftDownVectorBar: "\u2959",
  LeftFloor: "\u230A",
  LeftRightArrow: "\u2194",
  LeftRightVector: "\u294E",
  LeftTee: "\u22A3",
  LeftTeeArrow: "\u21A4",
  LeftTeeVector: "\u295A",
  LeftTriangle: "\u22B2",
  LeftTriangleBar: "\u29CF",
  LeftTriangleEqual: "\u22B4",
  LeftUpDownVector: "\u2951",
  LeftUpTeeVector: "\u2960",
  LeftUpVector: "\u21BF",
  LeftUpVectorBar: "\u2958",
  LeftVector: "\u21BC",
  LeftVectorBar: "\u2952",
  Leftarrow: "\u21D0",
  Leftrightarrow: "\u21D4",
  LessEqualGreater: "\u22DA",
  LessFullEqual: "\u2266",
  LessGreater: "\u2276",
  LessLess: "\u2AA1",
  LessSlantEqual: "\u2A7D",
  LessTilde: "\u2272",
  Lfr: "\u{1D50F}",
  Ll: "\u22D8",
  Lleftarrow: "\u21DA",
  Lmidot: "\u013F",
  LongLeftArrow: "\u27F5",
  LongLeftRightArrow: "\u27F7",
  LongRightArrow: "\u27F6",
  Longleftarrow: "\u27F8",
  Longleftrightarrow: "\u27FA",
  Longrightarrow: "\u27F9",
  Lopf: "\u{1D543}",
  LowerLeftArrow: "\u2199",
  LowerRightArrow: "\u2198",
  Lscr: "\u2112",
  Lsh: "\u21B0",
  Lstrok: "\u0141",
  Lt: "\u226A",
  Map: "\u2905",
  Mcy: "\u041C",
  MediumSpace: "\u205F",
  Mellintrf: "\u2133",
  Mfr: "\u{1D510}",
  MinusPlus: "\u2213",
  Mopf: "\u{1D544}",
  Mscr: "\u2133",
  Mu: "\u039C",
  NJcy: "\u040A",
  Nacute: "\u0143",
  Ncaron: "\u0147",
  Ncedil: "\u0145",
  Ncy: "\u041D",
  NegativeMediumSpace: "\u200B",
  NegativeThickSpace: "\u200B",
  NegativeThinSpace: "\u200B",
  NegativeVeryThinSpace: "\u200B",
  NestedGreaterGreater: "\u226B",
  NestedLessLess: "\u226A",
  NewLine: "\n",
  Nfr: "\u{1D511}",
  NoBreak: "\u2060",
  NonBreakingSpace: "\xA0",
  Nopf: "\u2115",
  Not: "\u2AEC",
  NotCongruent: "\u2262",
  NotCupCap: "\u226D",
  NotDoubleVerticalBar: "\u2226",
  NotElement: "\u2209",
  NotEqual: "\u2260",
  NotEqualTilde: "\u2242\u0338",
  NotExists: "\u2204",
  NotGreater: "\u226F",
  NotGreaterEqual: "\u2271",
  NotGreaterFullEqual: "\u2267\u0338",
  NotGreaterGreater: "\u226B\u0338",
  NotGreaterLess: "\u2279",
  NotGreaterSlantEqual: "\u2A7E\u0338",
  NotGreaterTilde: "\u2275",
  NotHumpDownHump: "\u224E\u0338",
  NotHumpEqual: "\u224F\u0338",
  NotLeftTriangle: "\u22EA",
  NotLeftTriangleBar: "\u29CF\u0338",
  NotLeftTriangleEqual: "\u22EC",
  NotLess: "\u226E",
  NotLessEqual: "\u2270",
  NotLessGreater: "\u2278",
  NotLessLess: "\u226A\u0338",
  NotLessSlantEqual: "\u2A7D\u0338",
  NotLessTilde: "\u2274",
  NotNestedGreaterGreater: "\u2AA2\u0338",
  NotNestedLessLess: "\u2AA1\u0338",
  NotPrecedes: "\u2280",
  NotPrecedesEqual: "\u2AAF\u0338",
  NotPrecedesSlantEqual: "\u22E0",
  NotReverseElement: "\u220C",
  NotRightTriangle: "\u22EB",
  NotRightTriangleBar: "\u29D0\u0338",
  NotRightTriangleEqual: "\u22ED",
  NotSquareSubset: "\u228F\u0338",
  NotSquareSubsetEqual: "\u22E2",
  NotSquareSuperset: "\u2290\u0338",
  NotSquareSupersetEqual: "\u22E3",
  NotSubset: "\u2282\u20D2",
  NotSubsetEqual: "\u2288",
  NotSucceeds: "\u2281",
  NotSucceedsEqual: "\u2AB0\u0338",
  NotSucceedsSlantEqual: "\u22E1",
  NotSucceedsTilde: "\u227F\u0338",
  NotSuperset: "\u2283\u20D2",
  NotSupersetEqual: "\u2289",
  NotTilde: "\u2241",
  NotTildeEqual: "\u2244",
  NotTildeFullEqual: "\u2247",
  NotTildeTilde: "\u2249",
  NotVerticalBar: "\u2224",
  Nscr: "\u{1D4A9}",
  Ntild: "\xD1",
  Ntilde: "\xD1",
  Nu: "\u039D",
  OElig: "\u0152",
  Oacut: "\xD3",
  Oacute: "\xD3",
  Ocir: "\xD4",
  Ocirc: "\xD4",
  Ocy: "\u041E",
  Odblac: "\u0150",
  Ofr: "\u{1D512}",
  Ograv: "\xD2",
  Ograve: "\xD2",
  Omacr: "\u014C",
  Omega: "\u03A9",
  Omicron: "\u039F",
  Oopf: "\u{1D546}",
  OpenCurlyDoubleQuote: "\u201C",
  OpenCurlyQuote: "\u2018",
  Or: "\u2A54",
  Oscr: "\u{1D4AA}",
  Oslas: "\xD8",
  Oslash: "\xD8",
  Otild: "\xD5",
  Otilde: "\xD5",
  Otimes: "\u2A37",
  Oum: "\xD6",
  Ouml: "\xD6",
  OverBar: "\u203E",
  OverBrace: "\u23DE",
  OverBracket: "\u23B4",
  OverParenthesis: "\u23DC",
  PartialD: "\u2202",
  Pcy: "\u041F",
  Pfr: "\u{1D513}",
  Phi: "\u03A6",
  Pi: "\u03A0",
  PlusMinus: "\xB1",
  Poincareplane: "\u210C",
  Popf: "\u2119",
  Pr: "\u2ABB",
  Precedes: "\u227A",
  PrecedesEqual: "\u2AAF",
  PrecedesSlantEqual: "\u227C",
  PrecedesTilde: "\u227E",
  Prime: "\u2033",
  Product: "\u220F",
  Proportion: "\u2237",
  Proportional: "\u221D",
  Pscr: "\u{1D4AB}",
  Psi: "\u03A8",
  QUO: '"',
  QUOT: '"',
  Qfr: "\u{1D514}",
  Qopf: "\u211A",
  Qscr: "\u{1D4AC}",
  RBarr: "\u2910",
  RE: "\xAE",
  REG: "\xAE",
  Racute: "\u0154",
  Rang: "\u27EB",
  Rarr: "\u21A0",
  Rarrtl: "\u2916",
  Rcaron: "\u0158",
  Rcedil: "\u0156",
  Rcy: "\u0420",
  Re: "\u211C",
  ReverseElement: "\u220B",
  ReverseEquilibrium: "\u21CB",
  ReverseUpEquilibrium: "\u296F",
  Rfr: "\u211C",
  Rho: "\u03A1",
  RightAngleBracket: "\u27E9",
  RightArrow: "\u2192",
  RightArrowBar: "\u21E5",
  RightArrowLeftArrow: "\u21C4",
  RightCeiling: "\u2309",
  RightDoubleBracket: "\u27E7",
  RightDownTeeVector: "\u295D",
  RightDownVector: "\u21C2",
  RightDownVectorBar: "\u2955",
  RightFloor: "\u230B",
  RightTee: "\u22A2",
  RightTeeArrow: "\u21A6",
  RightTeeVector: "\u295B",
  RightTriangle: "\u22B3",
  RightTriangleBar: "\u29D0",
  RightTriangleEqual: "\u22B5",
  RightUpDownVector: "\u294F",
  RightUpTeeVector: "\u295C",
  RightUpVector: "\u21BE",
  RightUpVectorBar: "\u2954",
  RightVector: "\u21C0",
  RightVectorBar: "\u2953",
  Rightarrow: "\u21D2",
  Ropf: "\u211D",
  RoundImplies: "\u2970",
  Rrightarrow: "\u21DB",
  Rscr: "\u211B",
  Rsh: "\u21B1",
  RuleDelayed: "\u29F4",
  SHCHcy: "\u0429",
  SHcy: "\u0428",
  SOFTcy: "\u042C",
  Sacute: "\u015A",
  Sc: "\u2ABC",
  Scaron: "\u0160",
  Scedil: "\u015E",
  Scirc: "\u015C",
  Scy: "\u0421",
  Sfr: "\u{1D516}",
  ShortDownArrow: "\u2193",
  ShortLeftArrow: "\u2190",
  ShortRightArrow: "\u2192",
  ShortUpArrow: "\u2191",
  Sigma: "\u03A3",
  SmallCircle: "\u2218",
  Sopf: "\u{1D54A}",
  Sqrt: "\u221A",
  Square: "\u25A1",
  SquareIntersection: "\u2293",
  SquareSubset: "\u228F",
  SquareSubsetEqual: "\u2291",
  SquareSuperset: "\u2290",
  SquareSupersetEqual: "\u2292",
  SquareUnion: "\u2294",
  Sscr: "\u{1D4AE}",
  Star: "\u22C6",
  Sub: "\u22D0",
  Subset: "\u22D0",
  SubsetEqual: "\u2286",
  Succeeds: "\u227B",
  SucceedsEqual: "\u2AB0",
  SucceedsSlantEqual: "\u227D",
  SucceedsTilde: "\u227F",
  SuchThat: "\u220B",
  Sum: "\u2211",
  Sup: "\u22D1",
  Superset: "\u2283",
  SupersetEqual: "\u2287",
  Supset: "\u22D1",
  THOR: "\xDE",
  THORN: "\xDE",
  TRADE: "\u2122",
  TSHcy: "\u040B",
  TScy: "\u0426",
  Tab: "	",
  Tau: "\u03A4",
  Tcaron: "\u0164",
  Tcedil: "\u0162",
  Tcy: "\u0422",
  Tfr: "\u{1D517}",
  Therefore: "\u2234",
  Theta: "\u0398",
  ThickSpace: "\u205F\u200A",
  ThinSpace: "\u2009",
  Tilde: "\u223C",
  TildeEqual: "\u2243",
  TildeFullEqual: "\u2245",
  TildeTilde: "\u2248",
  Topf: "\u{1D54B}",
  TripleDot: "\u20DB",
  Tscr: "\u{1D4AF}",
  Tstrok: "\u0166",
  Uacut: "\xDA",
  Uacute: "\xDA",
  Uarr: "\u219F",
  Uarrocir: "\u2949",
  Ubrcy: "\u040E",
  Ubreve: "\u016C",
  Ucir: "\xDB",
  Ucirc: "\xDB",
  Ucy: "\u0423",
  Udblac: "\u0170",
  Ufr: "\u{1D518}",
  Ugrav: "\xD9",
  Ugrave: "\xD9",
  Umacr: "\u016A",
  UnderBar: "_",
  UnderBrace: "\u23DF",
  UnderBracket: "\u23B5",
  UnderParenthesis: "\u23DD",
  Union: "\u22C3",
  UnionPlus: "\u228E",
  Uogon: "\u0172",
  Uopf: "\u{1D54C}",
  UpArrow: "\u2191",
  UpArrowBar: "\u2912",
  UpArrowDownArrow: "\u21C5",
  UpDownArrow: "\u2195",
  UpEquilibrium: "\u296E",
  UpTee: "\u22A5",
  UpTeeArrow: "\u21A5",
  Uparrow: "\u21D1",
  Updownarrow: "\u21D5",
  UpperLeftArrow: "\u2196",
  UpperRightArrow: "\u2197",
  Upsi: "\u03D2",
  Upsilon: "\u03A5",
  Uring: "\u016E",
  Uscr: "\u{1D4B0}",
  Utilde: "\u0168",
  Uum: "\xDC",
  Uuml: "\xDC",
  VDash: "\u22AB",
  Vbar: "\u2AEB",
  Vcy: "\u0412",
  Vdash: "\u22A9",
  Vdashl: "\u2AE6",
  Vee: "\u22C1",
  Verbar: "\u2016",
  Vert: "\u2016",
  VerticalBar: "\u2223",
  VerticalLine: "|",
  VerticalSeparator: "\u2758",
  VerticalTilde: "\u2240",
  VeryThinSpace: "\u200A",
  Vfr: "\u{1D519}",
  Vopf: "\u{1D54D}",
  Vscr: "\u{1D4B1}",
  Vvdash: "\u22AA",
  Wcirc: "\u0174",
  Wedge: "\u22C0",
  Wfr: "\u{1D51A}",
  Wopf: "\u{1D54E}",
  Wscr: "\u{1D4B2}",
  Xfr: "\u{1D51B}",
  Xi: "\u039E",
  Xopf: "\u{1D54F}",
  Xscr: "\u{1D4B3}",
  YAcy: "\u042F",
  YIcy: "\u0407",
  YUcy: "\u042E",
  Yacut: "\xDD",
  Yacute: "\xDD",
  Ycirc: "\u0176",
  Ycy: "\u042B",
  Yfr: "\u{1D51C}",
  Yopf: "\u{1D550}",
  Yscr: "\u{1D4B4}",
  Yuml: "\u0178",
  ZHcy: "\u0416",
  Zacute: "\u0179",
  Zcaron: "\u017D",
  Zcy: "\u0417",
  Zdot: "\u017B",
  ZeroWidthSpace: "\u200B",
  Zeta: "\u0396",
  Zfr: "\u2128",
  Zopf: "\u2124",
  Zscr: "\u{1D4B5}",
  aacut: "\xE1",
  aacute: "\xE1",
  abreve: "\u0103",
  ac: "\u223E",
  acE: "\u223E\u0333",
  acd: "\u223F",
  acir: "\xE2",
  acirc: "\xE2",
  acut: "\xB4",
  acute: "\xB4",
  acy: "\u0430",
  aeli: "\xE6",
  aelig: "\xE6",
  af: "\u2061",
  afr: "\u{1D51E}",
  agrav: "\xE0",
  agrave: "\xE0",
  alefsym: "\u2135",
  aleph: "\u2135",
  alpha: "\u03B1",
  amacr: "\u0101",
  amalg: "\u2A3F",
  am: "&",
  amp: "&",
  and: "\u2227",
  andand: "\u2A55",
  andd: "\u2A5C",
  andslope: "\u2A58",
  andv: "\u2A5A",
  ang: "\u2220",
  ange: "\u29A4",
  angle: "\u2220",
  angmsd: "\u2221",
  angmsdaa: "\u29A8",
  angmsdab: "\u29A9",
  angmsdac: "\u29AA",
  angmsdad: "\u29AB",
  angmsdae: "\u29AC",
  angmsdaf: "\u29AD",
  angmsdag: "\u29AE",
  angmsdah: "\u29AF",
  angrt: "\u221F",
  angrtvb: "\u22BE",
  angrtvbd: "\u299D",
  angsph: "\u2222",
  angst: "\xC5",
  angzarr: "\u237C",
  aogon: "\u0105",
  aopf: "\u{1D552}",
  ap: "\u2248",
  apE: "\u2A70",
  apacir: "\u2A6F",
  ape: "\u224A",
  apid: "\u224B",
  apos: "'",
  approx: "\u2248",
  approxeq: "\u224A",
  arin: "\xE5",
  aring: "\xE5",
  ascr: "\u{1D4B6}",
  ast: "*",
  asymp: "\u2248",
  asympeq: "\u224D",
  atild: "\xE3",
  atilde: "\xE3",
  aum: "\xE4",
  auml: "\xE4",
  awconint: "\u2233",
  awint: "\u2A11",
  bNot: "\u2AED",
  backcong: "\u224C",
  backepsilon: "\u03F6",
  backprime: "\u2035",
  backsim: "\u223D",
  backsimeq: "\u22CD",
  barvee: "\u22BD",
  barwed: "\u2305",
  barwedge: "\u2305",
  bbrk: "\u23B5",
  bbrktbrk: "\u23B6",
  bcong: "\u224C",
  bcy: "\u0431",
  bdquo: "\u201E",
  becaus: "\u2235",
  because: "\u2235",
  bemptyv: "\u29B0",
  bepsi: "\u03F6",
  bernou: "\u212C",
  beta: "\u03B2",
  beth: "\u2136",
  between: "\u226C",
  bfr: "\u{1D51F}",
  bigcap: "\u22C2",
  bigcirc: "\u25EF",
  bigcup: "\u22C3",
  bigodot: "\u2A00",
  bigoplus: "\u2A01",
  bigotimes: "\u2A02",
  bigsqcup: "\u2A06",
  bigstar: "\u2605",
  bigtriangledown: "\u25BD",
  bigtriangleup: "\u25B3",
  biguplus: "\u2A04",
  bigvee: "\u22C1",
  bigwedge: "\u22C0",
  bkarow: "\u290D",
  blacklozenge: "\u29EB",
  blacksquare: "\u25AA",
  blacktriangle: "\u25B4",
  blacktriangledown: "\u25BE",
  blacktriangleleft: "\u25C2",
  blacktriangleright: "\u25B8",
  blank: "\u2423",
  blk12: "\u2592",
  blk14: "\u2591",
  blk34: "\u2593",
  block: "\u2588",
  bne: "=\u20E5",
  bnequiv: "\u2261\u20E5",
  bnot: "\u2310",
  bopf: "\u{1D553}",
  bot: "\u22A5",
  bottom: "\u22A5",
  bowtie: "\u22C8",
  boxDL: "\u2557",
  boxDR: "\u2554",
  boxDl: "\u2556",
  boxDr: "\u2553",
  boxH: "\u2550",
  boxHD: "\u2566",
  boxHU: "\u2569",
  boxHd: "\u2564",
  boxHu: "\u2567",
  boxUL: "\u255D",
  boxUR: "\u255A",
  boxUl: "\u255C",
  boxUr: "\u2559",
  boxV: "\u2551",
  boxVH: "\u256C",
  boxVL: "\u2563",
  boxVR: "\u2560",
  boxVh: "\u256B",
  boxVl: "\u2562",
  boxVr: "\u255F",
  boxbox: "\u29C9",
  boxdL: "\u2555",
  boxdR: "\u2552",
  boxdl: "\u2510",
  boxdr: "\u250C",
  boxh: "\u2500",
  boxhD: "\u2565",
  boxhU: "\u2568",
  boxhd: "\u252C",
  boxhu: "\u2534",
  boxminus: "\u229F",
  boxplus: "\u229E",
  boxtimes: "\u22A0",
  boxuL: "\u255B",
  boxuR: "\u2558",
  boxul: "\u2518",
  boxur: "\u2514",
  boxv: "\u2502",
  boxvH: "\u256A",
  boxvL: "\u2561",
  boxvR: "\u255E",
  boxvh: "\u253C",
  boxvl: "\u2524",
  boxvr: "\u251C",
  bprime: "\u2035",
  breve: "\u02D8",
  brvba: "\xA6",
  brvbar: "\xA6",
  bscr: "\u{1D4B7}",
  bsemi: "\u204F",
  bsim: "\u223D",
  bsime: "\u22CD",
  bsol: "\\",
  bsolb: "\u29C5",
  bsolhsub: "\u27C8",
  bull: "\u2022",
  bullet: "\u2022",
  bump: "\u224E",
  bumpE: "\u2AAE",
  bumpe: "\u224F",
  bumpeq: "\u224F",
  cacute: "\u0107",
  cap: "\u2229",
  capand: "\u2A44",
  capbrcup: "\u2A49",
  capcap: "\u2A4B",
  capcup: "\u2A47",
  capdot: "\u2A40",
  caps: "\u2229\uFE00",
  caret: "\u2041",
  caron: "\u02C7",
  ccaps: "\u2A4D",
  ccaron: "\u010D",
  ccedi: "\xE7",
  ccedil: "\xE7",
  ccirc: "\u0109",
  ccups: "\u2A4C",
  ccupssm: "\u2A50",
  cdot: "\u010B",
  cedi: "\xB8",
  cedil: "\xB8",
  cemptyv: "\u29B2",
  cen: "\xA2",
  cent: "\xA2",
  centerdot: "\xB7",
  cfr: "\u{1D520}",
  chcy: "\u0447",
  check: "\u2713",
  checkmark: "\u2713",
  chi: "\u03C7",
  cir: "\u25CB",
  cirE: "\u29C3",
  circ: "\u02C6",
  circeq: "\u2257",
  circlearrowleft: "\u21BA",
  circlearrowright: "\u21BB",
  circledR: "\xAE",
  circledS: "\u24C8",
  circledast: "\u229B",
  circledcirc: "\u229A",
  circleddash: "\u229D",
  cire: "\u2257",
  cirfnint: "\u2A10",
  cirmid: "\u2AEF",
  cirscir: "\u29C2",
  clubs: "\u2663",
  clubsuit: "\u2663",
  colon: ":",
  colone: "\u2254",
  coloneq: "\u2254",
  comma: ",",
  commat: "@",
  comp: "\u2201",
  compfn: "\u2218",
  complement: "\u2201",
  complexes: "\u2102",
  cong: "\u2245",
  congdot: "\u2A6D",
  conint: "\u222E",
  copf: "\u{1D554}",
  coprod: "\u2210",
  cop: "\xA9",
  copy: "\xA9",
  copysr: "\u2117",
  crarr: "\u21B5",
  cross: "\u2717",
  cscr: "\u{1D4B8}",
  csub: "\u2ACF",
  csube: "\u2AD1",
  csup: "\u2AD0",
  csupe: "\u2AD2",
  ctdot: "\u22EF",
  cudarrl: "\u2938",
  cudarrr: "\u2935",
  cuepr: "\u22DE",
  cuesc: "\u22DF",
  cularr: "\u21B6",
  cularrp: "\u293D",
  cup: "\u222A",
  cupbrcap: "\u2A48",
  cupcap: "\u2A46",
  cupcup: "\u2A4A",
  cupdot: "\u228D",
  cupor: "\u2A45",
  cups: "\u222A\uFE00",
  curarr: "\u21B7",
  curarrm: "\u293C",
  curlyeqprec: "\u22DE",
  curlyeqsucc: "\u22DF",
  curlyvee: "\u22CE",
  curlywedge: "\u22CF",
  curre: "\xA4",
  curren: "\xA4",
  curvearrowleft: "\u21B6",
  curvearrowright: "\u21B7",
  cuvee: "\u22CE",
  cuwed: "\u22CF",
  cwconint: "\u2232",
  cwint: "\u2231",
  cylcty: "\u232D",
  dArr: "\u21D3",
  dHar: "\u2965",
  dagger: "\u2020",
  daleth: "\u2138",
  darr: "\u2193",
  dash: "\u2010",
  dashv: "\u22A3",
  dbkarow: "\u290F",
  dblac: "\u02DD",
  dcaron: "\u010F",
  dcy: "\u0434",
  dd: "\u2146",
  ddagger: "\u2021",
  ddarr: "\u21CA",
  ddotseq: "\u2A77",
  de: "\xB0",
  deg: "\xB0",
  delta: "\u03B4",
  demptyv: "\u29B1",
  dfisht: "\u297F",
  dfr: "\u{1D521}",
  dharl: "\u21C3",
  dharr: "\u21C2",
  diam: "\u22C4",
  diamond: "\u22C4",
  diamondsuit: "\u2666",
  diams: "\u2666",
  die: "\xA8",
  digamma: "\u03DD",
  disin: "\u22F2",
  div: "\xF7",
  divid: "\xF7",
  divide: "\xF7",
  divideontimes: "\u22C7",
  divonx: "\u22C7",
  djcy: "\u0452",
  dlcorn: "\u231E",
  dlcrop: "\u230D",
  dollar: "$",
  dopf: "\u{1D555}",
  dot: "\u02D9",
  doteq: "\u2250",
  doteqdot: "\u2251",
  dotminus: "\u2238",
  dotplus: "\u2214",
  dotsquare: "\u22A1",
  doublebarwedge: "\u2306",
  downarrow: "\u2193",
  downdownarrows: "\u21CA",
  downharpoonleft: "\u21C3",
  downharpoonright: "\u21C2",
  drbkarow: "\u2910",
  drcorn: "\u231F",
  drcrop: "\u230C",
  dscr: "\u{1D4B9}",
  dscy: "\u0455",
  dsol: "\u29F6",
  dstrok: "\u0111",
  dtdot: "\u22F1",
  dtri: "\u25BF",
  dtrif: "\u25BE",
  duarr: "\u21F5",
  duhar: "\u296F",
  dwangle: "\u29A6",
  dzcy: "\u045F",
  dzigrarr: "\u27FF",
  eDDot: "\u2A77",
  eDot: "\u2251",
  eacut: "\xE9",
  eacute: "\xE9",
  easter: "\u2A6E",
  ecaron: "\u011B",
  ecir: "\xEA",
  ecirc: "\xEA",
  ecolon: "\u2255",
  ecy: "\u044D",
  edot: "\u0117",
  ee: "\u2147",
  efDot: "\u2252",
  efr: "\u{1D522}",
  eg: "\u2A9A",
  egrav: "\xE8",
  egrave: "\xE8",
  egs: "\u2A96",
  egsdot: "\u2A98",
  el: "\u2A99",
  elinters: "\u23E7",
  ell: "\u2113",
  els: "\u2A95",
  elsdot: "\u2A97",
  emacr: "\u0113",
  empty: "\u2205",
  emptyset: "\u2205",
  emptyv: "\u2205",
  emsp13: "\u2004",
  emsp14: "\u2005",
  emsp: "\u2003",
  eng: "\u014B",
  ensp: "\u2002",
  eogon: "\u0119",
  eopf: "\u{1D556}",
  epar: "\u22D5",
  eparsl: "\u29E3",
  eplus: "\u2A71",
  epsi: "\u03B5",
  epsilon: "\u03B5",
  epsiv: "\u03F5",
  eqcirc: "\u2256",
  eqcolon: "\u2255",
  eqsim: "\u2242",
  eqslantgtr: "\u2A96",
  eqslantless: "\u2A95",
  equals: "=",
  equest: "\u225F",
  equiv: "\u2261",
  equivDD: "\u2A78",
  eqvparsl: "\u29E5",
  erDot: "\u2253",
  erarr: "\u2971",
  escr: "\u212F",
  esdot: "\u2250",
  esim: "\u2242",
  eta: "\u03B7",
  et: "\xF0",
  eth: "\xF0",
  eum: "\xEB",
  euml: "\xEB",
  euro: "\u20AC",
  excl: "!",
  exist: "\u2203",
  expectation: "\u2130",
  exponentiale: "\u2147",
  fallingdotseq: "\u2252",
  fcy: "\u0444",
  female: "\u2640",
  ffilig: "\uFB03",
  fflig: "\uFB00",
  ffllig: "\uFB04",
  ffr: "\u{1D523}",
  filig: "\uFB01",
  fjlig: "fj",
  flat: "\u266D",
  fllig: "\uFB02",
  fltns: "\u25B1",
  fnof: "\u0192",
  fopf: "\u{1D557}",
  forall: "\u2200",
  fork: "\u22D4",
  forkv: "\u2AD9",
  fpartint: "\u2A0D",
  frac1: "\xBC",
  frac12: "\xBD",
  frac13: "\u2153",
  frac14: "\xBC",
  frac15: "\u2155",
  frac16: "\u2159",
  frac18: "\u215B",
  frac23: "\u2154",
  frac25: "\u2156",
  frac3: "\xBE",
  frac34: "\xBE",
  frac35: "\u2157",
  frac38: "\u215C",
  frac45: "\u2158",
  frac56: "\u215A",
  frac58: "\u215D",
  frac78: "\u215E",
  frasl: "\u2044",
  frown: "\u2322",
  fscr: "\u{1D4BB}",
  gE: "\u2267",
  gEl: "\u2A8C",
  gacute: "\u01F5",
  gamma: "\u03B3",
  gammad: "\u03DD",
  gap: "\u2A86",
  gbreve: "\u011F",
  gcirc: "\u011D",
  gcy: "\u0433",
  gdot: "\u0121",
  ge: "\u2265",
  gel: "\u22DB",
  geq: "\u2265",
  geqq: "\u2267",
  geqslant: "\u2A7E",
  ges: "\u2A7E",
  gescc: "\u2AA9",
  gesdot: "\u2A80",
  gesdoto: "\u2A82",
  gesdotol: "\u2A84",
  gesl: "\u22DB\uFE00",
  gesles: "\u2A94",
  gfr: "\u{1D524}",
  gg: "\u226B",
  ggg: "\u22D9",
  gimel: "\u2137",
  gjcy: "\u0453",
  gl: "\u2277",
  glE: "\u2A92",
  gla: "\u2AA5",
  glj: "\u2AA4",
  gnE: "\u2269",
  gnap: "\u2A8A",
  gnapprox: "\u2A8A",
  gne: "\u2A88",
  gneq: "\u2A88",
  gneqq: "\u2269",
  gnsim: "\u22E7",
  gopf: "\u{1D558}",
  grave: "`",
  gscr: "\u210A",
  gsim: "\u2273",
  gsime: "\u2A8E",
  gsiml: "\u2A90",
  g: ">",
  gt: ">",
  gtcc: "\u2AA7",
  gtcir: "\u2A7A",
  gtdot: "\u22D7",
  gtlPar: "\u2995",
  gtquest: "\u2A7C",
  gtrapprox: "\u2A86",
  gtrarr: "\u2978",
  gtrdot: "\u22D7",
  gtreqless: "\u22DB",
  gtreqqless: "\u2A8C",
  gtrless: "\u2277",
  gtrsim: "\u2273",
  gvertneqq: "\u2269\uFE00",
  gvnE: "\u2269\uFE00",
  hArr: "\u21D4",
  hairsp: "\u200A",
  half: "\xBD",
  hamilt: "\u210B",
  hardcy: "\u044A",
  harr: "\u2194",
  harrcir: "\u2948",
  harrw: "\u21AD",
  hbar: "\u210F",
  hcirc: "\u0125",
  hearts: "\u2665",
  heartsuit: "\u2665",
  hellip: "\u2026",
  hercon: "\u22B9",
  hfr: "\u{1D525}",
  hksearow: "\u2925",
  hkswarow: "\u2926",
  hoarr: "\u21FF",
  homtht: "\u223B",
  hookleftarrow: "\u21A9",
  hookrightarrow: "\u21AA",
  hopf: "\u{1D559}",
  horbar: "\u2015",
  hscr: "\u{1D4BD}",
  hslash: "\u210F",
  hstrok: "\u0127",
  hybull: "\u2043",
  hyphen: "\u2010",
  iacut: "\xED",
  iacute: "\xED",
  ic: "\u2063",
  icir: "\xEE",
  icirc: "\xEE",
  icy: "\u0438",
  iecy: "\u0435",
  iexc: "\xA1",
  iexcl: "\xA1",
  iff: "\u21D4",
  ifr: "\u{1D526}",
  igrav: "\xEC",
  igrave: "\xEC",
  ii: "\u2148",
  iiiint: "\u2A0C",
  iiint: "\u222D",
  iinfin: "\u29DC",
  iiota: "\u2129",
  ijlig: "\u0133",
  imacr: "\u012B",
  image: "\u2111",
  imagline: "\u2110",
  imagpart: "\u2111",
  imath: "\u0131",
  imof: "\u22B7",
  imped: "\u01B5",
  in: "\u2208",
  incare: "\u2105",
  infin: "\u221E",
  infintie: "\u29DD",
  inodot: "\u0131",
  int: "\u222B",
  intcal: "\u22BA",
  integers: "\u2124",
  intercal: "\u22BA",
  intlarhk: "\u2A17",
  intprod: "\u2A3C",
  iocy: "\u0451",
  iogon: "\u012F",
  iopf: "\u{1D55A}",
  iota: "\u03B9",
  iprod: "\u2A3C",
  iques: "\xBF",
  iquest: "\xBF",
  iscr: "\u{1D4BE}",
  isin: "\u2208",
  isinE: "\u22F9",
  isindot: "\u22F5",
  isins: "\u22F4",
  isinsv: "\u22F3",
  isinv: "\u2208",
  it: "\u2062",
  itilde: "\u0129",
  iukcy: "\u0456",
  ium: "\xEF",
  iuml: "\xEF",
  jcirc: "\u0135",
  jcy: "\u0439",
  jfr: "\u{1D527}",
  jmath: "\u0237",
  jopf: "\u{1D55B}",
  jscr: "\u{1D4BF}",
  jsercy: "\u0458",
  jukcy: "\u0454",
  kappa: "\u03BA",
  kappav: "\u03F0",
  kcedil: "\u0137",
  kcy: "\u043A",
  kfr: "\u{1D528}",
  kgreen: "\u0138",
  khcy: "\u0445",
  kjcy: "\u045C",
  kopf: "\u{1D55C}",
  kscr: "\u{1D4C0}",
  lAarr: "\u21DA",
  lArr: "\u21D0",
  lAtail: "\u291B",
  lBarr: "\u290E",
  lE: "\u2266",
  lEg: "\u2A8B",
  lHar: "\u2962",
  lacute: "\u013A",
  laemptyv: "\u29B4",
  lagran: "\u2112",
  lambda: "\u03BB",
  lang: "\u27E8",
  langd: "\u2991",
  langle: "\u27E8",
  lap: "\u2A85",
  laqu: "\xAB",
  laquo: "\xAB",
  larr: "\u2190",
  larrb: "\u21E4",
  larrbfs: "\u291F",
  larrfs: "\u291D",
  larrhk: "\u21A9",
  larrlp: "\u21AB",
  larrpl: "\u2939",
  larrsim: "\u2973",
  larrtl: "\u21A2",
  lat: "\u2AAB",
  latail: "\u2919",
  late: "\u2AAD",
  lates: "\u2AAD\uFE00",
  lbarr: "\u290C",
  lbbrk: "\u2772",
  lbrace: "{",
  lbrack: "[",
  lbrke: "\u298B",
  lbrksld: "\u298F",
  lbrkslu: "\u298D",
  lcaron: "\u013E",
  lcedil: "\u013C",
  lceil: "\u2308",
  lcub: "{",
  lcy: "\u043B",
  ldca: "\u2936",
  ldquo: "\u201C",
  ldquor: "\u201E",
  ldrdhar: "\u2967",
  ldrushar: "\u294B",
  ldsh: "\u21B2",
  le: "\u2264",
  leftarrow: "\u2190",
  leftarrowtail: "\u21A2",
  leftharpoondown: "\u21BD",
  leftharpoonup: "\u21BC",
  leftleftarrows: "\u21C7",
  leftrightarrow: "\u2194",
  leftrightarrows: "\u21C6",
  leftrightharpoons: "\u21CB",
  leftrightsquigarrow: "\u21AD",
  leftthreetimes: "\u22CB",
  leg: "\u22DA",
  leq: "\u2264",
  leqq: "\u2266",
  leqslant: "\u2A7D",
  les: "\u2A7D",
  lescc: "\u2AA8",
  lesdot: "\u2A7F",
  lesdoto: "\u2A81",
  lesdotor: "\u2A83",
  lesg: "\u22DA\uFE00",
  lesges: "\u2A93",
  lessapprox: "\u2A85",
  lessdot: "\u22D6",
  lesseqgtr: "\u22DA",
  lesseqqgtr: "\u2A8B",
  lessgtr: "\u2276",
  lesssim: "\u2272",
  lfisht: "\u297C",
  lfloor: "\u230A",
  lfr: "\u{1D529}",
  lg: "\u2276",
  lgE: "\u2A91",
  lhard: "\u21BD",
  lharu: "\u21BC",
  lharul: "\u296A",
  lhblk: "\u2584",
  ljcy: "\u0459",
  ll: "\u226A",
  llarr: "\u21C7",
  llcorner: "\u231E",
  llhard: "\u296B",
  lltri: "\u25FA",
  lmidot: "\u0140",
  lmoust: "\u23B0",
  lmoustache: "\u23B0",
  lnE: "\u2268",
  lnap: "\u2A89",
  lnapprox: "\u2A89",
  lne: "\u2A87",
  lneq: "\u2A87",
  lneqq: "\u2268",
  lnsim: "\u22E6",
  loang: "\u27EC",
  loarr: "\u21FD",
  lobrk: "\u27E6",
  longleftarrow: "\u27F5",
  longleftrightarrow: "\u27F7",
  longmapsto: "\u27FC",
  longrightarrow: "\u27F6",
  looparrowleft: "\u21AB",
  looparrowright: "\u21AC",
  lopar: "\u2985",
  lopf: "\u{1D55D}",
  loplus: "\u2A2D",
  lotimes: "\u2A34",
  lowast: "\u2217",
  lowbar: "_",
  loz: "\u25CA",
  lozenge: "\u25CA",
  lozf: "\u29EB",
  lpar: "(",
  lparlt: "\u2993",
  lrarr: "\u21C6",
  lrcorner: "\u231F",
  lrhar: "\u21CB",
  lrhard: "\u296D",
  lrm: "\u200E",
  lrtri: "\u22BF",
  lsaquo: "\u2039",
  lscr: "\u{1D4C1}",
  lsh: "\u21B0",
  lsim: "\u2272",
  lsime: "\u2A8D",
  lsimg: "\u2A8F",
  lsqb: "[",
  lsquo: "\u2018",
  lsquor: "\u201A",
  lstrok: "\u0142",
  l: "<",
  lt: "<",
  ltcc: "\u2AA6",
  ltcir: "\u2A79",
  ltdot: "\u22D6",
  lthree: "\u22CB",
  ltimes: "\u22C9",
  ltlarr: "\u2976",
  ltquest: "\u2A7B",
  ltrPar: "\u2996",
  ltri: "\u25C3",
  ltrie: "\u22B4",
  ltrif: "\u25C2",
  lurdshar: "\u294A",
  luruhar: "\u2966",
  lvertneqq: "\u2268\uFE00",
  lvnE: "\u2268\uFE00",
  mDDot: "\u223A",
  mac: "\xAF",
  macr: "\xAF",
  male: "\u2642",
  malt: "\u2720",
  maltese: "\u2720",
  map: "\u21A6",
  mapsto: "\u21A6",
  mapstodown: "\u21A7",
  mapstoleft: "\u21A4",
  mapstoup: "\u21A5",
  marker: "\u25AE",
  mcomma: "\u2A29",
  mcy: "\u043C",
  mdash: "\u2014",
  measuredangle: "\u2221",
  mfr: "\u{1D52A}",
  mho: "\u2127",
  micr: "\xB5",
  micro: "\xB5",
  mid: "\u2223",
  midast: "*",
  midcir: "\u2AF0",
  middo: "\xB7",
  middot: "\xB7",
  minus: "\u2212",
  minusb: "\u229F",
  minusd: "\u2238",
  minusdu: "\u2A2A",
  mlcp: "\u2ADB",
  mldr: "\u2026",
  mnplus: "\u2213",
  models: "\u22A7",
  mopf: "\u{1D55E}",
  mp: "\u2213",
  mscr: "\u{1D4C2}",
  mstpos: "\u223E",
  mu: "\u03BC",
  multimap: "\u22B8",
  mumap: "\u22B8",
  nGg: "\u22D9\u0338",
  nGt: "\u226B\u20D2",
  nGtv: "\u226B\u0338",
  nLeftarrow: "\u21CD",
  nLeftrightarrow: "\u21CE",
  nLl: "\u22D8\u0338",
  nLt: "\u226A\u20D2",
  nLtv: "\u226A\u0338",
  nRightarrow: "\u21CF",
  nVDash: "\u22AF",
  nVdash: "\u22AE",
  nabla: "\u2207",
  nacute: "\u0144",
  nang: "\u2220\u20D2",
  nap: "\u2249",
  napE: "\u2A70\u0338",
  napid: "\u224B\u0338",
  napos: "\u0149",
  napprox: "\u2249",
  natur: "\u266E",
  natural: "\u266E",
  naturals: "\u2115",
  nbs: "\xA0",
  nbsp: "\xA0",
  nbump: "\u224E\u0338",
  nbumpe: "\u224F\u0338",
  ncap: "\u2A43",
  ncaron: "\u0148",
  ncedil: "\u0146",
  ncong: "\u2247",
  ncongdot: "\u2A6D\u0338",
  ncup: "\u2A42",
  ncy: "\u043D",
  ndash: "\u2013",
  ne: "\u2260",
  neArr: "\u21D7",
  nearhk: "\u2924",
  nearr: "\u2197",
  nearrow: "\u2197",
  nedot: "\u2250\u0338",
  nequiv: "\u2262",
  nesear: "\u2928",
  nesim: "\u2242\u0338",
  nexist: "\u2204",
  nexists: "\u2204",
  nfr: "\u{1D52B}",
  ngE: "\u2267\u0338",
  nge: "\u2271",
  ngeq: "\u2271",
  ngeqq: "\u2267\u0338",
  ngeqslant: "\u2A7E\u0338",
  nges: "\u2A7E\u0338",
  ngsim: "\u2275",
  ngt: "\u226F",
  ngtr: "\u226F",
  nhArr: "\u21CE",
  nharr: "\u21AE",
  nhpar: "\u2AF2",
  ni: "\u220B",
  nis: "\u22FC",
  nisd: "\u22FA",
  niv: "\u220B",
  njcy: "\u045A",
  nlArr: "\u21CD",
  nlE: "\u2266\u0338",
  nlarr: "\u219A",
  nldr: "\u2025",
  nle: "\u2270",
  nleftarrow: "\u219A",
  nleftrightarrow: "\u21AE",
  nleq: "\u2270",
  nleqq: "\u2266\u0338",
  nleqslant: "\u2A7D\u0338",
  nles: "\u2A7D\u0338",
  nless: "\u226E",
  nlsim: "\u2274",
  nlt: "\u226E",
  nltri: "\u22EA",
  nltrie: "\u22EC",
  nmid: "\u2224",
  nopf: "\u{1D55F}",
  no: "\xAC",
  not: "\xAC",
  notin: "\u2209",
  notinE: "\u22F9\u0338",
  notindot: "\u22F5\u0338",
  notinva: "\u2209",
  notinvb: "\u22F7",
  notinvc: "\u22F6",
  notni: "\u220C",
  notniva: "\u220C",
  notnivb: "\u22FE",
  notnivc: "\u22FD",
  npar: "\u2226",
  nparallel: "\u2226",
  nparsl: "\u2AFD\u20E5",
  npart: "\u2202\u0338",
  npolint: "\u2A14",
  npr: "\u2280",
  nprcue: "\u22E0",
  npre: "\u2AAF\u0338",
  nprec: "\u2280",
  npreceq: "\u2AAF\u0338",
  nrArr: "\u21CF",
  nrarr: "\u219B",
  nrarrc: "\u2933\u0338",
  nrarrw: "\u219D\u0338",
  nrightarrow: "\u219B",
  nrtri: "\u22EB",
  nrtrie: "\u22ED",
  nsc: "\u2281",
  nsccue: "\u22E1",
  nsce: "\u2AB0\u0338",
  nscr: "\u{1D4C3}",
  nshortmid: "\u2224",
  nshortparallel: "\u2226",
  nsim: "\u2241",
  nsime: "\u2244",
  nsimeq: "\u2244",
  nsmid: "\u2224",
  nspar: "\u2226",
  nsqsube: "\u22E2",
  nsqsupe: "\u22E3",
  nsub: "\u2284",
  nsubE: "\u2AC5\u0338",
  nsube: "\u2288",
  nsubset: "\u2282\u20D2",
  nsubseteq: "\u2288",
  nsubseteqq: "\u2AC5\u0338",
  nsucc: "\u2281",
  nsucceq: "\u2AB0\u0338",
  nsup: "\u2285",
  nsupE: "\u2AC6\u0338",
  nsupe: "\u2289",
  nsupset: "\u2283\u20D2",
  nsupseteq: "\u2289",
  nsupseteqq: "\u2AC6\u0338",
  ntgl: "\u2279",
  ntild: "\xF1",
  ntilde: "\xF1",
  ntlg: "\u2278",
  ntriangleleft: "\u22EA",
  ntrianglelefteq: "\u22EC",
  ntriangleright: "\u22EB",
  ntrianglerighteq: "\u22ED",
  nu: "\u03BD",
  num: "#",
  numero: "\u2116",
  numsp: "\u2007",
  nvDash: "\u22AD",
  nvHarr: "\u2904",
  nvap: "\u224D\u20D2",
  nvdash: "\u22AC",
  nvge: "\u2265\u20D2",
  nvgt: ">\u20D2",
  nvinfin: "\u29DE",
  nvlArr: "\u2902",
  nvle: "\u2264\u20D2",
  nvlt: "<\u20D2",
  nvltrie: "\u22B4\u20D2",
  nvrArr: "\u2903",
  nvrtrie: "\u22B5\u20D2",
  nvsim: "\u223C\u20D2",
  nwArr: "\u21D6",
  nwarhk: "\u2923",
  nwarr: "\u2196",
  nwarrow: "\u2196",
  nwnear: "\u2927",
  oS: "\u24C8",
  oacut: "\xF3",
  oacute: "\xF3",
  oast: "\u229B",
  ocir: "\xF4",
  ocirc: "\xF4",
  ocy: "\u043E",
  odash: "\u229D",
  odblac: "\u0151",
  odiv: "\u2A38",
  odot: "\u2299",
  odsold: "\u29BC",
  oelig: "\u0153",
  ofcir: "\u29BF",
  ofr: "\u{1D52C}",
  ogon: "\u02DB",
  ograv: "\xF2",
  ograve: "\xF2",
  ogt: "\u29C1",
  ohbar: "\u29B5",
  ohm: "\u03A9",
  oint: "\u222E",
  olarr: "\u21BA",
  olcir: "\u29BE",
  olcross: "\u29BB",
  oline: "\u203E",
  olt: "\u29C0",
  omacr: "\u014D",
  omega: "\u03C9",
  omicron: "\u03BF",
  omid: "\u29B6",
  ominus: "\u2296",
  oopf: "\u{1D560}",
  opar: "\u29B7",
  operp: "\u29B9",
  oplus: "\u2295",
  or: "\u2228",
  orarr: "\u21BB",
  ord: "\xBA",
  order: "\u2134",
  orderof: "\u2134",
  ordf: "\xAA",
  ordm: "\xBA",
  origof: "\u22B6",
  oror: "\u2A56",
  orslope: "\u2A57",
  orv: "\u2A5B",
  oscr: "\u2134",
  oslas: "\xF8",
  oslash: "\xF8",
  osol: "\u2298",
  otild: "\xF5",
  otilde: "\xF5",
  otimes: "\u2297",
  otimesas: "\u2A36",
  oum: "\xF6",
  ouml: "\xF6",
  ovbar: "\u233D",
  par: "\xB6",
  para: "\xB6",
  parallel: "\u2225",
  parsim: "\u2AF3",
  parsl: "\u2AFD",
  part: "\u2202",
  pcy: "\u043F",
  percnt: "%",
  period: ".",
  permil: "\u2030",
  perp: "\u22A5",
  pertenk: "\u2031",
  pfr: "\u{1D52D}",
  phi: "\u03C6",
  phiv: "\u03D5",
  phmmat: "\u2133",
  phone: "\u260E",
  pi: "\u03C0",
  pitchfork: "\u22D4",
  piv: "\u03D6",
  planck: "\u210F",
  planckh: "\u210E",
  plankv: "\u210F",
  plus: "+",
  plusacir: "\u2A23",
  plusb: "\u229E",
  pluscir: "\u2A22",
  plusdo: "\u2214",
  plusdu: "\u2A25",
  pluse: "\u2A72",
  plusm: "\xB1",
  plusmn: "\xB1",
  plussim: "\u2A26",
  plustwo: "\u2A27",
  pm: "\xB1",
  pointint: "\u2A15",
  popf: "\u{1D561}",
  poun: "\xA3",
  pound: "\xA3",
  pr: "\u227A",
  prE: "\u2AB3",
  prap: "\u2AB7",
  prcue: "\u227C",
  pre: "\u2AAF",
  prec: "\u227A",
  precapprox: "\u2AB7",
  preccurlyeq: "\u227C",
  preceq: "\u2AAF",
  precnapprox: "\u2AB9",
  precneqq: "\u2AB5",
  precnsim: "\u22E8",
  precsim: "\u227E",
  prime: "\u2032",
  primes: "\u2119",
  prnE: "\u2AB5",
  prnap: "\u2AB9",
  prnsim: "\u22E8",
  prod: "\u220F",
  profalar: "\u232E",
  profline: "\u2312",
  profsurf: "\u2313",
  prop: "\u221D",
  propto: "\u221D",
  prsim: "\u227E",
  prurel: "\u22B0",
  pscr: "\u{1D4C5}",
  psi: "\u03C8",
  puncsp: "\u2008",
  qfr: "\u{1D52E}",
  qint: "\u2A0C",
  qopf: "\u{1D562}",
  qprime: "\u2057",
  qscr: "\u{1D4C6}",
  quaternions: "\u210D",
  quatint: "\u2A16",
  quest: "?",
  questeq: "\u225F",
  quo: '"',
  quot: '"',
  rAarr: "\u21DB",
  rArr: "\u21D2",
  rAtail: "\u291C",
  rBarr: "\u290F",
  rHar: "\u2964",
  race: "\u223D\u0331",
  racute: "\u0155",
  radic: "\u221A",
  raemptyv: "\u29B3",
  rang: "\u27E9",
  rangd: "\u2992",
  range: "\u29A5",
  rangle: "\u27E9",
  raqu: "\xBB",
  raquo: "\xBB",
  rarr: "\u2192",
  rarrap: "\u2975",
  rarrb: "\u21E5",
  rarrbfs: "\u2920",
  rarrc: "\u2933",
  rarrfs: "\u291E",
  rarrhk: "\u21AA",
  rarrlp: "\u21AC",
  rarrpl: "\u2945",
  rarrsim: "\u2974",
  rarrtl: "\u21A3",
  rarrw: "\u219D",
  ratail: "\u291A",
  ratio: "\u2236",
  rationals: "\u211A",
  rbarr: "\u290D",
  rbbrk: "\u2773",
  rbrace: "}",
  rbrack: "]",
  rbrke: "\u298C",
  rbrksld: "\u298E",
  rbrkslu: "\u2990",
  rcaron: "\u0159",
  rcedil: "\u0157",
  rceil: "\u2309",
  rcub: "}",
  rcy: "\u0440",
  rdca: "\u2937",
  rdldhar: "\u2969",
  rdquo: "\u201D",
  rdquor: "\u201D",
  rdsh: "\u21B3",
  real: "\u211C",
  realine: "\u211B",
  realpart: "\u211C",
  reals: "\u211D",
  rect: "\u25AD",
  re: "\xAE",
  reg: "\xAE",
  rfisht: "\u297D",
  rfloor: "\u230B",
  rfr: "\u{1D52F}",
  rhard: "\u21C1",
  rharu: "\u21C0",
  rharul: "\u296C",
  rho: "\u03C1",
  rhov: "\u03F1",
  rightarrow: "\u2192",
  rightarrowtail: "\u21A3",
  rightharpoondown: "\u21C1",
  rightharpoonup: "\u21C0",
  rightleftarrows: "\u21C4",
  rightleftharpoons: "\u21CC",
  rightrightarrows: "\u21C9",
  rightsquigarrow: "\u219D",
  rightthreetimes: "\u22CC",
  ring: "\u02DA",
  risingdotseq: "\u2253",
  rlarr: "\u21C4",
  rlhar: "\u21CC",
  rlm: "\u200F",
  rmoust: "\u23B1",
  rmoustache: "\u23B1",
  rnmid: "\u2AEE",
  roang: "\u27ED",
  roarr: "\u21FE",
  robrk: "\u27E7",
  ropar: "\u2986",
  ropf: "\u{1D563}",
  roplus: "\u2A2E",
  rotimes: "\u2A35",
  rpar: ")",
  rpargt: "\u2994",
  rppolint: "\u2A12",
  rrarr: "\u21C9",
  rsaquo: "\u203A",
  rscr: "\u{1D4C7}",
  rsh: "\u21B1",
  rsqb: "]",
  rsquo: "\u2019",
  rsquor: "\u2019",
  rthree: "\u22CC",
  rtimes: "\u22CA",
  rtri: "\u25B9",
  rtrie: "\u22B5",
  rtrif: "\u25B8",
  rtriltri: "\u29CE",
  ruluhar: "\u2968",
  rx: "\u211E",
  sacute: "\u015B",
  sbquo: "\u201A",
  sc: "\u227B",
  scE: "\u2AB4",
  scap: "\u2AB8",
  scaron: "\u0161",
  sccue: "\u227D",
  sce: "\u2AB0",
  scedil: "\u015F",
  scirc: "\u015D",
  scnE: "\u2AB6",
  scnap: "\u2ABA",
  scnsim: "\u22E9",
  scpolint: "\u2A13",
  scsim: "\u227F",
  scy: "\u0441",
  sdot: "\u22C5",
  sdotb: "\u22A1",
  sdote: "\u2A66",
  seArr: "\u21D8",
  searhk: "\u2925",
  searr: "\u2198",
  searrow: "\u2198",
  sec: "\xA7",
  sect: "\xA7",
  semi: ";",
  seswar: "\u2929",
  setminus: "\u2216",
  setmn: "\u2216",
  sext: "\u2736",
  sfr: "\u{1D530}",
  sfrown: "\u2322",
  sharp: "\u266F",
  shchcy: "\u0449",
  shcy: "\u0448",
  shortmid: "\u2223",
  shortparallel: "\u2225",
  sh: "\xAD",
  shy: "\xAD",
  sigma: "\u03C3",
  sigmaf: "\u03C2",
  sigmav: "\u03C2",
  sim: "\u223C",
  simdot: "\u2A6A",
  sime: "\u2243",
  simeq: "\u2243",
  simg: "\u2A9E",
  simgE: "\u2AA0",
  siml: "\u2A9D",
  simlE: "\u2A9F",
  simne: "\u2246",
  simplus: "\u2A24",
  simrarr: "\u2972",
  slarr: "\u2190",
  smallsetminus: "\u2216",
  smashp: "\u2A33",
  smeparsl: "\u29E4",
  smid: "\u2223",
  smile: "\u2323",
  smt: "\u2AAA",
  smte: "\u2AAC",
  smtes: "\u2AAC\uFE00",
  softcy: "\u044C",
  sol: "/",
  solb: "\u29C4",
  solbar: "\u233F",
  sopf: "\u{1D564}",
  spades: "\u2660",
  spadesuit: "\u2660",
  spar: "\u2225",
  sqcap: "\u2293",
  sqcaps: "\u2293\uFE00",
  sqcup: "\u2294",
  sqcups: "\u2294\uFE00",
  sqsub: "\u228F",
  sqsube: "\u2291",
  sqsubset: "\u228F",
  sqsubseteq: "\u2291",
  sqsup: "\u2290",
  sqsupe: "\u2292",
  sqsupset: "\u2290",
  sqsupseteq: "\u2292",
  squ: "\u25A1",
  square: "\u25A1",
  squarf: "\u25AA",
  squf: "\u25AA",
  srarr: "\u2192",
  sscr: "\u{1D4C8}",
  ssetmn: "\u2216",
  ssmile: "\u2323",
  sstarf: "\u22C6",
  star: "\u2606",
  starf: "\u2605",
  straightepsilon: "\u03F5",
  straightphi: "\u03D5",
  strns: "\xAF",
  sub: "\u2282",
  subE: "\u2AC5",
  subdot: "\u2ABD",
  sube: "\u2286",
  subedot: "\u2AC3",
  submult: "\u2AC1",
  subnE: "\u2ACB",
  subne: "\u228A",
  subplus: "\u2ABF",
  subrarr: "\u2979",
  subset: "\u2282",
  subseteq: "\u2286",
  subseteqq: "\u2AC5",
  subsetneq: "\u228A",
  subsetneqq: "\u2ACB",
  subsim: "\u2AC7",
  subsub: "\u2AD5",
  subsup: "\u2AD3",
  succ: "\u227B",
  succapprox: "\u2AB8",
  succcurlyeq: "\u227D",
  succeq: "\u2AB0",
  succnapprox: "\u2ABA",
  succneqq: "\u2AB6",
  succnsim: "\u22E9",
  succsim: "\u227F",
  sum: "\u2211",
  sung: "\u266A",
  sup: "\u2283",
  sup1: "\xB9",
  sup2: "\xB2",
  sup3: "\xB3",
  supE: "\u2AC6",
  supdot: "\u2ABE",
  supdsub: "\u2AD8",
  supe: "\u2287",
  supedot: "\u2AC4",
  suphsol: "\u27C9",
  suphsub: "\u2AD7",
  suplarr: "\u297B",
  supmult: "\u2AC2",
  supnE: "\u2ACC",
  supne: "\u228B",
  supplus: "\u2AC0",
  supset: "\u2283",
  supseteq: "\u2287",
  supseteqq: "\u2AC6",
  supsetneq: "\u228B",
  supsetneqq: "\u2ACC",
  supsim: "\u2AC8",
  supsub: "\u2AD4",
  supsup: "\u2AD6",
  swArr: "\u21D9",
  swarhk: "\u2926",
  swarr: "\u2199",
  swarrow: "\u2199",
  swnwar: "\u292A",
  szli: "\xDF",
  szlig: "\xDF",
  target: "\u2316",
  tau: "\u03C4",
  tbrk: "\u23B4",
  tcaron: "\u0165",
  tcedil: "\u0163",
  tcy: "\u0442",
  tdot: "\u20DB",
  telrec: "\u2315",
  tfr: "\u{1D531}",
  there4: "\u2234",
  therefore: "\u2234",
  theta: "\u03B8",
  thetasym: "\u03D1",
  thetav: "\u03D1",
  thickapprox: "\u2248",
  thicksim: "\u223C",
  thinsp: "\u2009",
  thkap: "\u2248",
  thksim: "\u223C",
  thor: "\xFE",
  thorn: "\xFE",
  tilde: "\u02DC",
  time: "\xD7",
  times: "\xD7",
  timesb: "\u22A0",
  timesbar: "\u2A31",
  timesd: "\u2A30",
  tint: "\u222D",
  toea: "\u2928",
  top: "\u22A4",
  topbot: "\u2336",
  topcir: "\u2AF1",
  topf: "\u{1D565}",
  topfork: "\u2ADA",
  tosa: "\u2929",
  tprime: "\u2034",
  trade: "\u2122",
  triangle: "\u25B5",
  triangledown: "\u25BF",
  triangleleft: "\u25C3",
  trianglelefteq: "\u22B4",
  triangleq: "\u225C",
  triangleright: "\u25B9",
  trianglerighteq: "\u22B5",
  tridot: "\u25EC",
  trie: "\u225C",
  triminus: "\u2A3A",
  triplus: "\u2A39",
  trisb: "\u29CD",
  tritime: "\u2A3B",
  trpezium: "\u23E2",
  tscr: "\u{1D4C9}",
  tscy: "\u0446",
  tshcy: "\u045B",
  tstrok: "\u0167",
  twixt: "\u226C",
  twoheadleftarrow: "\u219E",
  twoheadrightarrow: "\u21A0",
  uArr: "\u21D1",
  uHar: "\u2963",
  uacut: "\xFA",
  uacute: "\xFA",
  uarr: "\u2191",
  ubrcy: "\u045E",
  ubreve: "\u016D",
  ucir: "\xFB",
  ucirc: "\xFB",
  ucy: "\u0443",
  udarr: "\u21C5",
  udblac: "\u0171",
  udhar: "\u296E",
  ufisht: "\u297E",
  ufr: "\u{1D532}",
  ugrav: "\xF9",
  ugrave: "\xF9",
  uharl: "\u21BF",
  uharr: "\u21BE",
  uhblk: "\u2580",
  ulcorn: "\u231C",
  ulcorner: "\u231C",
  ulcrop: "\u230F",
  ultri: "\u25F8",
  umacr: "\u016B",
  um: "\xA8",
  uml: "\xA8",
  uogon: "\u0173",
  uopf: "\u{1D566}",
  uparrow: "\u2191",
  updownarrow: "\u2195",
  upharpoonleft: "\u21BF",
  upharpoonright: "\u21BE",
  uplus: "\u228E",
  upsi: "\u03C5",
  upsih: "\u03D2",
  upsilon: "\u03C5",
  upuparrows: "\u21C8",
  urcorn: "\u231D",
  urcorner: "\u231D",
  urcrop: "\u230E",
  uring: "\u016F",
  urtri: "\u25F9",
  uscr: "\u{1D4CA}",
  utdot: "\u22F0",
  utilde: "\u0169",
  utri: "\u25B5",
  utrif: "\u25B4",
  uuarr: "\u21C8",
  uum: "\xFC",
  uuml: "\xFC",
  uwangle: "\u29A7",
  vArr: "\u21D5",
  vBar: "\u2AE8",
  vBarv: "\u2AE9",
  vDash: "\u22A8",
  vangrt: "\u299C",
  varepsilon: "\u03F5",
  varkappa: "\u03F0",
  varnothing: "\u2205",
  varphi: "\u03D5",
  varpi: "\u03D6",
  varpropto: "\u221D",
  varr: "\u2195",
  varrho: "\u03F1",
  varsigma: "\u03C2",
  varsubsetneq: "\u228A\uFE00",
  varsubsetneqq: "\u2ACB\uFE00",
  varsupsetneq: "\u228B\uFE00",
  varsupsetneqq: "\u2ACC\uFE00",
  vartheta: "\u03D1",
  vartriangleleft: "\u22B2",
  vartriangleright: "\u22B3",
  vcy: "\u0432",
  vdash: "\u22A2",
  vee: "\u2228",
  veebar: "\u22BB",
  veeeq: "\u225A",
  vellip: "\u22EE",
  verbar: "|",
  vert: "|",
  vfr: "\u{1D533}",
  vltri: "\u22B2",
  vnsub: "\u2282\u20D2",
  vnsup: "\u2283\u20D2",
  vopf: "\u{1D567}",
  vprop: "\u221D",
  vrtri: "\u22B3",
  vscr: "\u{1D4CB}",
  vsubnE: "\u2ACB\uFE00",
  vsubne: "\u228A\uFE00",
  vsupnE: "\u2ACC\uFE00",
  vsupne: "\u228B\uFE00",
  vzigzag: "\u299A",
  wcirc: "\u0175",
  wedbar: "\u2A5F",
  wedge: "\u2227",
  wedgeq: "\u2259",
  weierp: "\u2118",
  wfr: "\u{1D534}",
  wopf: "\u{1D568}",
  wp: "\u2118",
  wr: "\u2240",
  wreath: "\u2240",
  wscr: "\u{1D4CC}",
  xcap: "\u22C2",
  xcirc: "\u25EF",
  xcup: "\u22C3",
  xdtri: "\u25BD",
  xfr: "\u{1D535}",
  xhArr: "\u27FA",
  xharr: "\u27F7",
  xi: "\u03BE",
  xlArr: "\u27F8",
  xlarr: "\u27F5",
  xmap: "\u27FC",
  xnis: "\u22FB",
  xodot: "\u2A00",
  xopf: "\u{1D569}",
  xoplus: "\u2A01",
  xotime: "\u2A02",
  xrArr: "\u27F9",
  xrarr: "\u27F6",
  xscr: "\u{1D4CD}",
  xsqcup: "\u2A06",
  xuplus: "\u2A04",
  xutri: "\u25B3",
  xvee: "\u22C1",
  xwedge: "\u22C0",
  yacut: "\xFD",
  yacute: "\xFD",
  yacy: "\u044F",
  ycirc: "\u0177",
  ycy: "\u044B",
  ye: "\xA5",
  yen: "\xA5",
  yfr: "\u{1D536}",
  yicy: "\u0457",
  yopf: "\u{1D56A}",
  yscr: "\u{1D4CE}",
  yucy: "\u044E",
  yum: "\xFF",
  yuml: "\xFF",
  zacute: "\u017A",
  zcaron: "\u017E",
  zcy: "\u0437",
  zdot: "\u017C",
  zeetrf: "\u2128",
  zeta: "\u03B6",
  zfr: "\u{1D537}",
  zhcy: "\u0436",
  zigrarr: "\u21DD",
  zopf: "\u{1D56B}",
  zscr: "\u{1D4CF}",
  zwj: "\u200D",
  zwnj: "\u200C"
};

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/parse-entities-npm-3.0.0-da12de3a6f-0a37ebb3e4.zip/node_modules/parse-entities/decode-entity.js
var own3 = {}.hasOwnProperty;
function decodeEntity(characters2) {
  return own3.call(characterEntities, characters2) ? characterEntities[characters2] : false;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let max;
  let test;
  return start;
  function start(code2) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code2);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test = asciiAlphanumeric;
    return value(code2);
  }
  function numeric(code2) {
    if (code2 === 88 || code2 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test = asciiDigit;
    return value(code2);
  }
  function value(code2) {
    let token;
    if (code2 === 59 && size) {
      token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeEntity(self2.sliceSerialize(token))) {
        return nok(code2);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok2;
    }
    if (test(code2) && size++ < max) {
      effects.consume(code2);
      return value;
    }
    return nok(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/code-fenced.js
var codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self2 = this;
  const closingFenceConstruct = {
    tokenize: tokenizeClosingFence,
    partial: true
  };
  const nonLazyLine = {
    tokenize: tokenizeNonLazyLine,
    partial: true
  };
  const tail = this.events[this.events.length - 1];
  const initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    marker = code2;
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeFencedFenceSequence");
    return sizeOpen < 3 ? nok(code2) : factorySpace(effects, infoOpen, "whitespace")(code2);
  }
  function infoOpen(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return openAfter(code2);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code2);
  }
  function info(code2) {
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, infoAfter, "whitespace")(code2);
    }
    if (code2 === 96 && code2 === marker)
      return nok(code2);
    effects.consume(code2);
    return info;
  }
  function infoAfter(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return openAfter(code2);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return openAfter(code2);
    }
    if (code2 === 96 && code2 === marker)
      return nok(code2);
    effects.consume(code2);
    return meta;
  }
  function openAfter(code2) {
    effects.exit("codeFencedFence");
    return self2.interrupt ? ok2(code2) : contentStart(code2);
  }
  function contentStart(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(nonLazyLine, effects.attempt(closingFenceConstruct, after, initialPrefix ? factorySpace(effects, contentStart, "linePrefix", initialPrefix + 1) : contentStart), after)(code2);
    }
    effects.enter("codeFlowValue");
    return contentContinue(code2);
  }
  function contentContinue(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return contentStart(code2);
    }
    effects.consume(code2);
    return contentContinue;
  }
  function after(code2) {
    effects.exit("codeFenced");
    return ok2(code2);
  }
  function tokenizeNonLazyLine(effects2, ok3, nok2) {
    const self3 = this;
    return start2;
    function start2(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code2) {
      return self3.parser.lazy[self3.now().line] ? nok2(code2) : ok3(code2);
    }
  }
  function tokenizeClosingFence(effects2, ok3, nok2) {
    let size = 0;
    return factorySpace(effects2, closingSequenceStart, "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function closingSequenceStart(code2) {
      effects2.enter("codeFencedFence");
      effects2.enter("codeFencedFenceSequence");
      return closingSequence(code2);
    }
    function closingSequence(code2) {
      if (code2 === marker) {
        effects2.consume(code2);
        size++;
        return closingSequence;
      }
      if (size < sizeOpen)
        return nok2(code2);
      effects2.exit("codeFencedFenceSequence");
      return factorySpace(effects2, closingSequenceEnd, "whitespace")(code2);
    }
    function closingSequenceEnd(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("codeFencedFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var indentedContent = {
  tokenize: tokenizeIndentedContent,
  partial: true
};
function tokenizeCodeIndented(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterStartPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterStartPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? afterPrefix(code2) : nok(code2);
  }
  function afterPrefix(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(indentedContent, afterPrefix, after)(code2);
    }
    effects.enter("codeFlowValue");
    return content3(code2);
  }
  function content3(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return afterPrefix(code2);
    }
    effects.consume(code2);
    return content3;
  }
  function after(code2) {
    effects.exit("codeIndented");
    return ok2(code2);
  }
}
function tokenizeIndentedContent(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return start;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? start(code2) : nok(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/code-text.js
var codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size;
  let token;
  return start;
  function start(code2) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return openingSequence(code2);
  }
  function openingSequence(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      sizeOpen++;
      return openingSequence;
    }
    effects.exit("codeTextSequence");
    return gap(code2);
  }
  function gap(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 96) {
      token = effects.enter("codeTextSequence");
      size = 0;
      return closingSequence(code2);
    }
    if (code2 === 32) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return gap;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return gap;
    }
    effects.enter("codeTextData");
    return data(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
      effects.exit("codeTextData");
      return gap(code2);
    }
    effects.consume(code2);
    return data;
  }
  function closingSequence(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      size++;
      return closingSequence;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok2(code2);
    }
    token.type = "codeTextData";
    return data(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-util-subtokenize-npm-1.0.2-9d0d437340-14a819ec4a.zip/node_modules/micromark-util-subtokenize/index.js
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line) {
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    jumps.unshift([start2, start2 + slice.length - 1]);
    splice(events, start2, 2, slice);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/content.js
var content2 = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
var continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous2;
  return start;
  function start(code2) {
    effects.enter("content");
    previous2 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(continuationConstruct, contentContinue, contentEnd)(code2);
    }
    effects.consume(code2);
    return data;
  }
  function contentEnd(code2) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok2(code2);
  }
  function contentContinue(code2) {
    effects.consume(code2);
    effects.exit("chunkContent");
    previous2.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous2
    });
    previous2 = previous2.next;
    return data;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code2) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok2(code2);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-factory-destination-npm-1.0.0-ead4af0386-e19f074843.zip/node_modules/micromark-factory-destination/index.js
function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code2) {
    if (code2 === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return destinationEnclosedBefore;
    }
    if (code2 === null || code2 === 41 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationRaw(code2);
  }
  function destinationEnclosedBefore(code2) {
    if (code2 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationEnclosed(code2);
  }
  function destinationEnclosed(code2) {
    if (code2 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return destinationEnclosedBefore(code2);
    }
    if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? destinationEnclosedEscape : destinationEnclosed;
  }
  function destinationEnclosedEscape(code2) {
    if (code2 === 60 || code2 === 62 || code2 === 92) {
      effects.consume(code2);
      return destinationEnclosed;
    }
    return destinationEnclosed(code2);
  }
  function destinationRaw(code2) {
    if (code2 === 40) {
      if (++balance > limit)
        return nok(code2);
      effects.consume(code2);
      return destinationRaw;
    }
    if (code2 === 41) {
      if (!balance--) {
        effects.exit("chunkString");
        effects.exit(stringType);
        effects.exit(rawType);
        effects.exit(type);
        return ok2(code2);
      }
      effects.consume(code2);
      return destinationRaw;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      if (balance)
        return nok(code2);
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok2(code2);
    }
    if (asciiControl(code2))
      return nok(code2);
    effects.consume(code2);
    return code2 === 92 ? destinationRawEscape : destinationRaw;
  }
  function destinationRawEscape(code2) {
    if (code2 === 40 || code2 === 41 || code2 === 92) {
      effects.consume(code2);
      return destinationRaw;
    }
    return destinationRaw(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-factory-label-npm-1.0.2-aa46281fdc-27099d441b.zip/node_modules/micromark-factory-label/index.js
function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 && !data || code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs || size > 999) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return label(code2);
  }
  function label(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    data = data || !markdownSpace(code2);
    return code2 === 92 ? labelEscape : label;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return label;
    }
    return label(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-factory-title-npm-1.0.2-3739fc0d5d-3f47b2f7cf.zip/node_modules/micromark-factory-title/index.js
function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    marker = code2 === 40 ? 41 : code2;
    return atFirstTitleBreak;
  }
  function atFirstTitleBreak(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    return atTitleBreak(code2);
  }
  function atTitleBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return atFirstTitleBreak(marker);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, atTitleBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return title(code2);
  }
  function title(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      return atTitleBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? titleEscape : title;
  }
  function titleEscape(code2) {
    if (code2 === marker || code2 === 92) {
      effects.consume(code2);
      return title;
    }
    return title(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-factory-whitespace-npm-1.0.0-ea665f7a7c-eebacb0897.zip/node_modules/micromark-factory-whitespace/index.js
function factoryWhitespace(effects, ok2) {
  let seen;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code2);
    }
    return ok2(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-util-normalize-identifier-npm-1.0.0-79f4e82268-a8f0ef3203.zip/node_modules/micromark-util-normalize-identifier/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/definition.js
var definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
var titleConstruct = {
  tokenize: tokenizeTitle,
  partial: true
};
function tokenizeDefinition(effects, ok2, nok) {
  const self2 = this;
  let identifier;
  return start;
  function start(code2) {
    effects.enter("definition");
    return factoryLabel.call(self2, effects, labelAfter, nok, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(code2);
  }
  function labelAfter(code2) {
    identifier = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return factoryWhitespace(effects, factoryDestination(effects, effects.attempt(titleConstruct, factorySpace(effects, after, "whitespace"), factorySpace(effects, after, "whitespace")), nok, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString"));
    }
    return nok(code2);
  }
  function after(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("definition");
      if (!self2.parser.defined.includes(identifier)) {
        self2.parser.defined.push(identifier);
      }
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitle(effects, ok2, nok) {
  return start;
  function start(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, before)(code2) : nok(code2);
  }
  function before(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(effects, factorySpace(effects, after, "whitespace"), nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code2);
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("hardBreakEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit("escapeMarker");
      effects.exit("hardBreakEscape");
      return ok2(code2);
    }
    return nok(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text4;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text4 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text4, context],
      ["exit", text4, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("atxHeading");
    effects.enter("atxHeadingSequence");
    return fenceOpenInside(code2);
  }
  function fenceOpenInside(code2) {
    if (code2 === 35 && size++ < 6) {
      effects.consume(code2);
      return fenceOpenInside;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingSequence");
      return self2.interrupt ? ok2(code2) : headingBreak(code2);
    }
    return nok(code2);
  }
  function headingBreak(code2) {
    if (code2 === 35) {
      effects.enter("atxHeadingSequence");
      return sequence(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("atxHeading");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, headingBreak, "whitespace")(code2);
    }
    effects.enter("atxHeadingText");
    return data(code2);
  }
  function sequence(code2) {
    if (code2 === 35) {
      effects.consume(code2);
      return sequence;
    }
    effects.exit("atxHeadingSequence");
    return headingBreak(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingText");
      return headingBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-util-html-tag-name-npm-1.0.0-0b74ebd751-bdbcde984b.zip/node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/html-flow.js
var htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var nextBlankConstruct = {
  tokenize: tokenizeNextBlank,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self2 = this;
  let kind;
  let startTag;
  let buffer2;
  let index2;
  let marker;
  return start;
  function start(code2) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationStart;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      kind = 3;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      startTag = true;
      return tagName;
    }
    return nok(code2);
  }
  function declarationStart(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      kind = 2;
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      kind = 5;
      buffer2 = "CDATA[";
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      kind = 4;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    if (code2 === buffer2.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === buffer2.length ? self2.interrupt ? ok2 : continuation : cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      if (code2 !== 47 && startTag && htmlRawNames.includes(buffer2.toLowerCase())) {
        kind = 1;
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer2.toLowerCase())) {
        kind = 6;
        if (code2 === 47) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      kind = 7;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : startTag ? completeAttributeNameBefore(code2) : completeClosingTagAfter(code2);
    }
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    marker = null;
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    if (code2 === marker) {
      effects.consume(code2);
      return completeAttributeValueQuotedAfter;
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return code2 === null || markdownLineEnding(code2) ? continuation(code2) : nok(code2);
  }
  function continuation(code2) {
    if (code2 === 45 && kind === 2) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === 60 && kind === 1) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === 62 && kind === 4) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 63 && kind === 3) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === 93 && kind === 5) {
      effects.consume(code2);
      return continuationCharacterDataInside;
    }
    if (markdownLineEnding(code2) && (kind === 6 || kind === 7)) {
      return effects.check(nextBlankConstruct, continuationClose, continuationAtLineEnding)(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return continuationAtLineEnding(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationAtLineEnding(code2) {
    effects.exit("htmlFlowData");
    return htmlContinueStart(code2);
  }
  function htmlContinueStart(code2) {
    if (code2 === null) {
      return done(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt({
        tokenize: htmlLineEnd,
        partial: true
      }, htmlContinueStart, done)(code2);
    }
    effects.enter("htmlFlowData");
    return continuation(code2);
  }
  function htmlLineEnd(effects2, ok3, nok2) {
    return start2;
    function start2(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code2) {
      return self2.parser.lazy[self2.now().line] ? nok2(code2) : ok3(code2);
    }
  }
  function continuationCommentInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      buffer2 = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === 62 && htmlRawNames.includes(buffer2.toLowerCase())) {
      effects.consume(code2);
      return continuationClose;
    }
    if (asciiAlpha(code2) && buffer2.length < 8) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCharacterDataInside(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return continuationClose;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return done(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function done(code2) {
    effects.exit("htmlFlow");
    return ok2(code2);
  }
}
function tokenizeNextBlank(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.exit("htmlFlowData");
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    return effects.attempt(blankLine, ok2, nok);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/html-text.js
var htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let buffer2;
  let index2;
  let returnState;
  return start;
  function start(code2) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentOpen;
    }
    if (code2 === 91) {
      effects.consume(code2);
      buffer2 = "CDATA[";
      index2 = 0;
      return cdataOpen;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration;
    }
    return nok(code2);
  }
  function commentOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentStart;
    }
    return nok(code2);
  }
  function commentStart(code2) {
    if (code2 === null || code2 === 62) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentStartDash;
    }
    return comment(code2);
  }
  function commentStartDash(code2) {
    if (code2 === null || code2 === 62) {
      return nok(code2);
    }
    return comment(code2);
  }
  function comment(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return comment;
  }
  function commentClose(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return end;
    }
    return comment(code2);
  }
  function cdataOpen(code2) {
    if (code2 === buffer2.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === buffer2.length ? cdata : cdataOpen;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === 62) {
      return end(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration(code2) {
    if (code2 === null || code2 === 62) {
      return end(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return declaration;
  }
  function instruction(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === 62 ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end(code2);
  }
  function tagOpen(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return end;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return atLineEnding(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    marker = void 0;
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return atLineEnding(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === 62 || code2 === 47 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function atLineEnding(code2) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, afterPrefix, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
  }
  function afterPrefix(code2) {
    effects.enter("htmlTextData");
    return returnState(code2);
  }
  function end(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok2;
    }
    return nok(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = {
  tokenize: tokenizeResource
};
var fullReferenceConstruct = {
  tokenize: tokenizeFullReference
};
var collapsedReferenceConstruct = {
  tokenize: tokenizeCollapsedReference
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  let token;
  while (++index2 < events.length) {
    token = events[index2][1];
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index2;
        if (token.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text4 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text4, context]]);
  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));
  media = push(media, [
    ["exit", text4, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive)
      return balanced(code2);
    defined = self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize({
      start: labelStart.end,
      end: self2.now()
    })));
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return afterLabelEnd;
  }
  function afterLabelEnd(code2) {
    if (code2 === 40) {
      return effects.attempt(resourceConstruct, ok2, defined ? ok2 : balanced)(code2);
    }
    if (code2 === 91) {
      return effects.attempt(fullReferenceConstruct, ok2, defined ? effects.attempt(collapsedReferenceConstruct, ok2, balanced) : balanced)(code2);
    }
    return defined ? ok2(code2) : balanced(code2);
  }
  function balanced(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code2);
    effects.exit("resourceMarker");
    return factoryWhitespace(effects, open);
  }
  function open(code2) {
    if (code2 === 41) {
      return end(code2);
    }
    return factoryDestination(effects, destinationAfter, nok, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 3)(code2);
  }
  function destinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, between)(code2) : end(code2);
  }
  function between(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(effects, factoryWhitespace(effects, end), nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code2);
    }
    return end(code2);
  }
  function end(code2) {
    if (code2 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code2);
  }
}
function tokenizeFullReference(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    return factoryLabel.call(self2, effects, afterLabel, nok, "reference", "referenceMarker", "referenceString")(code2);
  }
  function afterLabel(code2) {
    return self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok2(code2) : nok(code2);
  }
}
function tokenizeCollapsedReference(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code2);
    effects.exit("referenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code2);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 91) {
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/line-ending.js
var lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, ok2, "linePrefix");
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter("thematicBreak");
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, "whitespace")(code2);
    }
    if (size < 3 || code2 !== null && !markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.exit("thematicBreak");
    return ok2(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return atBreak(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/list.js
var list = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
function tokenizeListStart(effects, ok2, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code2) {
    const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code2 === 42 || code2 === 45 ? effects.check(thematicBreak, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self2.interrupt || code2 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    if (asciiDigit(code2) && ++size < 10) {
      effects.consume(code2);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    effects.enter("listItemMarker");
    effects.consume(code2);
    effects.exit("listItemMarker");
    self2.containerState.marker = self2.containerState.marker || code2;
    return effects.check(blankLine, self2.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));
  }
  function onBlank(code2) {
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code2);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok2(code2);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self2 = this;
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(effects, ok2, "listItemIndent", self2.containerState.size + 1)(code2);
  }
  function notBlank(code2) {
    if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    return factorySpace(effects, effects.attempt(list, ok2, nok), "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
  }
}
function tokenizeIndent(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-core-commonmark-npm-1.0.3-e5a721c107-8b90603145.zip/node_modules/micromark-core-commonmark/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content3;
  let text4;
  let definition3;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content3 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text4 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition3 && events[index2][1].type === "definition") {
        definition3 = index2;
      }
    }
  }
  const heading2 = {
    type: "setextHeading",
    start: Object.assign({}, events[text4][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text4][1].type = "setextHeadingText";
  if (definition3) {
    events.splice(text4, 0, ["enter", heading2, context]);
    events.splice(definition3 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = Object.assign({}, events[definition3][1].end);
  } else {
    events[content3][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let marker;
  let paragraph2;
  while (index2--) {
    if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
      paragraph2 = self2.events[index2][1].type === "paragraph";
      break;
    }
  }
  return start;
  function start(code2) {
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter("setextHeadingLine");
      effects.enter("setextHeadingLineSequence");
      marker = code2;
      return closingSequence(code2);
    }
    return nok(code2);
  }
  function closingSequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return closingSequence;
    }
    effects.exit("setextHeadingLineSequence");
    return factorySpace(effects, closingSequenceEnd, "lineSuffix")(code2);
  }
  function closingSequenceEnd(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("setextHeadingLine");
      return ok2(code2);
    }
    return nok(code2);
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-3.0.7-da94deb9a9-741af00392.zip/node_modules/micromark/lib/initialize/flow.js
var flow = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(blankLine, atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content2, afterConstruct)), "linePrefix")));
  return initial;
  function atBlankEnding(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    self2.currentConstruct = void 0;
    return initial;
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-3.0.7-da94deb9a9-741af00392.zip/node_modules/micromark/lib/initialize/text.js
var resolver = {
  resolveAll: createResolver()
};
var string2 = initializeFactory("string");
var text = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0)
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text4 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code2) {
      return atBreak(code2) ? text4(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("data");
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit("data");
        return text4(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      if (code2 === null) {
        return true;
      }
      const list3 = constructs2[code2];
      let index2 = -1;
      if (list3) {
        while (++index2 < list3.length) {
          const item = list3[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = -1;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1) {
        } else {
          index2++;
          break;
        }
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-3.0.7-da94deb9a9-741af00392.zip/node_modules/micromark/lib/create-tokenizer.js
function createTokenizer(parser, initialize, from) {
  let point2 = Object.assign(from ? Object.assign({}, from) : {
    line: 1,
    column: 1,
    offset: 0
  }, {
    _index: 0,
    _bufferIndex: -1
  });
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main2();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    return Object.assign({}, point2);
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main2() {
    let chunkIndex;
    while (point2._index < chunks.length) {
      const chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    consumed = void 0;
    expectedCode = code2;
    state = state(code2);
  }
  function consume(code2) {
    if (markdownLineEnding(code2)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code2 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code2 !== -1) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context.previous = code2;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit2(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_6, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map3) {
        return start;
        function start(code2) {
          const def = code2 !== null && map3[code2];
          const all2 = code2 !== null && map3.null;
          const list3 = [
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list3)(code2);
        }
      }
      function handleListOfConstructs(list3) {
        listOfConstructs = list3;
        constructIndex = 0;
        if (list3.length === 0) {
          return bogusState;
        }
        return handleConstruct(list3[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code2);
          }
          return construct.tokenize.call(fields ? Object.assign(Object.create(context), fields) : context, effects, ok2, nok)(code2);
        }
      }
      function ok2(code2) {
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point2 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      view[0] = view[0].slice(startBufferIndex);
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab)
            continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-3.0.7-da94deb9a9-741af00392.zip/node_modules/micromark/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document2,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string3,
  text: () => text2
});
var document2 = {
  [42]: list,
  [43]: list,
  [45]: list,
  [48]: list,
  [49]: list,
  [50]: list,
  [51]: list,
  [52]: list,
  [53]: list,
  [54]: list,
  [55]: list,
  [56]: list,
  [57]: list,
  [62]: blockQuote
};
var contentInitial = {
  [91]: definition
};
var flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
var flow2 = {
  [35]: headingAtx,
  [42]: thematicBreak,
  [45]: [setextUnderline, thematicBreak],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak,
  [96]: codeFenced,
  [126]: codeFenced
};
var string3 = {
  [38]: characterReference,
  [92]: characterEscape
};
var text2 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
var insideSpan = {
  null: [attention, resolver]
};
var attentionMarkers = {
  null: [42, 95]
};
var disable = {
  null: []
};

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-3.0.7-da94deb9a9-741af00392.zip/node_modules/micromark/lib/parse.js
function parse(options = {}) {
  const constructs2 = combineExtensions([constructs_exports].concat(options.extensions || []));
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create(content),
    document: create(document),
    flow: create(flow),
    string: create(string2),
    text: create(text)
  };
  return parser;
  function create(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-3.0.7-da94deb9a9-741af00392.zip/node_modules/micromark/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer2 = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code2;
    value = buffer2 + value.toString(encoding);
    startPosition = 0;
    buffer2 = "";
    if (start) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code2 = value.charCodeAt(endPosition);
      if (!match) {
        buffer2 = value.slice(startPosition);
        break;
      }
      if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code2) {
          case 0: {
            chunks.push(65533);
            column++;
            break;
          }
          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next)
              chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer2)
        chunks.push(buffer2);
      chunks.push(null);
    }
    return chunks;
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-npm-3.0.7-da94deb9a9-741af00392.zip/node_modules/micromark/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-util-decode-numeric-character-reference-npm-1.0.0-68686444bf-d1dc565548.zip/node_modules/micromark-util-decode-numeric-character-reference/index.js
function decodeNumericCharacterReference(value, base2) {
  const code2 = Number.parseInt(value, base2);
  if (code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || code2 > 126 && code2 < 160 || code2 > 55295 && code2 < 57344 || code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || code2 > 1114111) {
    return "\uFFFD";
  }
  return String.fromCharCode(code2);
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/micromark-util-decode-string-npm-1.0.1-f5f8681728-eb52c3e2fe.zip/node_modules/micromark-util-decode-string/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeEntity($2) || $0;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-from-markdown-npm-1.0.4-0ff0b25e18-4117250ca2.zip/node_modules/mdast-util-from-markdown/lib/index.js
var own4 = {}.hasOwnProperty;
var fromMarkdown = function(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));
};
function compiler(options = {}) {
  const config = configure({
    transforms: [],
    canContainEols: [
      "emphasis",
      "fragment",
      "heading",
      "paragraph",
      "strong"
    ],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer2,
      codeFencedFenceMeta: buffer2,
      codeIndented: opener(codeFlow, buffer2),
      codeText: opener(codeText2, buffer2),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition3),
      definitionDestinationString: buffer2,
      definitionLabelString: buffer2,
      definitionTitleString: buffer2,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html2, buffer2),
      htmlFlowData: onenterdata,
      htmlText: opener(html2, buffer2),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer2,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list3, onenterlistordered),
      listUnordered: opener(list3),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer2,
      resourceDestinationString: buffer2,
      resourceTitleString: buffer2,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak3)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  }, options.mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const stack = [tree];
    const tokenStack = [];
    const listStack = [];
    const context = {
      stack,
      tokenStack,
      config,
      enter,
      exit: exit2,
      buffer: buffer2,
      resume,
      setData,
      getData
    };
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own4.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(Object.assign({
          sliceSerialize: events[index2][2].sliceSerialize
        }, context), events[index2][1]);
      }
    }
    if (tokenStack.length > 0) {
      throw new Error("Cannot close document, a token (`" + tokenStack[tokenStack.length - 1].type + "`, " + stringifyPosition({
        start: tokenStack[tokenStack.length - 1].start,
        end: tokenStack[tokenStack.length - 1].end
      }) + ") is still open");
    }
    tree.position = {
      start: point2(events.length > 0 ? events[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: point2(events.length > 0 ? events[events.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === "lineEndingBlank") {
        if (event[0] === "enter") {
          if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index2;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace") {
      } else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          listItem3 = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start)
          };
          events.splice(index2, 0, ["enter", listItem3, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function setData(key2, value) {
    data[key2] = value;
  }
  function getData(key2) {
    return data[key2];
  }
  function point2(d) {
    return {
      line: d.line,
      column: d.column,
      offset: d.offset
    };
  }
  function opener(create, and) {
    return open;
    function open(token) {
      enter.call(this, create(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer2() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node, token) {
    const parent = this.stack[this.stack.length - 1];
    parent.children.push(node);
    this.stack.push(node);
    this.tokenStack.push(token);
    node.position = {
      start: point2(token.start)
    };
    return node;
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and)
        and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token) {
    const node = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
        start: token.start,
        end: token.end
      }) + "): it\u2019s not open");
    } else if (open.type !== token.type) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
        start: token.start,
        end: token.end
      }) + "): a different token (`" + open.type + "`, " + stringifyPosition({
        start: open.start,
        end: open.end
      }) + ") is open");
    }
    node.position.end = point2(token.end);
    return node;
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    setData("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token) {
    if (getData("expectingFirstListItemValue")) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      setData("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.meta = data2;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside"))
      return;
    this.buffer();
    setData("flowCodeInside", true);
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData("flowCodeInside");
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node = this.stack[this.stack.length - 1];
    if (!node.depth) {
      const depth = this.sliceSerialize(token).length;
      node.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    setData("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token) {
    const node = this.stack[this.stack.length - 1];
    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    setData("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token) {
    const parent = this.stack[this.stack.length - 1];
    let tail = parent.children[parent.children.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text4();
      tail.position = {
        start: point2(token.start)
      };
      parent.children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (getData("atHardBreak")) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point2(token.end);
      setData("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    setData("atHardBreak", true);
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data2;
  }
  function onexitlink() {
    const context = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      context.type += "Reference";
      context.referenceType = getData("referenceType") || "shortcut";
      delete context.url;
      delete context.title;
    } else {
      delete context.identifier;
      delete context.label;
    }
    setData("referenceType");
  }
  function onexitimage() {
    const context = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      context.type += "Reference";
      context.referenceType = getData("referenceType") || "shortcut";
      delete context.url;
      delete context.title;
    } else {
      delete context.identifier;
      delete context.label;
    }
    setData("referenceType");
  }
  function onexitlabeltext(token) {
    const ancestor = this.stack[this.stack.length - 2];
    const string4 = this.sliceSerialize(token);
    ancestor.label = decodeString(string4);
    ancestor.identifier = normalizeIdentifier(string4).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node = this.stack[this.stack.length - 1];
    setData("inReference", true);
    if (node.type === "link") {
      node.children = fragment.children;
    } else {
      node.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.title = data2;
  }
  function onexitresource() {
    setData("inReference");
  }
  function onenterreference() {
    setData("referenceType", "collapsed");
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    setData("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token) {
    setData("characterReferenceType", token.type);
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = getData("characterReferenceType");
    let value;
    if (type) {
      value = decodeNumericCharacterReference(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
      setData("characterReferenceType");
    } else {
      value = decodeEntity(data2);
    }
    const tail = this.stack.pop();
    tail.value += value;
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node = this.stack[this.stack.length - 1];
    node.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node = this.stack[this.stack.length - 1];
    node.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition3() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading2() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function hardBreak2() {
    return {
      type: "break"
    };
  }
  function html2() {
    return {
      type: "html",
      value: ""
    };
  }
  function image2() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link2() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list3(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong2() {
    return {
      type: "strong",
      children: []
    };
  }
  function text4() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak3() {
    return {
      type: "thematicBreak"
    };
  }
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
  return combined;
}
function extension(combined, extension2) {
  let key2;
  for (key2 in extension2) {
    if (own4.call(extension2, key2)) {
      const list3 = key2 === "canContainEols" || key2 === "transforms";
      const maybe = own4.call(combined, key2) ? combined[key2] : void 0;
      const left = maybe || (combined[key2] = list3 ? [] : {});
      const right = extension2[key2];
      if (right) {
        if (list3) {
          combined[key2] = [...left, ...right];
        } else {
          Object.assign(left, right);
        }
      }
    }
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/remark-parse-npm-10.0.0-a311463b1a-161a56a41d.zip/node_modules/remark-parse/lib/index.js
function remarkParse(options) {
  const parser = (doc) => {
    const settings = this.data("settings");
    return fromMarkdown(doc, Object.assign({}, settings, options, {
      extensions: this.data("micromarkExtensions") || [],
      mdastExtensions: this.data("fromMarkdownExtensions") || []
    }));
  };
  Object.assign(this, { Parser: parser });
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/remark-parse-npm-10.0.0-a311463b1a-161a56a41d.zip/node_modules/remark-parse/index.js
var remark_parse_default = remarkParse;

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/mdx/parse.ts
var import_remark_mdx = __toModule(require_remark_mdx());

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/unist-util-is-npm-5.1.1-eeef3df35f-5f42529c8d.zip/node_modules/unist-util-is/index.js
var convert = function(test) {
  if (test === void 0 || test === null) {
    return ok;
  }
  if (typeof test === "string") {
    return typeFactory(test);
  }
  if (typeof test === "object") {
    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
  }
  if (typeof test === "function") {
    return castFactory(test);
  }
  throw new Error("Expected function, string, or object as test");
};
function anyFactory(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory(all2);
  function all2(node) {
    let key2;
    for (key2 in check) {
      if (node[key2] !== check[key2])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node) {
    return node && node.type === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(...parameters) {
    return Boolean(check.call(this, ...parameters));
  }
}
function ok() {
  return true;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/unist-util-visit-parents-npm-5.1.0-5b9348080b-0f3de815f3.zip/node_modules/unist-util-visit-parents/color.js
function color(d) {
  return "[33m" + d + "[39m";
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/unist-util-visit-parents-npm-5.1.0-5b9348080b-0f3de815f3.zip/node_modules/unist-util-visit-parents/index.js
var CONTINUE = true;
var SKIP = "skip";
var EXIT = false;
var visitParents = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  const is = convert(test);
  const step = reverse ? -1 : 1;
  factory(tree, null, [])();
  function factory(node, index2, parents) {
    const value = typeof node === "object" && node !== null ? node : {};
    let name2;
    if (typeof value.type === "string") {
      name2 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
      Object.defineProperty(visit3, "name", {
        value: "node (" + color(value.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit3;
    function visit3() {
      let result = [];
      let subresult;
      let offset;
      let grandparents;
      if (!test || is(node, index2, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if (node.children && result[0] !== SKIP) {
        offset = (reverse ? node.children.length : -1) + step;
        grandparents = parents.concat(node);
        while (offset > -1 && offset < node.children.length) {
          subresult = factory(node.children[offset], offset, grandparents)();
          if (subresult[0] === EXIT) {
            return subresult;
          }
          offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
        }
      }
      return result;
    }
  }
};
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return [value];
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/unist-util-visit-npm-4.1.0-71b0165ce5-0598d26f46.zip/node_modules/unist-util-visit/index.js
var visit = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node, parents) {
    const parent = parents[parents.length - 1];
    return visitor(node, parent ? parent.children.indexOf(node) : null, parent);
  }
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/mdx/parse.ts
var import_lodash4 = __toModule(require("lodash"));
var parseMDX = (value, field) => {
  const tree = unified().use(remark_parse_default).use(import_remark_mdx.default).parse(value);
  return parseMDXInner(tree, field);
};
var parseMDXInner = (tree, field) => {
  visit(tree, (node) => {
    delete node.position;
  });
  visit(tree, ["mdxJsxFlowElement", "mdxJsxTextElement"], (node) => {
    var _a;
    let props = {};
    if (!node.name) {
      props = parseMDXInner({ type: "root", children: node.children }, field);
    }
    const template = (_a = field.templates) == null ? void 0 : _a.find((template2) => {
      const templateName = typeof template2 === "string" ? template2 : template2.name;
      return templateName === node.name;
    });
    if (!template) {
      if ((0, import_lodash4.isNull)(node.name)) {
      } else {
        throw new Error(`Found unregistered JSX or HTML: <${node.name}>. Please ensure all structured elements have been registered with your schema.`);
      }
    }
    if (node.children.length > 0) {
      node.attributes.push({
        value: node.children,
        name: "children",
        type: "mdxJsxAttribute"
      });
    }
    node.children = null;
    node.attributes.forEach((attribute) => {
      if (attribute.type === "mdxJsxAttribute") {
        if (typeof template === "string") {
          throw new Error("Global templates not yet supported");
        }
        if (!template) {
        } else {
          const field2 = template.fields.find((field3) => field3.name === attribute.name);
          if (!field2) {
            throw new Error(`Unknown property '${attribute.name}' for embedded structure '${node.name}'`);
          }
          parseField(attribute, field2, props);
        }
      } else {
        console.log(`Not sure what this is, type: ${attribute.type}`);
      }
    });
    delete node.attributes;
    node.props = props;
  });
  const slateTree = tree.children.map(remarkToSlate);
  return { type: "root", children: slateTree };
};
var parseField = (attribute, field, props) => {
  var _a, _b;
  switch (field.type) {
    case "boolean":
    case "datetime":
    case "image":
    case "number":
    case "string":
      if (field.list) {
        if (((_a = attribute.value) == null ? void 0 : _a.type) === "mdxJsxAttributeValueExpression") {
          attribute.value.data.estree.body.forEach((item) => {
            if (item.type === "ExpressionStatement") {
              if (item.expression.type === "ArrayExpression") {
                props[field.name] = item.expression.elements.map((element) => {
                  if (element.type === "Literal") {
                    return element.value;
                  } else {
                    throw new Error(`Only literals are supported for array expressions`);
                  }
                });
              }
            }
          });
        }
      } else {
        if (attribute.type === "Property") {
          if (attribute.value.type === "Literal") {
            props[attribute.key.name] = attribute.value.value;
          }
        } else if (((_b = attribute.value) == null ? void 0 : _b.type) === "mdxJsxAttributeValueExpression") {
          attribute.value.data.estree.body.forEach((item) => {
            if (item.type === "ExpressionStatement") {
              if (item.expression.type === "Literal") {
                props[field.name] = item.expression.value;
              }
              if (item.expression.type === "ArrayExpression") {
                throw new Error(`Unexpected array expression for non-list field ${field.name}`);
              }
              if (item.expression.type === "TemplateLiteral") {
                throw new Error(`Template literals are not yet supported`);
              }
            }
          });
        } else {
          props[field.name] = attribute.value;
        }
      }
      break;
    case "object":
      if (attribute.type === "mdxJsxAttribute") {
        if (attribute.value.type === "mdxJsxAttributeValueExpression") {
          attribute.value.data.estree.body.forEach((item) => {
            if (item.type === "ExpressionStatement") {
              if (item.expression.type === "ObjectExpression") {
                const objectProps = {};
                item.expression.properties.forEach((property) => {
                  if (property.key.type !== "Identifier") {
                    throw new Error(`Unexptected key type ${property.key.type}`);
                  }
                  if (property.value.type !== "Literal") {
                    throw new Error(`Unexptected value type ${property.value.type}`);
                  }
                  if (field.fields) {
                    if (typeof field.fields === "string") {
                      throw new Error(`Global fields not supported at this time`);
                    }
                    field.fields.forEach((field2) => {
                      parseField(property, field2, objectProps);
                    });
                  }
                });
                props[field.name] = objectProps;
              } else if (item.expression.type === "ArrayExpression") {
                const objectArrayProps = [];
                item.expression.elements.forEach((element) => {
                  if (element.type === "ObjectExpression") {
                    const objectProps = {};
                    element.properties.forEach((property) => {
                      if (property.key.type !== "Identifier") {
                        throw new Error(`Unexptected key type ${property.key.type}`);
                      }
                      if (property.value.type !== "Literal") {
                        throw new Error(`Unexptected value type ${property.value.type}`);
                      }
                      if (field.fields) {
                        if (typeof field.fields === "string") {
                          throw new Error(`Global fields not supported at this time`);
                        }
                        field.fields.forEach((field2) => {
                          parseField(property, field2, objectProps);
                        });
                      }
                      if (field.templates) {
                        field.templates.forEach((fieldTemplate) => {
                          if (typeof fieldTemplate === "string") {
                            throw new Error(`Global fields not supported at this time`);
                          }
                          fieldTemplate.fields.forEach((field2) => {
                            parseField(property, field2, objectProps);
                          });
                        });
                      }
                    });
                    objectArrayProps.push(objectProps);
                  } else {
                    throw new Error(`Unexpected expression type ${element.type}`);
                  }
                  props[field.name] = objectArrayProps;
                });
              } else {
                throw new Error("Only object expressions are supported");
              }
            }
          });
        }
      }
      break;
    case "rich-text":
      if (attribute.value) {
        if (field.name === "children") {
          if (Array.isArray(attribute.value)) {
            props[field.name] = parseMDXInner({ type: "root", children: attribute.value }, field);
          } else {
            throw Error(`Expected an array of MDX strings for rich-text field with the special name 'children'`);
          }
        } else {
          try {
            const mdx2 = parseMDX(attribute.value.value, field);
            props[field.name] = mdx2.children[0].props;
          } catch (e) {
            console.log(e);
          }
        }
      } else {
        console.log("nothing", field.name, import_remark_mdx.default);
      }
      break;
  }
};
var plateElements = {
  ELEMENT_H1: "h1",
  ELEMENT_H2: "h2",
  ELEMENT_H3: "h3",
  ELEMENT_H4: "h4",
  ELEMENT_H5: "h5",
  ELEMENT_H6: "h6",
  ELEMENT_HR: "hr",
  ELEMENT_ALIGN_CENTER: "align_center",
  ELEMENT_ALIGN_JUSTIFY: "align_justify",
  ELEMENT_ALIGN_LEFT: "align_left",
  ELEMENT_ALIGN_RIGHT: "align_right",
  ELEMENT_BLOCKQUOTE: "blockquote",
  ELEMENT_CODE_BLOCK: "code_block",
  ELEMENT_CODE_LINE: "code",
  ELEMENT_DEFAULT: "p",
  ELEMENT_IMAGE: "img",
  ELEMENT_LI: "li",
  ELEMENT_LIC: "lic",
  ELEMENT_LINK: "a",
  ELEMENT_MEDIA_EMBED: "media_embed",
  ELEMENT_MENTION: "mention",
  ELEMENT_OL: "ol",
  ELEMENT_PARAGRAPH: "p",
  ELEMENT_TABLE: "table",
  ELEMENT_TD: "td",
  ELEMENT_TH: "th",
  ELEMENT_TODO_LI: "action_item",
  ELEMENT_TR: "tr",
  ELEMENT_UL: "ul",
  MARK_ITALIC: "italic",
  MARK_BOLD: "bold",
  MARK_STRIKETHROUGH: "strikethrough",
  MARK_UNDERLINE: "underline"
};
var defaultNodeTypes = {
  paragraph: plateElements.ELEMENT_PARAGRAPH,
  block_quote: plateElements.ELEMENT_BLOCKQUOTE,
  code_block: plateElements.ELEMENT_CODE_BLOCK,
  link: plateElements.ELEMENT_LINK,
  ul_list: plateElements.ELEMENT_UL,
  ol_list: plateElements.ELEMENT_OL,
  listItem: plateElements.ELEMENT_LI,
  heading: {
    1: plateElements.ELEMENT_H1,
    2: plateElements.ELEMENT_H2,
    3: plateElements.ELEMENT_H3,
    4: plateElements.ELEMENT_H4,
    5: plateElements.ELEMENT_H5,
    6: plateElements.ELEMENT_H6
  },
  emphasis_mark: plateElements.MARK_ITALIC,
  strong_mark: plateElements.MARK_BOLD,
  delete_mark: plateElements.MARK_STRIKETHROUGH,
  inline_code_mark: plateElements.ELEMENT_CODE_LINE,
  thematic_break: plateElements.ELEMENT_HR,
  image: plateElements.ELEMENT_IMAGE
};
function remarkToSlate(node) {
  const types = __spreadProps(__spreadValues({}, defaultNodeTypes), {
    heading: __spreadValues({}, defaultNodeTypes.heading)
  });
  switch (node.type) {
    case "heading":
      return {
        type: types.heading[node.depth],
        children: node.children.map(remarkToSlate)
      };
    case "list":
      return {
        type: node.ordered ? types.ol_list : types.ul_list,
        children: node.children.map(remarkToSlate)
      };
    case "listItem":
      const realChildren = [];
      node.children.forEach((child) => {
        if (child.type === "list") {
          realChildren.push({
            type: child.ordered ? types.ol_list : types.ul_list,
            children: child.children.map(remarkToSlate)
          });
        } else {
          realChildren.push({
            type: plateElements.ELEMENT_LIC,
            children: child.children.map(remarkToSlate)
          });
        }
      });
      return {
        type: types.listItem,
        children: realChildren
      };
    case "paragraph":
      return {
        type: types.paragraph,
        children: node.children.map(remarkToSlate)
      };
    case "link":
      return {
        type: types.link,
        url: node.url,
        children: node.children.map(remarkToSlate)
      };
    case "image":
      return {
        type: types.image,
        url: node.url,
        alt: node.alt,
        caption: node.title
      };
    case "blockquote":
      return {
        type: types.block_quote,
        children: node.children.map(remarkToSlate)
      };
    case "code":
      return {
        type: types.code_block,
        lang: node.lang,
        children: node.value.split("\n").map((item) => ({
          type: "code_line",
          children: [{ type: "text", text: item }]
        }))
      };
    case "emphasis":
      return __spreadValues(__spreadValues({
        [types.emphasis_mark]: true
      }, forceLeafNode(node.children)), persistLeafFormats(node.children));
    case "strong":
      return __spreadValues(__spreadValues({
        [types.strong_mark]: true
      }, forceLeafNode(node.children)), persistLeafFormats(node.children));
    case "delete":
      return __spreadValues(__spreadValues({
        [types.delete_mark]: true
      }, forceLeafNode(node.children)), persistLeafFormats(node.children));
    case "inlineCode":
      return {
        [types.inline_code_mark]: true,
        text: node.value
      };
    case "thematicBreak":
      return {
        type: types.thematic_break,
        children: [{ type: "text", text: "" }]
      };
    case "text":
      return { type: "text", text: node.value || "" };
    case "mdxJsxFlowElement":
    case "mdxJsxTextElement":
      return __spreadProps(__spreadValues({}, node), {
        children: void 0
      });
    default:
      console.log("unknown", node);
      return { type: "text", text: "" };
  }
}
var forceLeafNode = (children) => {
  const extraProps = {};
  const text4 = [];
  children.forEach((k) => {
    switch (k.type) {
      case "inlineCode":
      case "text":
        return text4.push(k.value || "");
      case "strong":
      case "emphasis":
        const format = { strong: "bold", em: "italic", code: "code" };
        extraProps[format[k.type]] = true;
        return k.children.forEach((item) => {
          text4.push(item.value);
        });
      default:
        throw new Error(`Not sure, this should be flattened to the same node`);
    }
  });
  return __spreadValues({
    type: "text",
    text: text4.join("")
  }, extraProps);
};
function persistLeafFormats(children) {
  return children.reduce((acc, node) => {
    Object.keys(node).forEach(function(key2) {
      if (key2 === "children" || key2 === "type" || key2 === "text")
        return;
      acc[key2] = node[key2];
    });
    return acc;
  }, {});
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/zwitch-npm-2.0.2-a4cf7ec6e3-b2db5e06e4.zip/node_modules/zwitch/index.js
var own5 = {}.hasOwnProperty;
function zwitch(key2, options) {
  var settings = options || {};
  function one2(value) {
    var fn = one2.invalid;
    var handlers = one2.handlers;
    if (value && own5.call(value, key2)) {
      fn = own5.call(handlers, value[key2]) ? handlers[value[key2]] : one2.unknown;
    }
    if (fn) {
      return fn.apply(this, arguments);
    }
  }
  one2.handlers = settings.handlers || {};
  one2.invalid = settings.invalid;
  one2.unknown = settings.unknown;
  return one2;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/configure.js
function configure2(base2, extension2) {
  let index2 = -1;
  let key2;
  if (extension2.extensions) {
    while (++index2 < extension2.extensions.length) {
      configure2(base2, extension2.extensions[index2]);
    }
  }
  for (key2 in extension2) {
    if (key2 === "extensions") {
    } else if (key2 === "unsafe" || key2 === "join") {
      base2[key2] = [...base2[key2] || [], ...extension2[key2] || []];
    } else if (key2 === "handlers") {
      base2[key2] = Object.assign(base2[key2], extension2[key2] || {});
    } else {
      base2.options[key2] = extension2[key2];
    }
  }
  return base2;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/container-flow.js
function containerFlow(parent, context) {
  const indexStack = context.indexStack;
  const children = parent.children || [];
  const results = [];
  let index2 = -1;
  indexStack.push(-1);
  while (++index2 < children.length) {
    const child = children[index2];
    indexStack[indexStack.length - 1] = index2;
    results.push(context.handle(child, parent, context, { before: "\n", after: "\n" }));
    if (child.type !== "list") {
      context.bulletLastUsed = void 0;
    }
    if (index2 < children.length - 1) {
      results.push(between(child, children[index2 + 1]));
    }
  }
  indexStack.pop();
  return results.join("");
  function between(left, right) {
    let index3 = context.join.length;
    while (index3--) {
      const result = context.join[index3](left, right, parent, context);
      if (result === true || result === 1) {
        break;
      }
      if (typeof result === "number") {
        return "\n".repeat(1 + result);
      }
      if (result === false) {
        return "\n\n<!---->\n\n";
      }
    }
    return "\n\n";
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
var eol = /\r?\n|\r/g;
function indentLines(value, map3) {
  const result = [];
  let start = 0;
  let line = 0;
  let match;
  while (match = eol.exec(value)) {
    one2(value.slice(start, match.index));
    result.push(match[0]);
    start = match.index + match[0].length;
    line++;
  }
  one2(value.slice(start));
  return result.join("");
  function one2(value2) {
    result.push(map3(value2, line, !value2));
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
function blockquote(node, _6, context) {
  const exit2 = context.enter("blockquote");
  const value = indentLines(containerFlow(node, context), map);
  exit2();
  return value;
}
function map(line, _6, blank) {
  return ">" + (blank ? "" : " ") + line;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list3, none) {
  if (!list3) {
    return none;
  }
  if (typeof list3 === "string") {
    list3 = [list3];
  }
  let index2 = -1;
  while (++index2 < list3.length) {
    if (stack.includes(list3[index2])) {
      return true;
    }
  }
  return false;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/break.js
function hardBreak(_6, _1, context, safe2) {
  let index2 = -1;
  while (++index2 < context.unsafe.length) {
    if (context.unsafe[index2].character === "\n" && patternInScope(context.stack, context.unsafe[index2])) {
      return /[ \t]/.test(safe2.before) ? "" : " ";
    }
  }
  return "\\\n";
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/longest-streak-npm-3.0.0-d72dc056b5-7fdd42f69a.zip/node_modules/longest-streak/index.js
function longestStreak(value, character) {
  var source = String(value);
  var index2 = source.indexOf(character);
  var expected = index2;
  var count = 0;
  var max = 0;
  if (typeof character !== "string" || character.length !== 1) {
    throw new Error("Expected character");
  }
  while (index2 !== -1) {
    if (index2 === expected) {
      if (++count > max) {
        max = count;
      }
    } else {
      count = 1;
    }
    expected = index2 + 1;
    index2 = source.indexOf(character, expected);
  }
  return max;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
function formatCodeAsIndented(node, context) {
  return Boolean(!context.options.fences && node.value && !node.lang && /[^ \r\n]/.test(node.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node.value));
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/check-fence.js
function checkFence(context) {
  const marker = context.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error("Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`");
  }
  return marker;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js
function patternCompile(pattern) {
  if (!pattern._compiled) {
    const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
    pattern._compiled = new RegExp((before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""), "g");
  }
  return pattern._compiled;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/safe.js
function safe(context, input, config) {
  const value = (config.before || "") + (input || "") + (config.after || "");
  const positions = [];
  const result = [];
  const infos = {};
  let index2 = -1;
  while (++index2 < context.unsafe.length) {
    const pattern = context.unsafe[index2];
    if (!patternInScope(context.stack, pattern)) {
      continue;
    }
    const expression = patternCompile(pattern);
    let match;
    while (match = expression.exec(value)) {
      const before = "before" in pattern || Boolean(pattern.atBreak);
      const after = "after" in pattern;
      const position2 = match.index + (before ? match[1].length : 0);
      if (positions.includes(position2)) {
        if (infos[position2].before && !before) {
          infos[position2].before = false;
        }
        if (infos[position2].after && !after) {
          infos[position2].after = false;
        }
      } else {
        positions.push(position2);
        infos[position2] = { before, after };
      }
    }
  }
  positions.sort(numerical);
  let start = config.before ? config.before.length : 0;
  const end = value.length - (config.after ? config.after.length : 0);
  index2 = -1;
  while (++index2 < positions.length) {
    const position2 = positions[index2];
    if (position2 < start || position2 >= end) {
      continue;
    }
    if (position2 + 1 < end && positions[index2 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after || positions[index2 - 1] === position2 - 1 && infos[position2].before && !infos[position2 - 1].before && !infos[position2 - 1].after) {
      continue;
    }
    if (start !== position2) {
      result.push(escapeBackslashes(value.slice(start, position2), "\\"));
    }
    start = position2;
    if (/[!-/:-@[-`{-~]/.test(value.charAt(position2)) && (!config.encode || !config.encode.includes(value.charAt(position2)))) {
      result.push("\\");
    } else {
      result.push("&#x" + value.charCodeAt(position2).toString(16).toUpperCase() + ";");
      start++;
    }
  }
  result.push(escapeBackslashes(value.slice(start, end), config.after));
  return result.join("");
}
function numerical(a, b) {
  return a - b;
}
function escapeBackslashes(value, after) {
  const expression = /\\(?=[!-/:-@[-`{-~])/g;
  const positions = [];
  const results = [];
  const whole = value + after;
  let index2 = -1;
  let start = 0;
  let match;
  while (match = expression.exec(whole)) {
    positions.push(match.index);
  }
  while (++index2 < positions.length) {
    if (start !== positions[index2]) {
      results.push(value.slice(start, positions[index2]));
    }
    results.push("\\");
    start = positions[index2];
  }
  results.push(value.slice(start));
  return results.join("");
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/code.js
function code(node, _6, context) {
  const marker = checkFence(context);
  const raw = node.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  let value;
  let exit2;
  if (formatCodeAsIndented(node, context)) {
    exit2 = context.enter("codeIndented");
    value = indentLines(raw, map2);
  } else {
    const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
    let subexit;
    exit2 = context.enter("codeFenced");
    value = sequence;
    if (node.lang) {
      subexit = context.enter("codeFencedLang" + suffix);
      value += safe(context, node.lang, {
        before: "`",
        after: " ",
        encode: ["`"]
      });
      subexit();
    }
    if (node.lang && node.meta) {
      subexit = context.enter("codeFencedMeta" + suffix);
      value += " " + safe(context, node.meta, {
        before: " ",
        after: "\n",
        encode: ["`"]
      });
      subexit();
    }
    value += "\n";
    if (raw) {
      value += raw + "\n";
    }
    value += sequence;
  }
  exit2();
  return value;
}
function map2(line, _6, blank) {
  return (blank ? "" : "    ") + line;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/association.js
function association(node) {
  if (node.label || !node.identifier) {
    return node.label || "";
  }
  return decodeString(node.identifier);
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/check-quote.js
function checkQuote(context) {
  const marker = context.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error("Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`");
  }
  return marker;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/definition.js
function definition2(node, _6, context) {
  const marker = checkQuote(context);
  const suffix = marker === '"' ? "Quote" : "Apostrophe";
  const exit2 = context.enter("definition");
  let subexit = context.enter("label");
  let value = "[" + safe(context, association(node), { before: "[", after: "]" }) + "]: ";
  subexit();
  if (!node.url || /[ \t\r\n]/.test(node.url)) {
    subexit = context.enter("destinationLiteral");
    value += "<" + safe(context, node.url, { before: "<", after: ">" }) + ">";
  } else {
    subexit = context.enter("destinationRaw");
    value += safe(context, node.url, { before: " ", after: " " });
  }
  subexit();
  if (node.title) {
    subexit = context.enter("title" + suffix);
    value += " " + marker + safe(context, node.title, { before: marker, after: marker }) + marker;
    subexit();
  }
  exit2();
  return value;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
function checkEmphasis(context) {
  const marker = context.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error("Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`");
  }
  return marker;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing(parent, context, safeOptions) {
  const indexStack = context.indexStack;
  const children = parent.children || [];
  const results = [];
  let index2 = -1;
  let before = safeOptions.before;
  indexStack.push(-1);
  while (++index2 < children.length) {
    const child = children[index2];
    let after;
    indexStack[indexStack.length - 1] = index2;
    if (index2 + 1 < children.length) {
      let handle2 = context.handle.handlers[children[index2 + 1].type];
      if (handle2 && handle2.peek)
        handle2 = handle2.peek;
      after = handle2 ? handle2(children[index2 + 1], parent, context, {
        before: "",
        after: ""
      }).charAt(0) : "";
    } else {
      after = safeOptions.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, " ");
      before = " ";
    }
    results.push(context.handle(child, parent, context, { before, after }));
    before = results[results.length - 1].slice(-1);
  }
  indexStack.pop();
  return results.join("");
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
emphasis.peek = emphasisPeek;
function emphasis(node, _6, context) {
  const marker = checkEmphasis(context);
  const exit2 = context.enter("emphasis");
  const value = containerPhrasing(node, context, {
    before: marker,
    after: marker
  });
  exit2();
  return marker + value + marker;
}
function emphasisPeek(_6, _1, context) {
  return context.options.emphasis || "*";
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
function formatHeadingAsSetext(node, context) {
  let literalWithBreak = false;
  visit(node, (node2) => {
    if ("value" in node2 && /\r?\n|\r/.test(node2.value) || node2.type === "break") {
      literalWithBreak = true;
      return EXIT;
    }
  });
  return Boolean((!node.depth || node.depth < 3) && toString(node) && (context.options.setext || literalWithBreak));
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/heading.js
function heading(node, _6, context) {
  const rank = Math.max(Math.min(6, node.depth || 1), 1);
  if (formatHeadingAsSetext(node, context)) {
    const exit3 = context.enter("headingSetext");
    const subexit2 = context.enter("phrasing");
    const value2 = containerPhrasing(node, context, { before: "\n", after: "\n" });
    subexit2();
    exit3();
    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(value2.length - (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1));
  }
  const sequence = "#".repeat(rank);
  const exit2 = context.enter("headingAtx");
  const subexit = context.enter("phrasing");
  let value = containerPhrasing(node, context, { before: "# ", after: "\n" });
  if (/^[\t ]/.test(value)) {
    value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (context.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit2();
  return value;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/html.js
html.peek = htmlPeek;
function html(node) {
  return node.value || "";
}
function htmlPeek() {
  return "<";
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/image.js
image.peek = imagePeek;
function image(node, _6, context) {
  const quote = checkQuote(context);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit2 = context.enter("image");
  let subexit = context.enter("label");
  let value = "![" + safe(context, node.alt, { before: "[", after: "]" }) + "](";
  subexit();
  if (!node.url && node.title || /[ \t\r\n]/.test(node.url)) {
    subexit = context.enter("destinationLiteral");
    value += "<" + safe(context, node.url, { before: "<", after: ">" }) + ">";
  } else {
    subexit = context.enter("destinationRaw");
    value += safe(context, node.url, {
      before: "(",
      after: node.title ? " " : ")"
    });
  }
  subexit();
  if (node.title) {
    subexit = context.enter("title" + suffix);
    value += " " + quote + safe(context, node.title, { before: quote, after: quote }) + quote;
    subexit();
  }
  value += ")";
  exit2();
  return value;
}
function imagePeek() {
  return "!";
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
imageReference.peek = imageReferencePeek;
function imageReference(node, _6, context) {
  const type = node.referenceType;
  const exit2 = context.enter("imageReference");
  let subexit = context.enter("label");
  const alt = safe(context, node.alt, { before: "[", after: "]" });
  let value = "![" + alt + "]";
  subexit();
  const stack = context.stack;
  context.stack = [];
  subexit = context.enter("reference");
  const reference = safe(context, association(node), { before: "[", after: "]" });
  subexit();
  context.stack = stack;
  exit2();
  if (type === "full" || !alt || alt !== reference) {
    value += "[" + reference + "]";
  } else if (type !== "shortcut") {
    value += "[]";
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
inlineCode.peek = inlineCodePeek;
function inlineCode(node, _6, context) {
  let value = node.value || "";
  let sequence = "`";
  let index2 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index2 < context.unsafe.length) {
    const pattern = context.unsafe[index2];
    const expression = patternCompile(pattern);
    let match;
    if (!pattern.atBreak)
      continue;
    while (match = expression.exec(value)) {
      let position2 = match.index;
      if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
        position2--;
      }
      value = value.slice(0, position2) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
function formatLinkAsAutolink(node, context) {
  const raw = toString(node);
  return Boolean(!context.options.resourceLink && node.url && !node.title && node.children && node.children.length === 1 && node.children[0].type === "text" && (raw === node.url || "mailto:" + raw === node.url) && /^[a-z][a-z+.-]+:/i.test(node.url) && !/[\0- <>\u007F]/.test(node.url));
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/link.js
link.peek = linkPeek;
function link(node, _6, context) {
  const quote = checkQuote(context);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  let exit2;
  let subexit;
  let value;
  if (formatLinkAsAutolink(node, context)) {
    const stack = context.stack;
    context.stack = [];
    exit2 = context.enter("autolink");
    value = "<" + containerPhrasing(node, context, { before: "<", after: ">" }) + ">";
    exit2();
    context.stack = stack;
    return value;
  }
  exit2 = context.enter("link");
  subexit = context.enter("label");
  value = "[" + containerPhrasing(node, context, { before: "[", after: "]" }) + "](";
  subexit();
  if (!node.url && node.title || /[ \t\r\n]/.test(node.url)) {
    subexit = context.enter("destinationLiteral");
    value += "<" + safe(context, node.url, { before: "<", after: ">" }) + ">";
  } else {
    subexit = context.enter("destinationRaw");
    value += safe(context, node.url, {
      before: "(",
      after: node.title ? " " : ")"
    });
  }
  subexit();
  if (node.title) {
    subexit = context.enter("title" + suffix);
    value += " " + quote + safe(context, node.title, { before: quote, after: quote }) + quote;
    subexit();
  }
  value += ")";
  exit2();
  return value;
}
function linkPeek(node, _6, context) {
  return formatLinkAsAutolink(node, context) ? "<" : "[";
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
linkReference.peek = linkReferencePeek;
function linkReference(node, _6, context) {
  const type = node.referenceType;
  const exit2 = context.enter("linkReference");
  let subexit = context.enter("label");
  const text4 = containerPhrasing(node, context, { before: "[", after: "]" });
  let value = "[" + text4 + "]";
  subexit();
  const stack = context.stack;
  context.stack = [];
  subexit = context.enter("reference");
  const reference = safe(context, association(node), { before: "[", after: "]" });
  subexit();
  context.stack = stack;
  exit2();
  if (type === "full" || !text4 || text4 !== reference) {
    value += "[" + reference + "]";
  } else if (type !== "shortcut") {
    value += "[]";
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
function checkBullet(context) {
  const marker = context.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error("Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`");
  }
  return marker;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
function checkBulletOther(context) {
  const bullet = checkBullet(context);
  const bulletOther = context.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error("Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`");
  }
  if (bulletOther === bullet) {
    throw new Error("Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different");
  }
  return bulletOther;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
function checkBulletOrdered(context) {
  const marker = context.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error("Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`");
  }
  return marker;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js
function checkBulletOrderedOther(context) {
  const bulletOrdered = checkBulletOrdered(context);
  const bulletOrderedOther = context.options.bulletOrderedOther;
  if (!bulletOrderedOther) {
    return bulletOrdered === "." ? ")" : ".";
  }
  if (bulletOrderedOther !== "." && bulletOrderedOther !== ")") {
    throw new Error("Cannot serialize items with `" + bulletOrderedOther + "` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`");
  }
  if (bulletOrderedOther === bulletOrdered) {
    throw new Error("Expected `bulletOrdered` (`" + bulletOrdered + "`) and `bulletOrderedOther` (`" + bulletOrderedOther + "`) to be different");
  }
  return bulletOrderedOther;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/check-rule.js
function checkRule(context) {
  const marker = context.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error("Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`");
  }
  return marker;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/list.js
function list2(node, parent, context) {
  const exit2 = context.enter("list");
  const bulletCurrent = context.bulletCurrent;
  let bullet = node.ordered ? checkBulletOrdered(context) : checkBullet(context);
  const bulletOther = node.ordered ? checkBulletOrderedOther(context) : checkBulletOther(context);
  const bulletLastUsed = context.bulletLastUsed;
  let useDifferentMarker = false;
  if (parent && (node.ordered ? context.options.bulletOrderedOther : context.options.bulletOther) && bulletLastUsed && bullet === bulletLastUsed) {
    useDifferentMarker = true;
  }
  if (!node.ordered) {
    const firstListItem = node.children ? node.children[0] : void 0;
    if ((bullet === "*" || bullet === "-") && firstListItem && (!firstListItem.children || !firstListItem.children[0]) && context.stack[context.stack.length - 1] === "list" && context.stack[context.stack.length - 2] === "listItem" && context.stack[context.stack.length - 3] === "list" && context.stack[context.stack.length - 4] === "listItem" && context.indexStack[context.indexStack.length - 1] === 0 && context.indexStack[context.indexStack.length - 2] === 0 && context.indexStack[context.indexStack.length - 3] === 0 && context.indexStack[context.indexStack.length - 4] === 0) {
      useDifferentMarker = true;
    }
    if (checkRule(context) === bullet && firstListItem) {
      let index2 = -1;
      while (++index2 < node.children.length) {
        const item = node.children[index2];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  context.bulletCurrent = bullet;
  const value = containerFlow(node, context);
  context.bulletLastUsed = bullet;
  context.bulletCurrent = bulletCurrent;
  exit2();
  return value;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
function checkListItemIndent(context) {
  const style = context.options.listItemIndent || "tab";
  if (style === 1 || style === "1") {
    return "one";
  }
  if (style !== "tab" && style !== "one" && style !== "mixed") {
    throw new Error("Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
  }
  return style;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/list-item.js
function listItem(node, parent, context) {
  const listItemIndent = checkListItemIndent(context);
  let bullet = context.bulletCurrent || checkBullet(context);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (context.options.incrementListMarker === false ? 0 : parent.children.indexOf(node)) + bullet;
  }
  let size = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node.spread)) {
    size = Math.ceil(size / 4) * 4;
  }
  const exit2 = context.enter("listItem");
  const value = indentLines(containerFlow(node, context), map3);
  exit2();
  return value;
  function map3(line, index2, blank) {
    if (index2) {
      return (blank ? "" : " ".repeat(size)) + line;
    }
    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
function paragraph(node, _6, context) {
  const exit2 = context.enter("paragraph");
  const subexit = context.enter("phrasing");
  const value = containerPhrasing(node, context, { before: "\n", after: "\n" });
  subexit();
  exit2();
  return value;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/root.js
function root(node, _6, context) {
  return containerFlow(node, context);
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/check-strong.js
function checkStrong(context) {
  const marker = context.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error("Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`");
  }
  return marker;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/strong.js
strong.peek = strongPeek;
function strong(node, _6, context) {
  const marker = checkStrong(context);
  const exit2 = context.enter("strong");
  const value = containerPhrasing(node, context, {
    before: marker,
    after: marker
  });
  exit2();
  return marker + marker + value + marker + marker;
}
function strongPeek(_6, _1, context) {
  return context.options.strong || "*";
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/text.js
function text3(node, _6, context, safeOptions) {
  return safe(context, node.value, safeOptions);
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
function checkRuleRepetition(context) {
  const repetition = context.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error("Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more");
  }
  return repetition;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
function thematicBreak2(_6, _1, context) {
  const value = (checkRule(context) + (context.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(context));
  return context.options.ruleSpaces ? value.slice(0, -1) : value;
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/handle/index.js
var handle = {
  blockquote,
  break: hardBreak,
  code,
  definition: definition2,
  emphasis,
  hardBreak,
  heading,
  html,
  image,
  imageReference,
  inlineCode,
  link,
  linkReference,
  list: list2,
  listItem,
  paragraph,
  root,
  strong,
  text: text3,
  thematicBreak: thematicBreak2
};

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/join.js
var join = [joinDefaults];
function joinDefaults(left, right, parent, context) {
  if (right.type === "code" && formatCodeAsIndented(right, context) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, context))) {
    return false;
  }
  if (left.type === "list" && left.type === right.type && Boolean(left.ordered) === Boolean(right.ordered) && !(left.ordered ? context.options.bulletOrderedOther : context.options.bulletOther)) {
    return false;
  }
  if ("spread" in parent && typeof parent.spread === "boolean") {
    if (left.type === "paragraph" && (left.type === right.type || right.type === "definition" || right.type === "heading" && formatHeadingAsSetext(right, context))) {
      return;
    }
    return parent.spread ? 1 : 0;
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/unsafe.js
var unsafe = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: "\n",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  { character: "!", after: "\\[", inConstruct: "phrasing" },
  { character: '"', inConstruct: "titleQuote" },
  { atBreak: true, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  { character: "'", inConstruct: "titleApostrophe" },
  { character: "(", inConstruct: "destinationRaw" },
  { before: "\\]", character: "(", inConstruct: "phrasing" },
  { atBreak: true, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  { atBreak: true, character: "*" },
  { character: "*", inConstruct: "phrasing" },
  { atBreak: true, character: "+" },
  { atBreak: true, character: "-" },
  { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
  { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
  { character: "<", after: "[!/?A-Za-z]", inConstruct: "phrasing" },
  { character: "<", inConstruct: "destinationLiteral" },
  { atBreak: true, character: "=" },
  { atBreak: true, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  { atBreak: true, character: "[" },
  { character: "[", inConstruct: ["phrasing", "label", "reference"] },
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "]", inConstruct: ["label", "reference"] },
  { atBreak: true, character: "_" },
  { character: "_", inConstruct: "phrasing" },
  { atBreak: true, character: "`" },
  {
    character: "`",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedMetaGraveAccent",
      "phrasing"
    ]
  },
  { atBreak: true, character: "~" }
];

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-to-markdown-npm-1.2.3-e27fe7fcf9-d50b5c4a9f.zip/node_modules/mdast-util-to-markdown/lib/index.js
function toMarkdown(tree, options = {}) {
  const context = {
    enter,
    stack: [],
    unsafe: [],
    join: [],
    handlers: {},
    options: {},
    indexStack: []
  };
  configure2(context, { unsafe, join, handlers: handle });
  configure2(context, options);
  if (context.options.tightDefinitions) {
    configure2(context, { join: [joinDefinition] });
  }
  context.handle = zwitch("type", {
    invalid,
    unknown,
    handlers: context.handlers
  });
  let result = context.handle(tree, null, context, { before: "\n", after: "\n" });
  if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
    result += "\n";
  }
  return result;
  function enter(name2) {
    context.stack.push(name2);
    return exit2;
    function exit2() {
      context.stack.pop();
    }
  }
}
function invalid(value) {
  throw new Error("Cannot handle value `" + value + "`, expected node");
}
function unknown(node) {
  throw new Error("Cannot handle unknown node `" + node.type + "`");
}
function joinDefinition(left, right) {
  if (left.type === "definition" && left.type === right.type) {
    return 0;
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-expression-npm-1.1.1-7e7ac0a51f-9e84a57a50.zip/node_modules/mdast-util-mdx-expression/index.js
var mdxExpressionToMarkdown = {
  handlers: {
    mdxFlowExpression: handleMdxExpression,
    mdxTextExpression: handleMdxExpression
  },
  unsafe: [
    { character: "{", inConstruct: ["phrasing"] },
    { atBreak: true, character: "{" }
  ]
};
function handleMdxExpression(node) {
  const value = node.value || "";
  return "{" + value + "}";
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/parse-entities-npm-3.0.0-da12de3a6f-0a37ebb3e4.zip/node_modules/parse-entities/index.js
var own6 = {}.hasOwnProperty;
var fromCharCode = String.fromCharCode;

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-4.0.1-3b61aeac68-f2cdeba8de.zip/node_modules/stringify-entities/lib/core.js
function core(value, options) {
  value = value.replace(options.subset ? charactersToExpression(options.subset) : /["&'<>`]/g, basic);
  if (options.subset || options.escapeOnly) {
    return value;
  }
  return value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(/[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g, basic);
  function surrogate(pair, index2, all2) {
    return options.format((pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536, all2.charCodeAt(index2 + 2), options);
  }
  function basic(character, index2, all2) {
    return options.format(character.charCodeAt(0), all2.charCodeAt(index2 + 1), options);
  }
}
function charactersToExpression(subset) {
  var groups = [];
  var index2 = -1;
  while (++index2 < subset.length) {
    groups.push(subset[index2].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/character-entities-html4-npm-2.0.0-7dd94897cd-79ce3a03b8.zip/node_modules/character-entities-html4/index.js
var characterEntitiesHtml4 = {
  nbsp: "\xA0",
  iexcl: "\xA1",
  cent: "\xA2",
  pound: "\xA3",
  curren: "\xA4",
  yen: "\xA5",
  brvbar: "\xA6",
  sect: "\xA7",
  uml: "\xA8",
  copy: "\xA9",
  ordf: "\xAA",
  laquo: "\xAB",
  not: "\xAC",
  shy: "\xAD",
  reg: "\xAE",
  macr: "\xAF",
  deg: "\xB0",
  plusmn: "\xB1",
  sup2: "\xB2",
  sup3: "\xB3",
  acute: "\xB4",
  micro: "\xB5",
  para: "\xB6",
  middot: "\xB7",
  cedil: "\xB8",
  sup1: "\xB9",
  ordm: "\xBA",
  raquo: "\xBB",
  frac14: "\xBC",
  frac12: "\xBD",
  frac34: "\xBE",
  iquest: "\xBF",
  Agrave: "\xC0",
  Aacute: "\xC1",
  Acirc: "\xC2",
  Atilde: "\xC3",
  Auml: "\xC4",
  Aring: "\xC5",
  AElig: "\xC6",
  Ccedil: "\xC7",
  Egrave: "\xC8",
  Eacute: "\xC9",
  Ecirc: "\xCA",
  Euml: "\xCB",
  Igrave: "\xCC",
  Iacute: "\xCD",
  Icirc: "\xCE",
  Iuml: "\xCF",
  ETH: "\xD0",
  Ntilde: "\xD1",
  Ograve: "\xD2",
  Oacute: "\xD3",
  Ocirc: "\xD4",
  Otilde: "\xD5",
  Ouml: "\xD6",
  times: "\xD7",
  Oslash: "\xD8",
  Ugrave: "\xD9",
  Uacute: "\xDA",
  Ucirc: "\xDB",
  Uuml: "\xDC",
  Yacute: "\xDD",
  THORN: "\xDE",
  szlig: "\xDF",
  agrave: "\xE0",
  aacute: "\xE1",
  acirc: "\xE2",
  atilde: "\xE3",
  auml: "\xE4",
  aring: "\xE5",
  aelig: "\xE6",
  ccedil: "\xE7",
  egrave: "\xE8",
  eacute: "\xE9",
  ecirc: "\xEA",
  euml: "\xEB",
  igrave: "\xEC",
  iacute: "\xED",
  icirc: "\xEE",
  iuml: "\xEF",
  eth: "\xF0",
  ntilde: "\xF1",
  ograve: "\xF2",
  oacute: "\xF3",
  ocirc: "\xF4",
  otilde: "\xF5",
  ouml: "\xF6",
  divide: "\xF7",
  oslash: "\xF8",
  ugrave: "\xF9",
  uacute: "\xFA",
  ucirc: "\xFB",
  uuml: "\xFC",
  yacute: "\xFD",
  thorn: "\xFE",
  yuml: "\xFF",
  fnof: "\u0192",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  bull: "\u2022",
  hellip: "\u2026",
  prime: "\u2032",
  Prime: "\u2033",
  oline: "\u203E",
  frasl: "\u2044",
  weierp: "\u2118",
  image: "\u2111",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  int: "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  circ: "\u02C6",
  tilde: "\u02DC",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  permil: "\u2030",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  euro: "\u20AC"
};

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-4.0.1-3b61aeac68-f2cdeba8de.zip/node_modules/stringify-entities/lib/constant/characters.js
var characters = {};
var own7 = {}.hasOwnProperty;
var key;
for (key in characterEntitiesHtml4) {
  if (own7.call(characterEntitiesHtml4, key)) {
    characters[characterEntitiesHtml4[key]] = key;
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-4.0.1-3b61aeac68-f2cdeba8de.zip/node_modules/stringify-entities/lib/util/to-named.js
var own8 = {}.hasOwnProperty;

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-4.0.1-3b61aeac68-f2cdeba8de.zip/node_modules/stringify-entities/lib/util/format-basic.js
function formatBasic(code2) {
  return "&#x" + code2.toString(16).toUpperCase() + ";";
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/stringify-entities-npm-4.0.1-3b61aeac68-f2cdeba8de.zip/node_modules/stringify-entities/lib/index.js
function stringifyEntitiesLight(value, options) {
  return core(value, Object.assign({ format: formatBasic }, options));
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-jsx-npm-1.1.1-219bb4c262-5c285f3502.zip/node_modules/mdast-util-mdx-jsx/index.js
mdxElement.peek = peekElement;
var mdxJsxToMarkdown = {
  handlers: {
    mdxJsxFlowElement: mdxElement,
    mdxJsxTextElement: mdxElement
  },
  unsafe: [
    { character: "<", inConstruct: ["phrasing"] },
    { atBreak: true, character: "<" }
  ],
  fences: true,
  resourceLink: true
};
function mdxElement(node, _6, context) {
  const selfClosing = node.name && (!node.children || node.children.length === 0);
  const quote = checkQuote(context);
  const exit2 = context.enter(node.type);
  let attributeValue = "";
  let index2 = -1;
  const attributes = [];
  let result;
  if (node.attributes && node.attributes.length > 0) {
    if (!node.name) {
      throw new Error("Cannot serialize fragment w/ attributes");
    }
    const isMultiFlow = node.type === "mdxJsxFlowElement" && node.attributes.length > 1;
    while (++index2 < node.attributes.length) {
      const attribute = node.attributes[index2];
      if (attribute.type === "mdxJsxExpressionAttribute") {
        result = "{" + (attribute.value || "") + "}";
      } else {
        if (!attribute.name) {
          throw new Error("Cannot serialize attribute w/o name");
        }
        result = attribute.name + (attribute.value === void 0 || attribute.value === null ? "" : "=" + (typeof attribute.value === "object" ? "{" + (attribute.value.value || "") + "}" : quote + stringifyEntitiesLight(attribute.value, { subset: [quote] }) + quote));
      }
      attributes.push((isMultiFlow ? "\n  " : " ") + result);
    }
    attributeValue = attributes.join("") + (isMultiFlow ? "\n" : "");
  }
  const value = "<" + (node.name || "") + attributeValue + (selfClosing ? "/" : "") + ">" + (node.children && node.children.length > 0 ? node.type === "mdxJsxFlowElement" ? "\n" + indent(containerFlow(node, context)) + "\n" : containerPhrasing(node, context, { before: "<", after: ">" }) : "") + (selfClosing ? "" : "</" + (node.name || "") + ">");
  exit2();
  return value;
}
function peekElement() {
  return "<";
}
function indent(value) {
  return indentLines(value, map3);
  function map3(line, _6, blank) {
    return (blank ? "" : "  ") + line;
  }
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdxjs-esm-npm-1.1.1-0d006d7b38-618ab33144.zip/node_modules/mdast-util-mdxjs-esm/index.js
var mdxjsEsmToMarkdown = { handlers: { mdxjsEsm: handleMdxjsEsm } };
function handleMdxjsEsm(node) {
  return node.value || "";
}

// pnp:/Users/jeffsee/code/tinacms/.yarn/cache/mdast-util-mdx-npm-1.1.0-e1140be51f-bcf7eed04f.zip/node_modules/mdast-util-mdx/index.js
var mdxToMarkdown = {
  extensions: [mdxExpressionToMarkdown, mdxJsxToMarkdown, mdxjsEsmToMarkdown]
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/mdx/stringify.ts
var stringifyMDX = (value, field) => {
  const slateTree = value.children;
  try {
    const tree = stringifyChildren(slateTree, field);
    const out = toMarkdown({
      type: "root",
      children: tree
    }, {
      extensions: [mdxToMarkdown]
    });
    return out.replace(/&#x22;/g, `"`);
  } catch (e) {
    console.log(e);
  }
};
var allChildrenEmpty = (children) => {
  if (children.every((child) => child.type === "text" && !child.value)) {
    return true;
  }
  return false;
};
var stringifyChildren = (children, field) => {
  return children.map((child) => stringify(child, field)).filter(Boolean);
};
var stringify = (node, field) => {
  var _a;
  if (!node.type) {
    if (node == null ? void 0 : node.code) {
      return {
        type: "inlineCode",
        value: node.text
      };
    }
    let returnNode = { type: "text", value: node.text || "" };
    if (node == null ? void 0 : node.bold) {
      returnNode = { type: "strong", children: [returnNode] };
    }
    if (node == null ? void 0 : node.italic) {
      returnNode = {
        type: "emphasis",
        children: [returnNode]
      };
    }
    return returnNode;
  }
  switch (node.type) {
    case plateElements.ELEMENT_H1:
      return {
        type: "heading",
        depth: 1,
        children: stringifyChildren(node.children, field)
      };
    case plateElements.ELEMENT_H2:
      return {
        type: "heading",
        depth: 2,
        children: stringifyChildren(node.children, field)
      };
    case plateElements.ELEMENT_H3:
      return {
        type: "heading",
        depth: 3,
        children: stringifyChildren(node.children, field)
      };
    case plateElements.ELEMENT_H4:
      return {
        type: "heading",
        depth: 4,
        children: stringifyChildren(node.children, field)
      };
    case plateElements.ELEMENT_H5:
      return {
        type: "heading",
        depth: 5,
        children: stringifyChildren(node.children, field)
      };
    case plateElements.ELEMENT_H6:
      return {
        type: "heading",
        depth: 6,
        children: stringifyChildren(node.children, field)
      };
    case plateElements.ELEMENT_PARAGRAPH:
      const children = stringifyChildren(node.children, field);
      if (allChildrenEmpty(children)) {
        return false;
      }
      return {
        type: "paragraph",
        children
      };
    case plateElements.ELEMENT_CODE_BLOCK:
      return {
        type: "code",
        lang: node.lang,
        value: node.children.map((child) => child.children[0].text).join("\n")
      };
    case plateElements.ELEMENT_UL:
      return {
        type: "list",
        ordered: false,
        spread: false,
        check: null,
        children: stringifyChildren(node.children, field)
      };
    case plateElements.ELEMENT_OL:
      return {
        type: "list",
        ordered: true,
        spread: false,
        check: null,
        children: stringifyChildren(node.children, field)
      };
    case plateElements.ELEMENT_LI:
      const realChildren = [];
      const extraChildren = [];
      node.children.forEach((child) => {
        child.children.forEach((c) => {
          if (c.type === "li") {
            extraChildren.push(c);
          } else {
            realChildren.push(c);
          }
        });
      });
      const p = {
        type: "p",
        children: realChildren
      };
      return {
        type: "listItem",
        spread: false,
        check: null,
        children: [
          stringify(p, field),
          ...stringifyChildren(extraChildren, field)
        ]
      };
    case plateElements.ELEMENT_LIC:
      return {
        type: "paragraph",
        children: stringifyChildren(node.children, field)
      };
    case plateElements.ELEMENT_IMAGE:
      return {
        type: "image",
        title: node.caption,
        alt: node.alt,
        url: node.url
      };
    case plateElements.ELEMENT_HR:
      return {
        type: "thematicBreak"
      };
    case plateElements.ELEMENT_LINK:
      return {
        type: "link",
        url: node.url,
        children: node.children.map((child) => stringify(child, field))
      };
    case plateElements.ELEMENT_BLOCKQUOTE:
      return {
        type: "blockquote",
        children: node.children.map((child) => stringify(child, field))
      };
    case "mdxJsxTextElement":
    case "mdxJsxFlowElement":
      try {
        let children2 = [];
        const atts = [];
        const template = (_a = field.templates) == null ? void 0 : _a.find((fieldTemplate) => {
          if (typeof fieldTemplate === "string") {
            throw new Error(`Global templates not yet supported`);
          } else {
            return fieldTemplate.name === node.name;
          }
        });
        if (typeof template === "string") {
          throw new Error(`Global templates not yet supported`);
        }
        Object.entries(node.props).map(([key2, value]) => {
          if (template.fields) {
            const field2 = template.fields.find((field3) => field3.name === key2);
            if (!field2) {
              throw new Error(`Unknown field for key ${key2}`);
            }
            switch (field2.type) {
              case "boolean":
              case "datetime":
              case "image":
              case "number":
              case "string":
                if (field2.list) {
                  const v = {
                    type: "mdxJsxAttributeValueExpression",
                    value: `[${value.map((item) => {
                      switch (field2.type) {
                        case "boolean":
                        case "number":
                          return `${item}`;
                        case "image":
                        case "datetime":
                        case "string":
                          return `"${item}"`;
                      }
                    })}]`
                  };
                  atts.push({ type: "mdxJsxAttribute", name: key2, value: v });
                } else {
                  atts.push({
                    type: "mdxJsxAttribute",
                    name: key2,
                    value: `${value}`
                  });
                }
                break;
              case "object":
                if (field2.list) {
                  const values = [];
                  value.forEach((item) => {
                    if (field2.fields) {
                      const innerValue = {};
                      if (typeof field2.fields === "string") {
                        throw new Error(`Global templates not yet supported for rich text`);
                      }
                      field2.fields.forEach((innerField) => {
                        const fieldValue = item[innerField.name];
                        if (fieldValue) {
                          switch (innerField.type) {
                            case "boolean":
                            case "number":
                              innerValue[innerField.name] = `${fieldValue}`;
                              break;
                            case "image":
                            case "datetime":
                            case "string":
                              innerValue[innerField.name] = `"${fieldValue}"`;
                              break;
                          }
                        }
                      });
                      if (Object.entries(innerValue).length > 0) {
                        values.push(innerValue);
                      }
                    } else {
                      value.forEach((item2) => {
                        const template2 = field2.templates.find((template3) => {
                          const templateName = typeof template3 === "string" ? template3 : template3.name;
                          return templateName === item2._template;
                        });
                        if (typeof template2 === "string") {
                          throw new Error(`Global templates not yet supported for rich text`);
                        }
                        if (!template2) {
                          throw new Error(`Unable to find template for field ${field2.name}`);
                        }
                        const v = {};
                        template2.fields.forEach((field3) => {
                          const fieldValue = item2[field3.name];
                          if (fieldValue) {
                            switch (field3.type) {
                              case "boolean":
                              case "number":
                                v[field3.name] = `${fieldValue}`;
                                break;
                              case "image":
                              case "datetime":
                              case "string":
                                v[field3.name] = `"${fieldValue}"`;
                                break;
                            }
                            v["_template"] = `"${template2.name}"`;
                          }
                        });
                        values.push(v);
                      });
                    }
                  });
                  if (values.length > 0) {
                    const ast = {
                      type: "mdxJsxAttributeValueExpression",
                      name: key2,
                      value: {
                        value: `[${values.map((item) => {
                          return `{${Object.entries(item).map(([key3, value2]) => {
                            return `${key3}: ${value2}`;
                          }).join(", ")}}`;
                        }).join(", ")}]`
                      }
                    };
                    atts.push(__spreadValues({ name: key2 }, ast));
                  }
                } else {
                  if (field2.fields) {
                    const v = {};
                    if (typeof field2.fields === "string") {
                      throw new Error(`Global templates not yet supported for rich text`);
                    }
                    field2.fields.forEach((field3) => {
                      const fieldValue = value[field3.name];
                      switch (field3.type) {
                        case "boolean":
                        case "number":
                          v[field3.name] = `${fieldValue}`;
                          break;
                        case "image":
                        case "datetime":
                        case "string":
                          v[field3.name] = `"${fieldValue}"`;
                          break;
                      }
                    });
                    const ast = {
                      type: "mdxJsxAttributeValueExpression",
                      name: key2,
                      value: {
                        value: `{${Object.entries(v).map(([key3, value2]) => {
                          return `${key3}: ${value2}`;
                        }).join(", ")}}`
                      }
                    };
                    atts.push(__spreadValues({ name: key2 }, ast));
                  } else {
                    throw new Error("Templates not yet");
                  }
                }
                break;
              case "rich-text":
                const tree = value.children.map((item) => stringify(item, field2)).filter((item) => {
                  if (item.type === "text" && !item.text) {
                    return false;
                  }
                  return true;
                });
                if (field2.name === "children") {
                  children2 = tree;
                } else {
                  const out = toMarkdown({
                    type: "root",
                    children: tree
                  }, { extensions: [mdxToMarkdown] });
                  if (out) {
                    atts.push({
                      type: "mdxJsxAttribute",
                      name: key2,
                      value: {
                        value: `
<>
${out}
</>
`
                      }
                    });
                  }
                }
                break;
              default:
                atts.push({
                  type: "mdxJsxAttribute",
                  name: key2,
                  value: "not yet"
                });
                break;
            }
          } else {
            throw new Error(`Templates not yet supported`);
          }
        });
        return __spreadProps(__spreadValues({}, node), {
          children: children2,
          attributes: atts
        });
      } catch (e) {
        console.log(e);
      }
    case "text":
      if (node == null ? void 0 : node.code) {
        return {
          type: "inlineCode",
          value: node.text
        };
      }
      let returnNode = { type: "text", value: node.text || "" };
      if (node == null ? void 0 : node.bold) {
        returnNode = { type: "strong", children: [returnNode] };
      }
      if (node == null ? void 0 : node.italic) {
        returnNode = {
          type: "emphasis",
          children: [returnNode]
        };
      }
      return returnNode;
    default:
      console.log(`Unrecognized field type: ${node.type}`);
      break;
  }
  return { type: "text", value: "" };
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/resolver/index.ts
var import_flat = __toModule(require("flat"));
var createResolver2 = (args) => {
  return new Resolver(args);
};
var Resolver = class {
  constructor(init) {
    this.init = init;
    this.resolveCollection = async (collectionName) => {
      const collection = this.tinaSchema.getCollection(collectionName);
      const extraFields = {};
      const documents = await this.getDocumentsForCollection(collectionName);
      return __spreadValues(__spreadValues({
        documents
      }, collection), extraFields);
    };
    this.getDocument = async (fullPath) => {
      if (typeof fullPath !== "string") {
        throw new Error(`fullPath must be of type string for getDocument request`);
      }
      const rawData = await this.database.get(fullPath);
      const collection = this.tinaSchema.getCollection(rawData._collection);
      try {
        const template = await this.tinaSchema.getTemplateForData({
          data: rawData,
          collection
        });
        const basename = import_path3.default.basename(fullPath);
        const extension2 = import_path3.default.extname(fullPath);
        const filename = basename.replace(extension2, "");
        const relativePath = fullPath.replace("\\", "/").replace(collection.path, "").replace(/^\/|\/$/g, "");
        const breadcrumbs = filename.split("/");
        const form = {
          label: collection.label,
          name: basename,
          fields: await sequential(template.fields, async (field) => {
            return this.resolveField(field);
          })
        };
        const data = {
          _collection: rawData._collection,
          _template: rawData._template
        };
        await sequential(template.fields, async (field) => this.resolveFieldData(field, rawData, data));
        return {
          __typename: NAMER.documentTypeName([rawData._collection]),
          id: fullPath,
          sys: {
            basename,
            filename,
            extension: extension2,
            path: fullPath,
            relativePath,
            breadcrumbs,
            collection,
            template: lastItem(template.namespace)
          },
          data,
          values: data,
          dataJSON: data,
          form
        };
      } catch (e) {
        if (e instanceof TinaError) {
          throw new TinaError(e.message, __spreadValues({
            requestedDocument: fullPath
          }, e.extensions));
        }
        throw e;
      }
    };
    this.getDocumentFields = async () => {
      try {
        const response = {};
        const collections = await this.tinaSchema.getCollections();
        await sequential(collections, async (collection) => {
          const collectable = this.tinaSchema.getTemplatesForCollectable(collection);
          switch (collectable.type) {
            case "object":
              response[collection.name] = {
                collection,
                fields: await sequential(collectable.template.fields, async (field) => {
                  return this.resolveField(field);
                }),
                mutationInfo: {
                  includeCollection: true,
                  includeTemplate: false
                }
              };
              break;
            case "union":
              const templates = {};
              await sequential(collectable.templates, async (template) => {
                templates[lastItem(template.namespace)] = {
                  template,
                  fields: await sequential(template.fields, async (field) => {
                    return this.resolveField(field);
                  })
                };
              });
              response[collection.name] = {
                collection,
                templates,
                mutationInfo: { includeCollection: true, includeTemplate: true }
              };
              break;
          }
        });
        return response;
      } catch (e) {
        throw e;
      }
    };
    this.buildObjectMutations = (fieldValue, field) => {
      if (field.fields) {
        const objectTemplate = typeof field.fields === "string" ? this.tinaSchema.getGlobalTemplate(field.fields) : field;
        if (Array.isArray(fieldValue)) {
          return fieldValue.map((item) => this.buildFieldMutations(item, objectTemplate));
        } else {
          return this.buildFieldMutations(fieldValue, objectTemplate);
        }
      }
      if (field.templates) {
        if (Array.isArray(fieldValue)) {
          return fieldValue.map((item) => {
            if (typeof item === "string") {
              throw new Error(`Expected object for template value for field ${field.name}`);
            }
            const templates = field.templates.map((templateOrTemplateName) => {
              if (typeof templateOrTemplateName === "string") {
                return this.tinaSchema.getGlobalTemplate(templateOrTemplateName);
              }
              return templateOrTemplateName;
            });
            const [templateName] = Object.entries(item)[0];
            const template = templates.find((template2) => template2.name === templateName);
            if (!template) {
              throw new Error(`Expected to find template ${templateName}`);
            }
            return __spreadProps(__spreadValues({}, this.buildFieldMutations(item[template.name], template)), {
              _template: template.name
            });
          });
        } else {
          if (typeof fieldValue === "string") {
            throw new Error(`Expected object for template value for field ${field.name}`);
          }
          const templates = field.templates.map((templateOrTemplateName) => {
            if (typeof templateOrTemplateName === "string") {
              return this.tinaSchema.getGlobalTemplate(templateOrTemplateName);
            }
            return templateOrTemplateName;
          });
          const [templateName] = Object.entries(fieldValue)[0];
          const template = templates.find((template2) => template2.name === templateName);
          if (!template) {
            throw new Error(`Expected to find template ${templateName}`);
          }
          return __spreadProps(__spreadValues({}, this.buildFieldMutations(fieldValue[template.name], template)), {
            _template: template.name
          });
        }
      }
    };
    this.createResolveDocument = async ({
      collection,
      realPath,
      args,
      isAddPendingDocument
    }) => {
      if (isAddPendingDocument === true) {
        const templateInfo = this.tinaSchema.getTemplatesForCollectable(collection);
        switch (templateInfo.type) {
          case "object":
            await this.database.addPendingDocument(realPath, {});
            break;
          case "union":
            const templateString = args.template;
            const template = templateInfo.templates.find((template2) => lastItem(template2.namespace) === templateString);
            if (!args.template) {
              throw new Error(`Must specify a template when creating content for a collection with multiple templates. Possible templates are: ${templateInfo.templates.map((t) => lastItem(t.namespace)).join(" ")}`);
            }
            if (!template) {
              throw new Error(`Expected to find template named ${templateString} in collection "${collection.name}" but none was found. Possible templates are: ${templateInfo.templates.map((t) => lastItem(t.namespace)).join(" ")}`);
            }
            await this.database.addPendingDocument(realPath, {
              _template: lastItem(template.namespace)
            });
        }
        return this.getDocument(realPath);
      }
      const params = this.buildObjectMutations(args.params[collection.name], collection);
      await this.database.put(realPath, params);
      return this.getDocument(realPath);
    };
    this.updateResolveDocument = async ({
      collection,
      realPath,
      args,
      isAddPendingDocument,
      isCollectionSpecific
    }) => {
      if (isAddPendingDocument === true) {
        const templateInfo = this.tinaSchema.getTemplatesForCollectable(collection);
        const params2 = this.buildParams(args);
        switch (templateInfo.type) {
          case "object":
            if (params2) {
              const values = this.buildFieldMutations(params2, templateInfo.template);
              await this.database.put(realPath, values);
            }
            break;
          case "union":
            await sequential(templateInfo.templates, async (template) => {
              const templateParams = params2[lastItem(template.namespace)];
              if (templateParams) {
                if (typeof templateParams === "string") {
                  throw new Error(`Expected to find an object for template params, but got string`);
                }
                const values = __spreadProps(__spreadValues({}, this.buildFieldMutations(templateParams, template)), {
                  _template: lastItem(template.namespace)
                });
                await this.database.put(realPath, values);
              }
            });
        }
        return this.getDocument(realPath);
      }
      const params = this.buildObjectMutations(isCollectionSpecific ? args.params : args.params[collection.name], collection);
      await this.database.put(realPath, params);
      return this.getDocument(realPath);
    };
    this.resolveDocument = async ({
      args,
      collection: collectionName,
      isMutation,
      isCreation,
      isAddPendingDocument,
      isCollectionSpecific
    }) => {
      let collectionLookup = collectionName || void 0;
      if (!collectionLookup && isCollectionSpecific === false) {
        collectionLookup = Object.keys(args.params)[0];
      }
      const collectionNames = this.tinaSchema.getCollections().map((item) => item.name);
      assertShape(collectionLookup, (yup3) => {
        return yup3.mixed().oneOf(collectionNames);
      }, `"collection" must be one of: [${collectionNames.join(", ")}] but got ${collectionLookup}`);
      assertShape(args, (yup3) => yup3.object({ relativePath: yup3.string().required() }));
      const collection = await this.tinaSchema.getCollection(collectionLookup);
      const realPath = import_path3.default.join(collection == null ? void 0 : collection.path, args.relativePath);
      const alreadyExists = await this.database.documentExists(realPath);
      if (isMutation) {
        if (isCreation) {
          if (alreadyExists === true) {
            throw new Error(`Unable to add document, ${realPath} already exists`);
          }
          return this.createResolveDocument({
            collection,
            realPath,
            args,
            isAddPendingDocument
          });
        }
        if (alreadyExists === false) {
          throw new Error(`Unable to update document, ${realPath} does not exist`);
        }
        return this.updateResolveDocument({
          collection,
          realPath,
          args,
          isAddPendingDocument,
          isCollectionSpecific
        });
      } else {
        return this.getDocument(realPath);
      }
    };
    this.resolveCollectionConnections = async ({ ids }) => {
      return {
        totalCount: ids.length,
        edges: await sequential(ids, async (filepath) => {
          const document3 = await this.getDocument(filepath);
          return {
            node: document3
          };
        })
      };
    };
    this.getDocumentsForCollection = async (collectionName) => {
      const collection = this.tinaSchema.getCollection(collectionName);
      return this.database.store.glob(collection.path, this.getDocument);
    };
    this.resolveCollectionConnection = async ({
      args,
      lookup
    }) => {
      let documents;
      if (args.filter) {
        const queries = [];
        const flattenedArgs = (0, import_flat.default)(args.filter, { delimiter: "#" });
        Object.entries(flattenedArgs).map(([key2, value]) => {
          const keys2 = key2.split("#");
          const maybeTemplateName = keys2[0];
          const realKey = keys2.slice(0, keys2.length - 1).join("#");
          const collection = this.tinaSchema.getCollection(lookup.collection);
          let templateName = collection.name;
          if (collection.templates) {
            const template = collection.templates.find((template2) => {
              if (typeof template2 === "string") {
                throw new Error("Global templates not yet supported for queries");
              }
              return template2.name === maybeTemplateName;
            });
            if (typeof template === "string") {
              throw new Error("Global templates not yet supported for queries");
            }
            if (template) {
              templateName = template.name;
            }
          }
          queries.push(`__attribute__${lookup.collection}#${templateName}#${realKey}#${value}`);
        });
        documents = await this.database.query(queries, this.getDocument);
      } else {
        const collection = await this.tinaSchema.getCollection(lookup.collection);
        documents = await this.database.store.glob(collection.path, this.getDocument);
      }
      return {
        totalCount: documents.length,
        edges: documents.map((document3) => {
          return { node: document3 };
        })
      };
    };
    this.buildFieldMutations = (fieldParams, template) => {
      const accum = {};
      Object.entries(fieldParams).forEach(([fieldName, fieldValue]) => {
        if (Array.isArray(fieldValue)) {
          if (fieldValue.length === 0) {
            return;
          }
        }
        const field = template.fields.find((field2) => field2.name === fieldName);
        if (!field) {
          throw new Error(`Expected to find field by name ${fieldName}`);
        }
        switch (field.type) {
          case "datetime":
            accum[fieldName] = resolveDateInput(fieldValue, field);
            break;
          case "string":
          case "boolean":
          case "number":
          case "image":
            accum[fieldName] = fieldValue;
            break;
          case "object":
            accum[fieldName] = this.buildObjectMutations(fieldValue, field);
            break;
          case "rich-text":
            field;
            accum[fieldName] = stringifyMDX(fieldValue, field);
            break;
          case "reference":
            accum[fieldName] = fieldValue;
            break;
          default:
            throw new Error(`No mutation builder for field type ${field.type}`);
        }
      });
      return accum;
    };
    this.resolveFieldData = async (_a, rawData, accumulator) => {
      var _b = _a, { namespace } = _b, field = __objRest(_b, ["namespace"]);
      if (!rawData) {
        return void 0;
      }
      assertShape(rawData, (yup3) => yup3.object());
      const value = rawData[field.name];
      switch (field.type) {
        case "datetime":
          if (value instanceof Date) {
            accumulator[field.name] = value.toISOString();
          } else {
            accumulator[field.name] = value;
          }
          break;
        case "string":
        case "boolean":
        case "number":
        case "reference":
        case "image":
          accumulator[field.name] = value;
          break;
        case "rich-text":
          const tree = parseMDX(value, field);
          accumulator[field.name] = tree;
          break;
        case "object":
          if (field.list) {
            if (!value) {
              return;
            }
            assertShape(value, (yup3) => yup3.array().of(yup3.object().required()));
            accumulator[field.name] = await sequential(value, async (item) => {
              const template = await this.tinaSchema.getTemplateForData({
                data: item,
                collection: __spreadValues({
                  namespace
                }, field)
              });
              const payload = {};
              await sequential(template.fields, async (field2) => {
                await this.resolveFieldData(field2, item, payload);
              });
              const isUnion = !!field.templates;
              return isUnion ? __spreadValues({
                _template: lastItem(template.namespace)
              }, payload) : payload;
            });
          } else {
            if (!value) {
              return;
            }
            const template = await this.tinaSchema.getTemplateForData({
              data: value,
              collection: __spreadValues({
                namespace
              }, field)
            });
            const payload = {};
            await sequential(template.fields, async (field2) => {
              await this.resolveFieldData(field2, value, payload);
            });
            const isUnion = !!field.templates;
            accumulator[field.name] = isUnion ? __spreadValues({
              _template: lastItem(template.namespace)
            }, payload) : payload;
          }
          break;
        default:
          return field;
      }
      return accumulator;
    };
    this.buildParams = (args) => {
      try {
        assertShape(args, (yup3) => yup3.object({
          collection: yup3.string().required(),
          params: yup3.object().required()
        }));
        return args.params[args.collection];
      } catch (e) {
      }
      assertShape(args, (yup3) => yup3.object({
        params: yup3.object().required()
      }));
      return args.params;
    };
    this.resolveField = async (_c) => {
      var _d = _c, {
        namespace
      } = _d, field = __objRest(_d, [
        "namespace"
      ]);
      const extraFields = field.ui || {};
      switch (field.type) {
        case "number":
          return __spreadValues(__spreadValues({
            component: "number"
          }, field), extraFields);
        case "datetime":
          return __spreadValues(__spreadValues({
            component: "date"
          }, field), extraFields);
        case "boolean":
          return __spreadValues(__spreadValues({
            component: "toggle"
          }, field), extraFields);
        case "image":
          return __spreadValues(__spreadValues({
            component: "image",
            clearable: true
          }, field), extraFields);
        case "string":
          if (field.options) {
            if (field.list) {
              return __spreadProps(__spreadValues(__spreadValues({
                component: "checkbox-group"
              }, field), extraFields), {
                options: field.options
              });
            }
            return __spreadProps(__spreadValues(__spreadValues({
              component: "select"
            }, field), extraFields), {
              options: field.required ? field.options : [{ label: `Choose an option`, value: "" }, ...field.options]
            });
          }
          if (field.list) {
            return __spreadValues(__spreadValues({
              component: "list",
              field: {
                component: "text"
              }
            }, field), extraFields);
          }
          return __spreadValues(__spreadValues({
            component: "text"
          }, field), extraFields);
        case "object":
          const templateInfo = this.tinaSchema.getTemplatesForCollectable(__spreadProps(__spreadValues({}, field), {
            namespace
          }));
          if (templateInfo.type === "object") {
            return __spreadValues(__spreadProps(__spreadValues({}, field), {
              component: field.list ? "group-list" : "group",
              fields: await sequential(templateInfo.template.fields, async (field2) => await this.resolveField(field2))
            }), extraFields);
          } else if (templateInfo.type === "union") {
            const templates2 = {};
            const typeMap2 = {};
            await sequential(templateInfo.templates, async (template) => {
              const extraFields2 = template.ui || {};
              const templateName = lastItem(template.namespace);
              typeMap2[templateName] = NAMER.dataTypeName(template.namespace);
              templates2[lastItem(template.namespace)] = __spreadValues({
                label: template.label || templateName,
                key: templateName,
                fields: await sequential(template.fields, async (field2) => await this.resolveField(field2))
              }, extraFields2);
              return true;
            });
            return __spreadValues(__spreadProps(__spreadValues({}, field), {
              typeMap: typeMap2,
              component: field.list ? "blocks" : "not-implemented",
              templates: templates2
            }), extraFields);
          } else {
            throw new Error(`Unknown object for resolveField function`);
          }
        case "rich-text":
          const templates = {};
          const typeMap = {};
          await sequential(field.templates, async (template) => {
            if (typeof template === "string") {
              throw new Error(`Global templates not yet supported for rich-text`);
            } else {
              const extraFields2 = template.ui || {};
              const templateName = lastItem(template.namespace);
              typeMap[templateName] = NAMER.dataTypeName(template.namespace);
              templates[lastItem(template.namespace)] = __spreadValues({
                label: template.label || templateName,
                key: templateName,
                inline: template.inline,
                name: templateName,
                fields: await sequential(template.fields, async (field2) => await this.resolveField(field2))
              }, extraFields2);
              return true;
            }
          });
          return __spreadValues(__spreadProps(__spreadValues({}, field), {
            templates: Object.values(templates),
            component: "rich-text"
          }), extraFields);
        case "reference":
          const documents = import_lodash5.default.flatten(await sequential(field.collections, async (collectionName) => {
            const collection = this.tinaSchema.getCollection(collectionName);
            return this.database.store.glob(collection.path);
          }));
          return __spreadValues(__spreadProps(__spreadValues({}, field), {
            component: "reference",
            options: [
              { label: "Choose an option", value: "" },
              ...documents.map((document3) => {
                return {
                  value: document3,
                  label: document3
                };
              })
            ]
          }), extraFields);
        default:
          throw new Error(`Unknown field type ${field.type}`);
      }
    };
    this.database = init.database;
    this.tinaSchema = init.tinaSchema;
  }
};
var resolveDateInput = (value) => {
  const date = new Date(value);
  if (!(0, import_isValid.default)(date)) {
    throw "Invalid Date";
  }
  return date.toISOString();
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/resolve.ts
var resolve = async ({
  query,
  variables,
  database,
  silenceErrors
}) => {
  try {
    const graphQLSchemaAst = await database.getGraphQLSchema();
    const graphQLSchema = (0, import_graphql3.buildASTSchema)(graphQLSchemaAst);
    const config = await database.getTinaSchema();
    const tinaSchema = await createSchema({ schema: config });
    const resolver2 = await createResolver2({ database, tinaSchema });
    const paths = [];
    const mutationPaths = [];
    const ast = (0, import_graphql3.parse)(query);
    const typeInfo = new import_graphql3.TypeInfo(graphQLSchema);
    const referencePathVisitor = () => {
      return {
        leave: {
          Field(node, key2, parent, path6, ancestors) {
            const type = typeInfo.getType();
            if (type) {
              const realType = (0, import_graphql3.getNamedType)(type);
              if (realType instanceof import_graphql3.GraphQLUnionType) {
                const hasNodeInterface = !!realType.getTypes().find((objectType) => objectType.getInterfaces().find((intfc) => intfc.name === "Node"));
                if (hasNodeInterface) {
                  const p = [];
                  ancestors.forEach((item, index2) => {
                    var _a;
                    const activePath = path6[index2];
                    const result = item[activePath];
                    if ((_a = result == null ? void 0 : result.name) == null ? void 0 : _a.value) {
                      if (result.kind === "Field") {
                        p.push(result.name.value);
                      }
                    }
                  });
                  const referenceQuery = buildReferenceQuery(node, [
                    ...p,
                    node.name.value
                  ]);
                  if (referenceQuery) {
                    paths.push(referenceQuery);
                  }
                }
              }
            }
          }
        }
      };
    };
    (0, import_graphql3.visit)(ast, (0, import_graphql3.visitWithTypeInfo)(typeInfo, referencePathVisitor()));
    const res = await (0, import_graphql3.graphql)({
      schema: graphQLSchema,
      source: query,
      variableValues: variables,
      contextValue: {
        database
      },
      typeResolver: async (source, _args, info) => {
        if (source.__typename)
          return source.__typename;
        const namedType = (0, import_graphql3.getNamedType)(info.returnType).toString();
        const lookup = await database.getLookup(namedType);
        if (lookup.resolveType === "unionData") {
          return lookup.typeMap[source._template];
        } else {
          throw new Error(`Unable to find lookup key for ${namedType}`);
        }
      },
      fieldResolver: async (source = {}, _args = {}, _context, info) => {
        const args = JSON.parse(JSON.stringify(_args));
        const returnType = (0, import_graphql3.getNamedType)(info.returnType).toString();
        const lookup = await database.getLookup(returnType);
        const isMutation = info.parentType.toString() === "Mutation";
        const value = source[info.fieldName];
        if (returnType === "Collection") {
          if (value) {
            return value;
          }
          if (info.fieldName === "getCollections") {
            return tinaSchema.getCollections().map((collection) => {
              return resolver2.resolveCollection(collection.name);
            });
          }
          return resolver2.resolveCollection(args.collection);
        }
        if (info.fieldName === "getDocumentFields") {
          return resolver2.getDocumentFields();
        }
        if (!lookup) {
          return value;
        }
        const isCreation = lookup[info.fieldName] === "create";
        switch (lookup.resolveType) {
          case "nodeDocument":
            assertShape(args, (yup3) => yup3.object({ id: yup3.string().required() }));
            return resolver2.getDocument(args.id);
          case "multiCollectionDocument":
            if (typeof value === "string") {
              return resolver2.getDocument(value);
            }
            if (args && args.collection && info.fieldName === "addPendingDocument") {
              return resolver2.resolveDocument({
                args: __spreadProps(__spreadValues({}, args), { params: {} }),
                collection: args.collection,
                isMutation,
                isCreation: true,
                isAddPendingDocument: true
              });
            }
            if (["getDocument", "createDocument", "updateDocument"].includes(info.fieldName)) {
              const result2 = await resolver2.resolveDocument({
                args,
                collection: args.collection,
                isMutation,
                isCreation,
                isAddPendingDocument: false,
                isCollectionSpecific: false
              });
              if (!isMutation) {
                const mutationPath = buildMutationPath(info, {
                  relativePath: result2.sys.relativePath
                });
                if (mutationPath) {
                  mutationPaths.push(mutationPath);
                }
              }
              return result2;
            }
            return value;
          case "multiCollectionDocumentList":
            if (Array.isArray(value)) {
              return {
                totalCount: value.length,
                edges: value.map((document3) => {
                  return { node: document3 };
                })
              };
            } else {
              throw new Error(`Expected an array for result of ${info.fieldName} at ${info.path}`);
            }
          case "collectionDocument":
            if (value) {
              return value;
            }
            const result = value || await resolver2.resolveDocument({
              args,
              collection: lookup.collection,
              isMutation,
              isCreation,
              isAddPendingDocument: false,
              isCollectionSpecific: true
            });
            if (!isMutation) {
              const mutationPath = buildMutationPath(info, {
                collection: tinaSchema.getCollection(lookup.collection),
                relativePath: result.sys.relativePath
              });
              if (mutationPath) {
                mutationPaths.push(mutationPath);
              }
            }
            return result;
          case "collectionDocumentList":
            return resolver2.resolveCollectionConnection({ args, lookup });
          case "unionData":
            return value;
          default:
            console.error(lookup);
            throw new Error(`Unexpected resolve type`);
        }
      }
    });
    paths.forEach((p) => {
      const item = import_lodash6.default.get(res, p.path.slice(0, 3));
      if (item) {
        item.paths = [...item.paths || [], p];
      }
    });
    mutationPaths.forEach((mutationPath) => {
      const item = import_lodash6.default.get(res, mutationPath.path);
      if (item) {
        item.mutationInfo = mutationPath;
      }
    });
    if (res.errors) {
      if (!silenceErrors) {
        console.error(res.errors);
      }
    }
    return res;
  } catch (e) {
    if (!silenceErrors) {
      console.error(e);
    }
    if (e instanceof import_graphql3.GraphQLError) {
      return {
        errors: [e]
      };
    } else {
      throw e;
    }
  }
};
var buildPath = (path6, accum) => {
  if (path6.prev) {
    buildPath(path6.prev, accum);
  }
  accum.push(path6.key);
  return accum;
};
var buildReferenceQuery = (fieldNode, path6) => {
  if (fieldNode) {
    const p = path6.map((item) => item === "data" ? "form" : item);
    const dataPath = path6;
    const newNode = __spreadProps(__spreadValues({}, fieldNode), {
      name: { kind: "Name", value: "node" },
      arguments: [
        {
          kind: "Argument",
          name: {
            kind: "Name",
            value: "id"
          },
          value: {
            kind: "Variable",
            name: {
              kind: "Name",
              value: "id"
            }
          }
        }
      ]
    });
    const q = {
      kind: "OperationDefinition",
      operation: "query",
      name: {
        value: "GetNode",
        kind: "Name"
      },
      variableDefinitions: [
        {
          kind: "VariableDefinition",
          variable: {
            kind: "Variable",
            name: {
              kind: "Name",
              value: "id"
            }
          },
          type: {
            kind: "NonNullType",
            type: {
              kind: "NamedType",
              name: {
                kind: "Name",
                value: "String"
              }
            }
          }
        }
      ],
      selectionSet: {
        kind: "SelectionSet",
        selections: [newNode]
      }
    };
    const queryString = (0, import_graphql3.print)(q);
    return {
      path: ["data", ...p.slice(0, -1)],
      dataPath,
      queryString
    };
  }
};
var buildMutationPath = (info, {
  collection,
  relativePath
}) => {
  var _a, _b, _c;
  const queryNode = info.fieldNodes.find((fn) => fn.name.value === info.fieldName);
  if (!queryNode) {
    throw new Error(`exptected to find field node for ${info.fieldName}`);
  }
  const mutationName = collection ? NAMER.updateName([collection.name]) : "updateDocument";
  const mutations = JSON.parse(JSON.stringify((_a = info.schema.getMutationType()) == null ? void 0 : _a.getFields()));
  const mutation = mutations[mutationName];
  if (!mutation) {
    throw new Error(`exptected to find mutation for ${mutationName}`);
  }
  const mutationNode = mutations[mutationName].astNode;
  const newNode = __spreadProps(__spreadValues({}, queryNode), {
    name: { kind: "Name", value: mutation.name },
    arguments: (_b = mutationNode == null ? void 0 : mutationNode.arguments) == null ? void 0 : _b.map((argument) => {
      if (argument.name.value === "relativePath") {
        return {
          kind: "Argument",
          name: {
            kind: "Name",
            value: argument.name.value
          },
          value: {
            kind: "StringValue",
            value: relativePath
          }
        };
      }
      return {
        kind: "Argument",
        name: {
          kind: "Name",
          value: argument.name.value
        },
        value: {
          kind: "Variable",
          name: {
            kind: "Name",
            value: argument.name.value
          }
        }
      };
    })
  });
  const paramArgs = (_c = mutationNode == null ? void 0 : mutationNode.arguments) == null ? void 0 : _c.find((arg) => arg.name.value === "params");
  if (!paramArgs) {
    throw new Error(`Expected to find argument named params for mutation ${mutationName}`);
  }
  const q = {
    kind: "OperationDefinition",
    operation: "mutation",
    name: {
      value: "UpdateDocument",
      kind: "Name"
    },
    variableDefinitions: [
      {
        kind: "VariableDefinition",
        variable: {
          kind: "Variable",
          name: {
            kind: "Name",
            value: "params"
          }
        },
        type: paramArgs == null ? void 0 : paramArgs.type
      }
    ],
    selectionSet: {
      kind: "SelectionSet",
      selections: [newNode]
    }
  };
  const mutationString = addFragmentsToQuery(info, newNode, q);
  return {
    path: ["data", ...buildPath(info.path, []), "form"],
    string: mutationString,
    includeCollection: collection ? false : true,
    includeTemplate: collection ? !!collection.templates : false
  };
};
function addFragmentsToQuery(info, fieldNode, q) {
  const fragmentSpreadVisitor = (frag) => {
    return {
      leave: {
        FragmentSpread(node) {
          frag.subFrags.push(node.name.value);
        }
      }
    };
  };
  const frags = [];
  Object.entries(info.fragments).map(([fragmentName, fragmentDefinition]) => {
    const frag = {
      name: fragmentName,
      node: fragmentDefinition,
      subFrags: []
    };
    frags.push(frag);
    (0, import_graphql3.visit)(fragmentDefinition, fragmentSpreadVisitor(frag));
  });
  const n = {
    query: (0, import_graphql3.print)(fieldNode),
    fragments: []
  };
  const visitor = {
    leave: {
      FragmentSpread(node) {
        n.fragments.push(node.name.value);
      }
    }
  };
  (0, import_graphql3.visit)(fieldNode, visitor);
  const getFrags = (fragNames, accum) => {
    fragNames.forEach((fragName) => {
      const frag = frags.find((f) => f.name === fragName);
      if (!frag) {
        throw new Error(`Unable to find fragment ${fragName}`);
      }
      accum.push(frag.node);
      if (frag.subFrags) {
        getFrags(frag.subFrags, accum);
      }
    });
    return accum;
  };
  const fragss = getFrags(n.fragments, []);
  const queryString = `${fragss.map((f) => (0, import_graphql3.print)(f)).join("\n")}
${(0, import_graphql3.print)(q)}`;
  return queryString;
}

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/database/index.ts
var import_path4 = __toModule(require("path"));
var import_graphql4 = __toModule(require("graphql"));

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/database/util.ts
var import_gray_matter = __toModule(require("gray-matter"));
var stringifyFile = (content3, format, keepTemplateKey) => {
  switch (format) {
    case ".markdown":
    case ".mdx":
    case ".md":
      const _a = content3, {
        _relativePath,
        _keepTemplateKey,
        _id,
        _template,
        _collection,
        $_body
      } = _a, rest = __objRest(_a, [
        "_relativePath",
        "_keepTemplateKey",
        "_id",
        "_template",
        "_collection",
        "$_body"
      ]);
      const extra = {};
      if (keepTemplateKey) {
        extra["_template"] = _template;
      }
      const ok2 = import_gray_matter.default.stringify(typeof $_body === "undefined" ? "" : `
${$_body}`, __spreadValues(__spreadValues({}, rest), extra));
      return ok2;
    case ".json":
      return JSON.stringify(content3, null, 2);
    default:
      throw new Error(`Must specify a valid format, got ${format}`);
  }
};
var parseFile = (content3, format, yupSchema) => {
  switch (format) {
    case ".markdown":
    case ".mdx":
    case ".md":
      const contentJSON = (0, import_gray_matter.default)(content3 || "");
      const markdownData = __spreadProps(__spreadValues({}, contentJSON.data), {
        $_body: contentJSON.content
      });
      assertShape(markdownData, yupSchema);
      return markdownData;
    case ".json":
      if (!content3) {
        return {};
      }
      return JSON.parse(content3);
    default:
      throw new Error(`Must specify a valid format, got ${format}`);
  }
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/database/index.ts
var import_lodash7 = __toModule(require("lodash"));
var createDatabase = async (config) => {
  return new Database(__spreadProps(__spreadValues({}, config), {
    bridge: config.bridge,
    store: config.store
  }));
};
var SYSTEM_FILES = ["_schema", "_graphql", "_lookup"];
var GENERATED_FOLDER = import_path4.default.join(".tina", "__generated__");
var Database = class {
  constructor(config) {
    this.config = config;
    this.get = async (filepath) => {
      if (SYSTEM_FILES.includes(filepath)) {
        throw new Error(`Unexpected get for config file ${filepath}`);
      } else {
        const tinaSchema = await this.getSchema();
        const extension2 = import_path4.default.extname(filepath);
        const contentObject = await this.store.get(filepath);
        if (!contentObject) {
          throw new import_graphql4.GraphQLError(`Unable to find record ${filepath}`);
        }
        const templateName = hasOwnProperty2(contentObject, "_template") && typeof contentObject._template === "string" ? contentObject._template : void 0;
        const { collection, template } = await tinaSchema.getCollectionAndTemplateByFullPath(filepath, templateName);
        const field = template.fields.find((field2) => {
          if (field2.type === "string" || field2.type === "rich-text") {
            if (field2.isBody) {
              return true;
            }
          }
          return false;
        });
        let data = contentObject;
        if ((extension2 === ".md" || extension2 === ".mdx") && field) {
          if (hasOwnProperty2(contentObject, "$_body")) {
            const _a = contentObject, { $_body } = _a, rest = __objRest(_a, ["$_body"]);
            data = rest;
            data[field.name] = $_body;
          }
        }
        return __spreadProps(__spreadValues({}, data), {
          _collection: collection.name,
          _keepTemplateKey: !!collection.templates,
          _template: lastItem(template.namespace),
          _relativePath: filepath.replace(collection.path, "").replace(/^\/|\/$/g, ""),
          _id: filepath
        });
      }
    };
    this.addPendingDocument = async (filepath, data) => {
      const { stringifiedFile, payload } = await this.stringifyFile(filepath, data);
      if (this.store.supportsSeeding()) {
        await this.bridge.put(filepath, stringifiedFile);
      }
      await this.store.put(filepath, payload);
    };
    this.put = async (filepath, data) => {
      if (SYSTEM_FILES.includes(filepath)) {
        throw new Error(`Unexpected put for config file ${filepath}`);
      } else {
        const { stringifiedFile, payload } = await this.stringifyFile(filepath, data);
        if (this.store.supportsSeeding()) {
          await this.bridge.put(filepath, stringifiedFile);
        }
        if (this.store.supportsIndexing()) {
          const existingData = await this.get(filepath);
          const collection = this.tinaSchema.getCollection(existingData._collection);
          const attributesToFilterOut = await _indexCollectable({
            record: filepath,
            value: existingData,
            field: collection,
            prefix: collection.name,
            database: this
          });
          const attributesToAdd = await _indexCollectable({
            record: filepath,
            value: data,
            field: collection,
            prefix: collection.name,
            database: this
          });
          await sequential(attributesToFilterOut, async (attribute) => {
            const records = await this.store.get(attribute) || [];
            await this.store.put(attribute, records.filter((item) => item !== filepath));
            return true;
          });
          await sequential(attributesToAdd, async (attribute) => {
            const records = await this.store.get(attribute) || [];
            await this.store.put(attribute, [...records, filepath]);
            return true;
          });
        }
        await this.store.put(filepath, payload);
      }
      return true;
    };
    this.stringifyFile = async (filepath, data) => {
      if (SYSTEM_FILES.includes(filepath)) {
        throw new Error(`Unexpected put for config file ${filepath}`);
      } else {
        const tinaSchema = await this.getSchema();
        const collection = await tinaSchema.getCollectionByFullPath(filepath);
        const templateInfo = await tinaSchema.getTemplatesForCollectable(collection);
        let template;
        if (templateInfo.type === "object") {
          template = templateInfo.template;
        }
        if (templateInfo.type === "union") {
          if (hasOwnProperty2(data, "_template")) {
            template = templateInfo.templates.find((t) => lastItem(t.namespace) === data._template);
          } else {
            throw new Error(`Expected _template to be provided for document in an ambiguous collection`);
          }
        }
        if (!template) {
          throw new Error(`Unable to determine template`);
        }
        const field = template.fields.find((field2) => {
          if (field2.type === "string" || field2.type === "rich-text") {
            if (field2.isBody) {
              return true;
            }
          }
          return false;
        });
        let payload = {};
        if (["md", "mdx"].includes(collection.format) && field) {
          Object.entries(data).forEach(([key2, value]) => {
            if (key2 !== field.name) {
              payload[key2] = value;
            }
          });
          payload["$_body"] = data[field.name];
        } else {
          payload = data;
        }
        const extension2 = import_path4.default.extname(filepath);
        const stringifiedFile = stringifyFile(payload, extension2, templateInfo.type === "union");
        return { stringifiedFile, payload };
      }
    };
    this.flush = async (filepath) => {
      const data = await this.get(filepath);
      const { stringifiedFile } = await this.stringifyFile(filepath, data);
      return stringifiedFile;
    };
    this.getLookup = async (returnType) => {
      const lookupPath = import_path4.default.join(GENERATED_FOLDER, `_lookup.json`);
      if (!this._lookup) {
        const _lookup = await this.store.get(lookupPath);
        this._lookup = _lookup;
      }
      return this._lookup[returnType];
    };
    this.getGraphQLSchema = async () => {
      const graphqlPath = import_path4.default.join(GENERATED_FOLDER, `_graphql.json`);
      return this.store.get(graphqlPath);
    };
    this.getGraphQLSchemaFromBridge = async () => {
      const graphqlPath = import_path4.default.join(GENERATED_FOLDER, `_graphql.json`);
      const _graphql = await this.bridge.get(graphqlPath);
      return JSON.parse(_graphql);
    };
    this.getTinaSchema = async () => {
      const schemaPath = import_path4.default.join(GENERATED_FOLDER, `_schema.json`);
      return this.store.get(schemaPath);
    };
    this.getSchema = async () => {
      if (this.tinaSchema) {
        return this.tinaSchema;
      }
      const schema = await this.getTinaSchema();
      this.tinaSchema = await createSchema({ schema });
      return this.tinaSchema;
    };
    this.documentExists = async (fullpath) => {
      try {
        await this.get(fullpath);
      } catch (e) {
        return false;
      }
      return true;
    };
    this.query = async (queryStrings, hydrator) => {
      return await this.store.query(queryStrings, hydrator);
    };
    this.indexData = async ({
      graphQLSchema,
      tinaSchema
    }) => {
      if (!this.bridge.supportsBuilding()) {
        throw new Error(`Schema cannot be built with provided Bridge`);
      }
      const graphqlPath = import_path4.default.join(GENERATED_FOLDER, `_graphql.json`);
      const schemaPath = import_path4.default.join(GENERATED_FOLDER, `_schema.json`);
      await this.bridge.putConfig(graphqlPath, JSON.stringify(graphQLSchema, null, 2));
      await this.bridge.putConfig(schemaPath, JSON.stringify(tinaSchema.schema, null, 2));
      const lookup = JSON.parse(await this.bridge.get(import_path4.default.join(GENERATED_FOLDER, "_lookup.json")));
      if (this.store.supportsSeeding()) {
        this.store.clear();
        await this.store.seed(import_path4.default.join(GENERATED_FOLDER, "_graphql.json"), graphQLSchema);
        await this.store.seed(import_path4.default.join(GENERATED_FOLDER, "_schema.json"), tinaSchema.schema);
        await this.store.seed(import_path4.default.join(GENERATED_FOLDER, "_lookup.json"), lookup);
        await _indexContent(tinaSchema, this);
      } else {
        if (this.store.supportsIndexing()) {
          throw new Error(`Schema must be indexed with provided Store`);
        }
      }
    };
    this.addToLookupMap = async (lookup) => {
      const lookupPath = import_path4.default.join(GENERATED_FOLDER, `_lookup.json`);
      let lookupMap;
      try {
        lookupMap = JSON.parse(await this.bridge.get(lookupPath));
      } catch (e) {
        lookupMap = {};
      }
      const updatedLookup = __spreadProps(__spreadValues({}, lookupMap), {
        [lookup.type]: lookup
      });
      await this.bridge.putConfig(lookupPath, JSON.stringify(updatedLookup, null, 2));
    };
    this.bridge = config.bridge;
    this.store = config.store;
  }
};
function hasOwnProperty2(obj, prop) {
  return obj.hasOwnProperty(prop);
}
var _indexContent = async (tinaSchema, database) => {
  await sequential(tinaSchema.getCollections(), async (collection) => {
    const documentPaths = await database.bridge.glob(collection.path);
    await sequential(documentPaths, async (documentPath) => {
      const dataString = await database.bridge.get(documentPath);
      const data = parseFile(dataString, import_path4.default.extname(documentPath), (yup3) => yup3.object({}));
      if (database.store.supportsSeeding()) {
        await database.store.seed(documentPath, data);
      }
      if (database.store.supportsIndexing()) {
        return indexDocument({ documentPath, collection, data, database });
      }
    });
  });
};
var indexDocument = async ({
  documentPath,
  data,
  collection,
  database
}) => {
  const attributes = await _indexCollectable({
    record: documentPath,
    field: collection,
    value: data,
    prefix: `${lastItem(collection.namespace)}`,
    database
  });
  await sequential(attributes, async (fieldName) => {
    const existingRecords = await database.store.get(fieldName) || [];
    const uniqueItems = [...new Set([...existingRecords, documentPath])];
    await database.store.seed(fieldName, uniqueItems);
  });
};
var _indexCollectable = async (_a) => {
  var _b = _a, {
    field,
    value
  } = _b, rest = __objRest(_b, [
    "field",
    "value"
  ]);
  let template;
  let extra = "";
  if (field.templates) {
    template = field.templates.find((t) => {
      if (typeof t === "string") {
        throw new Error(`Global templates not yet supported`);
      }
      if (hasOwnProperty2(value, "_template")) {
        return t.name === value._template;
      } else {
        throw new Error(`Expected value for collectable with multiple templates to have property _template`);
      }
    });
    extra = `#${lastItem(template.namespace)}`;
  } else {
    template = field;
  }
  const atts = await _indexAttributes({
    record: rest.record,
    data: value,
    prefix: `${rest.prefix}${extra}#${template.name}`,
    fields: template.fields,
    database: rest.database
  });
  return (0, import_lodash7.flatten)(atts).filter((item) => !(0, import_lodash7.isBoolean)(item));
};
var _indexAttributes = async (_a) => {
  var _b = _a, {
    data,
    fields
  } = _b, rest = __objRest(_b, [
    "data",
    "fields"
  ]);
  return sequential(fields, async (field) => {
    const value = data[field.name];
    if (!value) {
      return true;
    }
    switch (field.type) {
      case "boolean":
      case "string":
      case "number":
      case "datetime":
        return _indexAttribute(__spreadValues({ value, field }, rest));
      case "object":
        if (field.list) {
          await sequential(value, async (item) => {
            return _indexCollectable(__spreadValues({ field, value: item }, rest));
          });
        } else {
          return _indexCollectable(__spreadValues({ field, value }, rest));
        }
        return true;
      case "reference":
        return _indexAttribute(__spreadValues({ value, field }, rest));
    }
    return true;
  });
};
var _indexAttribute = async ({
  record,
  value,
  prefix,
  field,
  database
}) => {
  const stringValue = value.toString().substr(0, 100);
  const fieldName = `__attribute__${prefix}#${field.name}#${stringValue}`;
  return fieldName;
};

// pnp:/Users/jeffsee/code/tinacms/packages/@tinacms/graphql/src/index.ts
var buildSchema = async (rootPath, database) => {
  const tempConfig = import_path5.default.join(rootPath, ".tina", "__generated__", "config");
  const config = await import_fs_extra2.default.readFileSync(import_path5.default.join(tempConfig, "schema.json")).toString();
  await import_fs_extra2.default.rmdir(tempConfig, { recursive: true });
  await indexDB({ database, config: JSON.parse(config) });
  const gqlAst = await database.getGraphQLSchemaFromBridge();
  return (0, import_graphql5.buildASTSchema)(gqlAst);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assertShape,
  buildSchema,
  createDatabase,
  indexDB,
  parseFile,
  resolve,
  sequential,
  stringifyFile
});
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
