/**
Copyright 2021 Forestry.io Holdings, Inc.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
import { FieldDefinitionNode, ScalarTypeDefinitionNode, InputValueDefinitionNode, ObjectTypeDefinitionNode, InterfaceTypeDefinitionNode, NamedTypeNode, UnionTypeDefinitionNode, TypeDefinitionNode, DirectiveNode, EnumTypeDefinitionNode, InputObjectTypeDefinitionNode, DocumentNode, FragmentDefinitionNode, SelectionNode, FieldNode, InlineFragmentNode, OperationDefinitionNode } from 'graphql';
/**
 * the `gql` module provides functions and types which can be
 * used to build up the GraphQL AST. The primary reason for us using
 * this instead of the [builders provided by the graphql package](https://graphql.org/graphql-js/type/#examples)
 * is due to the dynamic and asynchronous nature of our needs.
 *
 * The tradeoff is a low-level API that's often more verbose, and it's
 * not a complete match of the GraphQL spec, so additional properties will likely
 * be needed as our needs grow.
 */
export declare const astBuilder: {
    /**
     * `FormFieldBuilder` acts as a shortcut to building an entire `ObjectTypeDefinition`, we use this
     * because all Tina field objects share a common set of fields ('name', 'label', 'component')
     */
    FormFieldBuilder: ({ name, additionalFields, }: {
        name: string;
        additionalFields?: FieldDefinitionNode[];
    }) => ObjectTypeDefinitionNode;
    ScalarTypeDefinition: ({ name, description, }: {
        name: string;
        description?: string;
    }) => ScalarTypeDefinitionNode;
    InputValueDefinition: ({ name, type, list, required, }: {
        name: string;
        type: string | InputObjectTypeDefinitionNode | EnumTypeDefinitionNode;
        list?: boolean;
        required?: boolean;
    }) => InputValueDefinitionNode;
    EnumDefinition: (props: {
        name: string;
        required?: boolean;
        values: string[];
    }) => EnumTypeDefinitionNode;
    FieldNodeDefinition: ({ name, type, args, list, required, }: {
        name: string;
        type: string | TypeDefinitionNode;
        required?: boolean;
        list?: boolean;
        args?: InputValueDefinitionNode[];
    }) => FieldNode;
    FieldDefinition: ({ name, type, args, list, required, }: {
        name: string;
        type: string | TypeDefinitionNode;
        required?: boolean;
        list?: boolean;
        args?: InputValueDefinitionNode[];
    }) => FieldDefinitionNode;
    InterfaceTypeDefinition: ({ name, fields, description, }: {
        name: string;
        description?: string;
        fields: FieldDefinitionNode[];
    }) => InterfaceTypeDefinitionNode;
    InputObjectTypeDefinition: ({ name, fields, }: {
        name: string;
        fields: InputValueDefinitionNode[] | ObjectTypeDefinitionNode[];
    }) => InputObjectTypeDefinitionNode;
    UnionTypeDefinition: ({ name, types, }: {
        name: string;
        types: (string | TypeDefinitionNode)[];
    }) => UnionTypeDefinitionNode;
    NamedType: ({ name }: {
        name: string;
    }) => NamedTypeNode;
    ObjectTypeDefinition: ({ name, fields, interfaces, directives, args, }: {
        name: string;
        fields: FieldDefinitionNode[];
        interfaces?: NamedTypeNode[];
        directives?: DirectiveNode[];
        args?: NamedTypeNode[];
    }) => ObjectTypeDefinitionNode;
    FieldWithSelectionSetDefinition: ({ name, selections, }: {
        name: string;
        selections: SelectionNode[];
    }) => {
        name: {
            kind: "Name";
            value: string;
        };
        kind: "Field";
        selectionSet: {
            kind: "SelectionSet";
            selections: SelectionNode[];
        };
    };
    InlineFragmentDefinition: ({ name, selections, }: {
        name: string;
        selections: SelectionNode[];
    }) => InlineFragmentNode;
    FragmentDefinition: ({ name, fragmentName, selections, }: {
        name: string;
        fragmentName: string;
        selections: SelectionNode[];
    }) => FragmentDefinitionNode;
    TYPES: {
        Scalar: (type: scalarNames) => string;
        MultiCollectionDocument: string;
        CollectionDocumentUnion: string;
        String: string;
        Reference: string;
        Collection: string;
        ID: string;
        SystemInfo: string;
        Boolean: string;
        JSON: string;
        Node: string;
        PageInfo: string;
        Connection: string;
        Number: string;
        Document: string;
    };
    QueryOperationDefinition: ({ queryName, fragName, }: {
        queryName: string;
        fragName: string;
    }) => OperationDefinitionNode;
    ListQueryOperationDefinition: ({ queryName, fragName, }: {
        queryName: string;
        fragName: string;
    }) => OperationDefinitionNode;
    toGraphQLAst: (ast: {
        globalTemplates: TypeDefinitionNode[];
        query: TypeDefinitionNode;
        definitions: TypeDefinitionNode[];
    }) => DocumentNode;
};
declare type scalarNames = 'string' | 'boolean' | 'datetime' | 'image' | 'text' | 'number';
export declare const extractInlineTypes: (item: TypeDefinitionNode | TypeDefinitionNode[]) => TypeDefinitionNode[];
export declare function walk(maybeNode: TypeDefinitionNode, visited?: WeakSet<object>): IterableIterator<TypeDefinitionNode>;
export declare function addNamespaceToSchema<T extends object | string>(maybeNode: T, namespace?: string[]): T;
export declare const NAMER: {
    dataFilterTypeNameOn: (namespace: string[]) => string;
    dataFilterTypeName: (namespace: string[]) => string;
    dataMutationTypeNameOn: (namespace: string[]) => string;
    dataMutationTypeName: (namespace: string[]) => string;
    updateName: (namespace: string[]) => string;
    createName: (namespace: string[]) => string;
    queryName: (namespace: string[]) => string;
    generateQueryListName: (namespace: string[]) => string;
    fragmentName: (namespace: string[]) => string;
    collectionTypeName: (namespace: string[]) => string;
    documentTypeName: (namespace: string[]) => string;
    dataTypeName: (namespace: string[]) => string;
    referenceConnectionType: (namespace: string[]) => string;
    referenceConnectionEdgesTypeName: (namespace: string[]) => string;
};
export {};
