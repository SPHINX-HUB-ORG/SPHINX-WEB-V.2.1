/**

*/
import { FieldDefinitionNode, ScalarTypeDefinitionNode, InputValueDefinitionNode, ObjectTypeDefinitionNode, InterfaceTypeDefinitionNode, NamedTypeNode, UnionTypeDefinitionNode, TypeDefinitionNode, DirectiveNode, EnumTypeDefinitionNode, InputObjectTypeDefinitionNode, DocumentNode, FragmentDefinitionNode, SelectionNode, FieldNode, InlineFragmentNode, OperationDefinitionNode } from 'graphql';
export declare const SysFieldDefinition: {
    kind: "Field";
    name: {
        kind: "Name";
        value: string;
    };
    arguments: any[];
    directives: any[];
    selectionSet: {
        kind: "SelectionSet";
        selections: {
            kind: "Field";
            name: {
                kind: "Name";
                value: string;
            };
            arguments: any[];
            directives: any[];
        }[];
    };
};
/**
 * the `gql` module provides functions and types which can be
 * used to build up the GraphQL AST. The primary reason for us using
 * this instead of the [builders provided by the graphql package](https://graphql.org/graphql-js/type/#examples)
 * is due to the dynamic and asynchronous nature of our needs.
 *
 * The tradeoff is a low-level API that's often more verbose, and it's
 * not a complete match of the GraphQL spec, so additional properties will likely
 * be needed as our needs grow.
 */
export declare const astBuilder: {
    /**
     * `FormFieldBuilder` acts as a shortcut to building an entire `ObjectTypeDefinition`, we use this
     * because all Tina field objects share a common set of fields ('name', 'label', 'component')
     */
    FormFieldBuilder: ({ name, additionalFields, }: {
        name: string;
        additionalFields?: FieldDefinitionNode[];
    }) => ObjectTypeDefinitionNode;
    ScalarTypeDefinition: ({ name, description, }: {
        name: string;
        description?: string;
    }) => ScalarTypeDefinitionNode;
    InputValueDefinition: ({ name, type, list, required, }: {
        name: string;
        type: string | InputObjectTypeDefinitionNode | EnumTypeDefinitionNode;
        list?: boolean;
        required?: boolean;
    }) => InputValueDefinitionNode;
    EnumDefinition: (props: {
        name: string;
        required?: boolean;
        values: string[];
    }) => EnumTypeDefinitionNode;
    FieldNodeDefinition: ({ name, type, args, list, required, }: {
        name: string;
        type: string | TypeDefinitionNode;
        required?: boolean;
        list?: boolean;
        args?: InputValueDefinitionNode[];
    }) => FieldNode;
    FieldDefinition: ({ name, type, args, list, required, }: {
        name: string;
        type: string | TypeDefinitionNode;
        required?: boolean;
        list?: boolean;
        args?: InputValueDefinitionNode[];
    }) => FieldDefinitionNode;
    InterfaceTypeDefinition: ({ name, fields, description, }: {
        name: string;
        description?: string;
        fields: FieldDefinitionNode[];
    }) => InterfaceTypeDefinitionNode;
    InputObjectTypeDefinition: ({ name, fields, }: {
        name: string;
        fields: InputValueDefinitionNode[] | ObjectTypeDefinitionNode[];
    }) => InputObjectTypeDefinitionNode;
    UnionTypeDefinition: ({ name, types, }: {
        name: string;
        types: (string | TypeDefinitionNode)[];
    }) => UnionTypeDefinitionNode;
    NamedType: ({ name }: {
        name: string;
    }) => NamedTypeNode;
    ObjectTypeDefinition: ({ name, fields, interfaces, directives, args, }: {
        name: string;
        fields: FieldDefinitionNode[];
        interfaces?: NamedTypeNode[];
        directives?: DirectiveNode[];
        args?: NamedTypeNode[];
    }) => ObjectTypeDefinitionNode;
    FieldWithSelectionSetDefinition: ({ name, selections, }: {
        name: string;
        selections: SelectionNode[];
    }) => {
        name: {
            kind: "Name";
            value: string;
        };
        kind: "Field";
        selectionSet: {
            kind: "SelectionSet";
            selections: SelectionNode[];
        };
    };
    InlineFragmentDefinition: ({ name, selections, }: {
        name: string;
        selections: SelectionNode[];
    }) => InlineFragmentNode;
    FragmentDefinition: ({ name, fragmentName, selections, }: {
        name: string;
        fragmentName: string;
        selections: SelectionNode[];
    }) => FragmentDefinitionNode;
    TYPES: {
        Scalar: (type: scalarNames) => string;
        MultiCollectionDocument: string;
        CollectionDocumentUnion: string;
        Folder: string;
        String: string;
        Reference: string;
        Collection: string;
        ID: string;
        SystemInfo: string;
        Boolean: string;
        JSON: string;
        Node: string;
        PageInfo: string;
        Connection: string;
        Number: string;
        Document: string;
    };
    QueryOperationDefinition: ({ queryName, fragName, }: {
        queryName: string;
        fragName: string;
    }) => OperationDefinitionNode;
    ListQueryOperationDefinition: ({ queryName, fragName, filterType, dataLayer, }: {
        queryName: string;
        fragName: string;
        filterType: string;
        dataLayer: boolean;
    }) => OperationDefinitionNode;
    toGraphQLAst: (ast: {
        globalTemplates: TypeDefinitionNode[];
        query: TypeDefinitionNode;
        definitions: TypeDefinitionNode[];
    }) => DocumentNode;
};
declare type scalarNames = 'string' | 'boolean' | 'datetime' | 'image' | 'text' | 'number';
export declare const extractInlineTypes: (item: TypeDefinitionNode | TypeDefinitionNode[]) => TypeDefinitionNode[];
export declare function walk(maybeNode: TypeDefinitionNode, visited?: WeakSet<object>): IterableIterator<TypeDefinitionNode>;
export declare function addNamespaceToSchema<T extends object | string>(maybeNode: T, namespace?: string[]): T;
export declare const NAMER: {
    dataFilterTypeNameOn: (namespace: string[]) => string;
    dataFilterTypeName: (namespace: string[]) => string;
    dataMutationTypeNameOn: (namespace: string[]) => string;
    dataMutationTypeName: (namespace: string[]) => string;
    dataMutationUpdateTypeName: (namespace: string[]) => string;
    updateName: (namespace: string[]) => string;
    createName: (namespace: string[]) => string;
    documentQueryName: () => string;
    documentConnectionQueryName: () => string;
    collectionQueryName: () => string;
    collectionListQueryName: () => string;
    queryName: (namespace: string[]) => string;
    generateQueryListName: (namespace: string[]) => string;
    fragmentName: (namespace: string[]) => string;
    collectionTypeName: (namespace: string[]) => string;
    documentTypeName: (namespace: string[]) => string;
    dataTypeName: (namespace: string[]) => string;
    referenceConnectionType: (namespace: string[]) => string;
    referenceConnectionEdgesTypeName: (namespace: string[]) => string;
};
export {};
