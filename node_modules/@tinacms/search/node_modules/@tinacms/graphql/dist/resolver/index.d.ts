/**

*/
import { Database } from '../database';
import type { Collectable, Collection, TinaField, Template, TinaSchema } from '@tinacms/schema-tools';
import type { GraphQLConfig } from '../types';
interface ResolverConfig {
    config?: GraphQLConfig;
    database: Database;
    tinaSchema: TinaSchema;
    isAudit: boolean;
}
export declare const createResolver: (args: ResolverConfig) => Resolver;
export declare const transformDocumentIntoPayload: (fullPath: string, rawData: {
    _collection;
    _template;
}, tinaSchema: TinaSchema, config?: GraphQLConfig, isAudit?: boolean) => Promise<{
    _sys: {
        title: any;
        basename: string;
        filename: string;
        extension: string;
        path: string;
        relativePath: string;
        breadcrumbs: string[];
        collection: Collection<true>;
        template: string | number;
    };
    _values: {
        _collection: any;
        _template: any;
    };
    _rawData: {
        _collection: any;
        _template: any;
    };
    _collection: any;
    _template: any;
    __typename: string;
    id: string;
}>;
/**
 * The resolver provides functions for all possible types of lookup
 * values and retrieves them from the database
 */
export declare class Resolver {
    init: ResolverConfig;
    config: GraphQLConfig;
    database: Database;
    tinaSchema: TinaSchema;
    isAudit: boolean;
    constructor(init: ResolverConfig);
    resolveCollection: (args: any, collectionName: string, hasDocuments?: boolean) => Promise<{
        fields: TinaField<true>[];
        templates?: undefined;
        label?: string;
        name: string;
        path: string;
        indexes?: {
            name: string;
            fields: {
                name: string;
            }[];
        }[];
        format?: "json" | "md" | "markdown" | "mdx" | "yaml" | "yml" | "toml";
        ui?: import("@tinacms/schema-tools").UICollection<any, any, any>;
        defaultItem?: import("@tinacms/schema-tools").DefaultItem<Record<string, any>>;
        frontmatterFormat?: "json" | "yaml" | "toml";
        frontmatterDelimiters?: string | [string, string];
        match?: {
            include?: string;
            exclude?: string;
        };
        namespace: string[];
        documents: {
            collection: Collection<true>;
            hasDocuments: boolean;
        };
    } | {
        templates: Template<true>[];
        fields?: undefined;
        label?: string;
        name: string;
        path: string;
        indexes?: {
            name: string;
            fields: {
                name: string;
            }[];
        }[];
        format?: "json" | "md" | "markdown" | "mdx" | "yaml" | "yml" | "toml";
        ui?: import("@tinacms/schema-tools").UICollection<any, any, any>;
        defaultItem?: import("@tinacms/schema-tools").DefaultItem<Record<string, any>>;
        frontmatterFormat?: "json" | "yaml" | "toml";
        frontmatterDelimiters?: string | [string, string];
        match?: {
            include?: string;
            exclude?: string;
        };
        namespace: string[];
        documents: {
            collection: Collection<true>;
            hasDocuments: boolean;
        };
    }>;
    getRaw: (fullPath: unknown) => Promise<{
        _collection: string;
        _template: string;
    }>;
    getDocumentOrDirectory: (fullPath: unknown) => Promise<{
        _sys: {
            title: any;
            basename: string;
            filename: string;
            extension: string;
            path: string;
            relativePath: string;
            breadcrumbs: string[];
            collection: Collection<true>;
            template: string | number;
        };
        _values: {
            _collection: any;
            _template: any;
        };
        _rawData: {
            _collection: any;
            _template: any;
        };
        _collection: any;
        _template: any;
        __typename: string;
        id: string;
    } | {
        __typename: string;
        name: any;
        path: any;
    }>;
    getDocument: (fullPath: unknown) => Promise<{
        _sys: {
            title: any;
            basename: string;
            filename: string;
            extension: string;
            path: string;
            relativePath: string;
            breadcrumbs: string[];
            collection: Collection<true>;
            template: string | number;
        };
        _values: {
            _collection: any;
            _template: any;
        };
        _rawData: {
            _collection: any;
            _template: any;
        };
        _collection: any;
        _template: any;
        __typename: string;
        id: string;
    }>;
    deleteDocument: (fullPath: unknown) => Promise<void>;
    buildObjectMutations: (fieldValue: any, field: Collectable) => {
        [key: string]: unknown;
    } | {
        [key: string]: unknown;
    }[];
    createResolveDocument: ({ collection, realPath, args, isAddPendingDocument, }: {
        collection: Collection<true>;
        realPath: string;
        args: unknown;
        isAddPendingDocument: boolean;
    }) => Promise<{
        _sys: {
            title: any;
            basename: string;
            filename: string;
            extension: string;
            path: string;
            relativePath: string;
            breadcrumbs: string[];
            collection: Collection<true>;
            template: string | number;
        };
        _values: {
            _collection: any;
            _template: any;
        };
        _rawData: {
            _collection: any;
            _template: any;
        };
        _collection: any;
        _template: any;
        __typename: string;
        id: string;
    }>;
    updateResolveDocument: ({ collection, realPath, args, isAddPendingDocument, isCollectionSpecific, }: {
        collection: Collection<true>;
        realPath: string;
        args: unknown;
        isAddPendingDocument: boolean;
        isCollectionSpecific: boolean;
    }) => Promise<{
        _sys: {
            title: any;
            basename: string;
            filename: string;
            extension: string;
            path: string;
            relativePath: string;
            breadcrumbs: string[];
            collection: Collection<true>;
            template: string | number;
        };
        _values: {
            _collection: any;
            _template: any;
        };
        _rawData: {
            _collection: any;
            _template: any;
        };
        _collection: any;
        _template: any;
        __typename: string;
        id: string;
    }>;
    resolveDocument: ({ args, collection: collectionName, isMutation, isCreation, isDeletion, isAddPendingDocument, isCollectionSpecific, isUpdateName, }: {
        args: unknown;
        collection?: string;
        isMutation: boolean;
        isCreation?: boolean;
        isDeletion?: boolean;
        isAddPendingDocument?: boolean;
        isCollectionSpecific?: boolean;
        isUpdateName?: boolean;
    }) => Promise<{
        _sys: {
            title: any;
            basename: string;
            filename: string;
            extension: string;
            path: string;
            relativePath: string;
            breadcrumbs: string[];
            collection: Collection<true>;
            template: string | number;
        };
        _values: {
            _collection: any;
            _template: any;
        };
        _rawData: {
            _collection: any;
            _template: any;
        };
        _collection: any;
        _template: any;
        __typename: string;
        id: string;
    }>;
    resolveCollectionConnections: ({ ids }: {
        ids: string[];
    }) => Promise<{
        totalCount: number;
        edges: {
            node: {
                _sys: {
                    title: any;
                    basename: string;
                    filename: string;
                    extension: string;
                    path: string;
                    relativePath: string;
                    breadcrumbs: string[];
                    collection: Collection<true>;
                    template: string | number;
                };
                _values: {
                    _collection: any;
                    _template: any;
                };
                _rawData: {
                    _collection: any;
                    _template: any;
                };
                _collection: any;
                _template: any;
                __typename: string;
                id: string;
            };
        }[];
    }>;
    private referenceResolver;
    private resolveFilterConditions;
    resolveCollectionConnection: ({ args, collection, hydrator, }: {
        args: Record<string, Record<string, object> | string | number>;
        collection: Collection<true>;
        hydrator?: (string: any) => any;
    }) => Promise<{
        totalCount: number;
        edges: {
            node: any;
            cursor: string;
        }[];
        pageInfo: {
            hasPreviousPage: boolean;
            hasNextPage: boolean;
            startCursor: string;
            endCursor: string;
        };
    }>;
    private buildFieldMutations;
    /**
     * A mutation looks nearly identical between updateDocument:
     * ```graphql
     * updateDocument(collection: $collection,relativePath: $path, params: {
     *   post: {
     *     title: "Hello, World"
     *   }
     * })`
     * ```
     * and `updatePostDocument`:
     * ```graphql
     * updatePostDocument(relativePath: $path, params: {
     *   title: "Hello, World"
     * })
     * ```
     * The problem here is that we don't know whether the payload came from `updateDocument`
     * or `updatePostDocument` (we could, but for now it's easier not to pipe those details through),
     * But we do know that when given a `args.collection` value, we can assume that
     * this was a `updateDocument` request, and thus - should grab the data
     * from the corresponding field name in the key
     */
    private buildParams;
}
export {};
