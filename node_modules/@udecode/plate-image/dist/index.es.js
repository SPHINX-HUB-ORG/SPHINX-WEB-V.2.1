import { useElement, getNodeString, createComponentAs, createElementAs, useEditorRef, findNodePath, useComposedRef, setNodes, focusEditor, getPointAfter, isDefined, select, createAtomStore, createStore, getPluginType, insertNodes, getInjectedPlugins, pipeInsertDataQuery, createPluginFactory, getBlockAbove, isUrl } from '@udecode/plate-core';
import { useSelected, useReadOnly } from 'slate-react';
import React, { useMemo, forwardRef, useState, useLayoutEffect, useEffect, useRef, useCallback } from 'react';
import { Path } from 'slate';
import ReactTextareaAutosize from 'react-textarea-autosize';
import { Resizable } from 're-resizable';

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var lib = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Constants.
 */

// We make this a function so it can be tested in describe block mocks with Jest.
var IS_MAC = () => typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);

var MODIFIERS = {
  alt: 'altKey',
  control: 'ctrlKey',
  meta: 'metaKey',
  shift: 'shiftKey'
};

// We make this a function so it can be tested in describe block mocks with Jest.
var ALIASES = () => ({
  add: '+',
  break: 'pause',
  cmd: 'meta',
  command: 'meta',
  ctl: 'control',
  ctrl: 'control',
  del: 'delete',
  down: 'arrowdown',
  esc: 'escape',
  ins: 'insert',
  left: 'arrowleft',
  mod: IS_MAC() ? 'meta' : 'control',
  opt: 'alt',
  option: 'alt',
  return: 'enter',
  right: 'arrowright',
  space: ' ',
  spacebar: ' ',
  up: 'arrowup',
  win: 'meta',
  windows: 'meta'
});

var CODES = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  ' ': 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ';': 186,
  '=': 187,
  ',': 188,
  '-': 189,
  '.': 190,
  '/': 191,
  '`': 192,
  '[': 219,
  '\\': 220,
  ']': 221,
  '\'': 222
};

for (var f = 1; f < 20; f++) {
  CODES['f' + f] = 111 + f;
}

/**
 * Is hotkey?
 */

function isHotkey(hotkey, options, event) {
  if (options && !('byKey' in options)) {
    event = options;
    options = null;
  }

  if (!Array.isArray(hotkey)) {
    hotkey = [hotkey];
  }

  var array = hotkey.map(function (string) {
    return parseHotkey(string, options);
  });
  var check = function check(e) {
    return array.some(function (object) {
      return compareHotkey(object, e);
    });
  };
  var ret = event == null ? check : check(event);
  return ret;
}

function isCodeHotkey(hotkey, event) {
  return isHotkey(hotkey, event);
}

function isKeyHotkey(hotkey, event) {
  return isHotkey(hotkey, { byKey: true }, event);
}

/**
 * Parse.
 */

function parseHotkey(hotkey, options) {
  var byKey = options && options.byKey;
  var ret = {};

  // Special case to handle the `+` key since we use it as a separator.
  hotkey = hotkey.replace('++', '+add');
  var values = hotkey.split('+');
  var length = values.length;

  // Ensure that all the modifiers are set to false unless the hotkey has them.

  for (var k in MODIFIERS) {
    ret[MODIFIERS[k]] = false;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;

      var optional = value.endsWith('?') && value.length > 1;

      if (optional) {
        value = value.slice(0, -1);
      }

      var name = toKeyName(value);
      var modifier = MODIFIERS[name];

      if (length === 1 || !modifier) {
        if (byKey) {
          ret.key = name;
        } else {
          ret.which = toKeyCode(value);
        }
      }

      if (modifier) {
        ret[modifier] = optional ? null : true;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return ret;
}

/**
 * Compare.
 */

function compareHotkey(object, event) {
  for (var key in object) {
    var expected = object[key];
    var actual = void 0;

    if (expected == null) {
      continue;
    }

    if (key === 'key' && event.key != null) {
      actual = event.key.toLowerCase();
    } else if (key === 'which') {
      actual = expected === 91 && event.which === 93 ? 91 : event.which;
    } else {
      actual = event[key];
    }

    if (actual == null && expected === false) {
      continue;
    }

    if (actual !== expected) {
      return false;
    }
  }

  return true;
}

/**
 * Utils.
 */

function toKeyCode(name) {
  name = toKeyName(name);
  var code = CODES[name] || name.toUpperCase().charCodeAt(0);
  return code;
}

function toKeyName(name) {
  name = name.toLowerCase();
  name = ALIASES()[name] || name;
  return name;
}

/**
 * Export.
 */

exports.default = isHotkey;
exports.isHotkey = isHotkey;
exports.isCodeHotkey = isCodeHotkey;
exports.isKeyHotkey = isKeyHotkey;
exports.parseHotkey = parseHotkey;
exports.compareHotkey = compareHotkey;
exports.toKeyCode = toKeyCode;
exports.toKeyName = toKeyName;
});

var isHotkey = unwrapExports(lib);
lib.isHotkey;
lib.isCodeHotkey;
lib.isKeyHotkey;
lib.parseHotkey;
lib.compareHotkey;
lib.toKeyCode;
lib.toKeyName;

const useImageElement = () => useElement(ELEMENT_IMAGE);

const useImageCaptionString = () => {
  const {
    caption: nodeCaption = [{
      children: [{
        text: ''
      }]
    }]
  } = useImageElement();
  return useMemo(() => {
    return getNodeString(nodeCaption[0]) || '';
  }, [nodeCaption]);
};

const useImageCaption = ({
  readOnly,
  ...props
} = {}) => {
  const width = useImageStore().get.width();
  return {
    style: {
      width
    },
    ...props
  };
};
const useImageCaptionState = props => {
  const captionString = useImageCaptionString();
  const selected = useSelected();

  const _readOnly = useReadOnly();

  const readOnly = props.readOnly || _readOnly;
  return {
    captionString,
    selected,
    readOnly
  };
};
const ImageCaption = createComponentAs(props => {
  const htmlProps = useImageCaption(props);
  const {
    captionString,
    selected,
    readOnly
  } = useImageCaptionState(props);

  if (!captionString.length && (readOnly || !selected)) {
    return null;
  }

  return createElementAs('figcaption', htmlProps);
});

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

/**
 * `<textarea />` component for React which grows with content.
 * @see https://github.com/Andarist/react-textarea-autosize
 * @see https://github.com/Andarist/react-textarea-autosize/issues/337
 */

const TextareaAutosize = /*#__PURE__*/forwardRef((props, ref) => {
  const [isRerendered, setIsRerendered] = useState(false);
  useLayoutEffect(() => setIsRerendered(true), []);
  return isRerendered ? /*#__PURE__*/React.createElement(ReactTextareaAutosize, _extends({}, props, {
    ref: ref
  })) : null;
});

/**
 * Focus textareaRef when focusCaptionPath is set to the image path.
 */
const useImageCaptionTextareaFocus = textareaRef => {
  const editor = useEditorRef();
  const element = useImageElement();
  const focusCaptionPath = imageGlobalStore.use.focusEndCaptionPath();
  useEffect(() => {
    if (focusCaptionPath && textareaRef.current) {
      const path = findNodePath(editor, element);

      if (path && Path.equals(path, focusCaptionPath)) {
        textareaRef.current.focus();
        imageGlobalStore.set.focusEndCaptionPath(null);
      }
    }
  }, [editor, element, focusCaptionPath, textareaRef]);
};
const useImageCaptionTextarea = props => {
  const element = useImageElement();
  const {
    caption: nodeCaption = [{
      children: [{
        text: ''
      }]
    }]
  } = element;
  const [captionValue, setCaptionValue] = useState(getNodeString(nodeCaption[0]));
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const textareaRef = useRef(null);
  const ref = useComposedRef(textareaRef, props.ref);
  useImageCaptionTextareaFocus(textareaRef);
  const onChange = useCallback(e => {
    const newValue = e.target.value; // local state

    setCaptionValue(newValue);
    const path = findNodePath(editor, element);
    if (!path) return; // saved state

    setNodes(editor, {
      caption: [{
        text: newValue
      }]
    }, {
      at: path
    });
  }, [editor, element]);

  const onKeyDown = e => {
    // select image
    if (isHotkey('up', e)) {
      const path = findNodePath(editor, element);
      if (!path) return;
      e.preventDefault();
      focusEditor(editor, path);
    } // select next block


    if (isHotkey('down', e)) {
      const path = findNodePath(editor, element);
      if (!path) return;
      const nextNodePath = getPointAfter(editor, path);
      if (!nextNodePath) return;
      e.preventDefault();
      focusEditor(editor, nextNodePath);
    }
  };

  return {
    value: captionValue,
    readOnly,
    onChange,
    onKeyDown,
    ...props,
    ref
  };
};
const ImageCaptionTextarea = createComponentAs(({
  as,
  ...props
}) => {
  const htmlProps = useImageCaptionTextarea({
    as: as,
    ...props
  });
  return /*#__PURE__*/React.createElement(TextareaAutosize, htmlProps);
});

const useImageImg = props => {
  const {
    url
  } = useImageElement();
  const captionString = useImageCaptionString();
  return {
    src: url,
    alt: captionString,
    draggable: true,
    ...props
  };
};
const ImageImg = createComponentAs(props => {
  const htmlProps = useImageImg(props);
  return createElementAs('img', htmlProps);
});

const useImageResizable = ({
  align = 'center',
  readOnly,
  ...props
}) => {
  const element = useImageElement();
  const editor = useEditorRef();

  const _readOnly = useReadOnly();

  readOnly = isDefined(readOnly) ? readOnly : _readOnly;
  const {
    width: nodeWidth = '100%'
  } = element !== null && element !== void 0 ? element : {};
  const [width, setWidth] = useImageStore().use.width();
  const setNodeWidth = useCallback(w => {
    const path = findNodePath(editor, element);
    if (!path) return;

    if (w === nodeWidth) {
      // Focus the node if not resized
      select(editor, path);
    } else {
      setNodes(editor, {
        width: w
      }, {
        at: path
      });
    }
  }, [editor, element, nodeWidth]);
  useEffect(() => {
    setWidth(nodeWidth);
  }, [nodeWidth, setWidth]);
  const defaultProps = {
    minWidth: 92,
    size: {
      width: width,
      height: '100%'
    },
    maxWidth: '100%',
    lockAspectRatio: true,
    resizeRatio: align === 'center' ? 2 : 1,
    enable: {
      left: ['center', 'left'].includes(align),
      right: ['center', 'right'].includes(align)
    },
    handleStyles: {
      left: {
        left: 0
      },
      right: {
        right: 0
      }
    },
    onResize: (e, direction, ref) => {
      setWidth(ref.offsetWidth);
    },
    onResizeStop: (e, direction, ref) => setNodeWidth(ref.offsetWidth)
  };

  if (readOnly) {
    return { ...defaultProps,
      ...props,
      enable: {
        left: false,
        right: false,
        top: false,
        bottom: false,
        topLeft: false,
        bottomLeft: false,
        topRight: false,
        bottomRight: false
      }
    };
  }

  return { ...defaultProps,
    ...props
  };
};
const ImageResizable = createComponentAs(props => {
  const resizableProps = useImageResizable(props);
  return /*#__PURE__*/React.createElement(Resizable, resizableProps);
});

const {
  imageStore,
  useImageStore
} = createAtomStore({
  width: 0
}, {
  name: 'image',
  scope: 'img'
});
const imageGlobalStore = createStore('image')({
  /**
   * When defined, focus end of caption textarea of the image with the same path.
   */
  focusEndCaptionPath: null,

  /**
   * When defined, focus start of caption textarea of the image with the same path.
   */
  focusStartCaptionPath: null
});
const useElementProps = ({
  attributes,
  nodeProps,
  element,
  editor,
  ...props
}) => {
  return { ...attributes,
    ...props,
    ...nodeProps,
    ref: useComposedRef(props.ref, attributes.ref)
  };
};
const ImageRoot = createComponentAs(props => {
  const htmlProps = useElementProps(props);
  return createElementAs('div', htmlProps);
});
const Image = {
  Root: ImageRoot,
  Caption: ImageCaption,
  Img: ImageImg,
  Resizable: ImageResizable,
  CaptionTextarea: ImageCaptionTextarea
};

const insertImage = (editor, url) => {
  const text = {
    text: ''
  };
  const image = {
    type: getPluginType(editor, ELEMENT_IMAGE),
    url: url,
    children: [text]
  };
  insertNodes(editor, image);
};

/**
 * Allows for pasting images from clipboard.
 * Not yet: dragging and dropping images, selecting them through a file system dialog.
 */
const withImageUpload = (editor, plugin) => {
  const {
    options: {
      uploadImage
    }
  } = plugin;
  const {
    insertData
  } = editor;

  editor.insertData = dataTransfer => {
    const text = dataTransfer.getData('text/plain');
    const {
      files
    } = dataTransfer;

    if (files && files.length > 0) {
      const injectedPlugins = getInjectedPlugins(editor, plugin);

      if (!pipeInsertDataQuery(injectedPlugins, {
        data: text,
        dataTransfer
      })) {
        return insertData(dataTransfer);
      }

      for (const file of files) {
        const reader = new FileReader();
        const [mime] = file.type.split('/');

        if (mime === 'image') {
          reader.addEventListener('load', async () => {
            if (!reader.result) {
              return;
            }

            const uploadedUrl = uploadImage ? await uploadImage(reader.result) : reader.result;
            insertImage(editor, uploadedUrl);
          });
          reader.readAsDataURL(file);
        }
      }
    } else {
      insertData(dataTransfer);
    }
  };

  return editor;
};

const ELEMENT_IMAGE = 'img';
/**
 * Enables support for images.
 */

const createImagePlugin = createPluginFactory({
  key: ELEMENT_IMAGE,
  isElement: true,
  isVoid: true,
  withOverrides: withImageUpload,
  handlers: {
    onKeyDown: editor => e => {
      // focus caption from image
      if (isHotkey('down', e)) {
        const entry = getBlockAbove(editor, {
          match: {
            type: getPluginType(editor, ELEMENT_IMAGE)
          }
        });
        if (!entry) return;
        imageGlobalStore.set.focusEndCaptionPath(entry[1]);
      } // TODO: focus caption from line below image
      // if (isHotkey('up', e)) {
      // }

    }
  },
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      rules: [{
        validNodeName: 'IMG'
      }],
      getNode: el => ({
        type,
        url: el.getAttribute('src')
      })
    }
  })
});

const imageExtensions = ['ase', 'art', 'bmp', 'blp', 'cd5', 'cit', 'cpt', 'cr2', 'cut', 'dds', 'dib', 'djvu', 'egt', 'exif', 'gif', 'gpl', 'grf', 'icns', 'ico', 'iff', 'jng', 'jpeg', 'jpg', 'jfif', 'jp2', 'jps', 'lbm', 'max', 'miff', 'mng', 'msp', 'nitf', 'ota', 'pbm', 'pc1', 'pc2', 'pc3', 'pcf', 'pcx', 'pdn', 'pgm', 'PI1', 'PI2', 'PI3', 'pict', 'pct', 'pnm', 'pns', 'ppm', 'psb', 'psd', 'pdd', 'psp', 'px', 'pxm', 'pxr', 'qfx', 'raw', 'rle', 'sct', 'sgi', 'rgb', 'int', 'bw', 'tga', 'tiff', 'tif', 'vtf', 'xbm', 'xcf', 'xpm', '3dv', 'amf', 'ai', 'awg', 'cgm', 'cdr', 'cmx', 'dxf', 'e2d', 'egt', 'eps', 'fs', 'gbr', 'odg', 'svg', 'stl', 'vrml', 'x3d', 'sxd', 'v2d', 'vnd', 'wmf', 'emf', 'art', 'xar', 'png', 'webp', 'jxr', 'hdp', 'wdp', 'cur', 'ecw', 'iff', 'lbm', 'liff', 'nrrd', 'pam', 'pcx', 'pgf', 'sgi', 'rgb', 'rgba', 'bw', 'int', 'inta', 'sid', 'ras', 'sun', 'tga'];
const isImageUrl = url => {
  if (!isUrl(url)) return false;
  const ext = new URL(url).pathname.split('.').pop();
  return imageExtensions.includes(ext);
};

/**
 * If inserted text is image url, insert image instead.
 */
const withImageEmbed = (editor, plugin) => {
  const {
    insertData
  } = editor;

  editor.insertData = dataTransfer => {
    const text = dataTransfer.getData('text/plain');

    if (isImageUrl(text)) {
      insertImage(editor, text);
      return;
    }

    insertData(dataTransfer);
  };

  return editor;
};

/**
 * @see withImageUpload
 * @see withImageEmbed
 */

const withImage = (editor, plugin) => {
  const {
    options: {
      disableUploadInsert,
      disableEmbedInsert
    }
  } = plugin;

  if (!disableUploadInsert) {
    editor = withImageUpload(editor, plugin);
  }

  if (!disableEmbedInsert) {
    editor = withImageEmbed(editor);
  }

  return editor;
};

export { ELEMENT_IMAGE, Image, ImageCaption, ImageCaptionTextarea, ImageImg, ImageResizable, ImageRoot, TextareaAutosize, createImagePlugin, imageGlobalStore, imageStore, insertImage, isImageUrl, useElementProps, useImageCaption, useImageCaptionState, useImageCaptionString, useImageCaptionTextarea, useImageCaptionTextareaFocus, useImageElement, useImageImg, useImageResizable, useImageStore, withImage, withImageEmbed, withImageUpload };
//# sourceMappingURL=index.es.js.map
