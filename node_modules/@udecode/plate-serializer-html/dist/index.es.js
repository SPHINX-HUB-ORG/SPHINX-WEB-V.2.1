import { renderToStaticMarkup } from 'react-dom/server';
import { withTReact, createTEditor, pipeInjectProps, pluginRenderElement, pluginRenderLeaf, isText } from '@udecode/plate-common';
import { decode, encode } from 'html-entities';
import React from 'react';
import { Slate } from 'slate-react';

/**
 * Create a React element wrapped in a Slate provider.
 * By default, it will use an empty editor.
 * TODO: allow other providers
 */

const createElementWithSlate = (slateProps, dndWrapper) => {
  const {
    editor = withTReact(createTEditor()),
    value = [],
    onChange = () => {},
    children,
    ...props
  } = slateProps || {};

  if (dndWrapper) {
    return /*#__PURE__*/React.createElement(dndWrapper, null, /*#__PURE__*/React.createElement(Slate, {
      editor,
      value,
      onChange,
      ...props
    }, children));
  }

  return /*#__PURE__*/React.createElement(Slate, {
    editor,
    value,
    onChange,
    ...props
  }, children);
};

/**
 * Remove all class names that do not start with one of preserveClassNames (`slate-` by default)
 */
const stripClassNames = (html, {
  preserveClassNames = ['slate-']
}) => {
  const allClasses = html.split(/(class="[^"]*")/g);
  let filteredHtml = '';
  allClasses.forEach((item, index) => {
    if (index % 2 === 0) {
      return filteredHtml += item;
    }

    const preserveRegExp = new RegExp(preserveClassNames.map(cn => `${cn}[^"\\s]*`).join('|'), 'g');
    const classNames = item.split('"')[1].match(preserveRegExp);

    if (classNames) {
      filteredHtml += `class="${classNames.join(' ')}"`;
    }
  });
  return filteredHtml;
};

const elementToHtml = (editor, {
  props,
  slateProps,
  preserveClassNames,
  dndWrapper
}) => {
  let html = `<div>${props.children}</div>`; // If no type provided we wrap children with div tag

  if (!props.element.type) {
    return html;
  }

  props = pipeInjectProps(editor, props); // Search for matching plugin based on element type

  editor.plugins.some(plugin => {
    var _plugin$serializeHtml, _plugin$serializeHtml2;

    if (!plugin.isElement || plugin.serializeHtml === null || props.element.type !== plugin.type) return false; // Render element using picked plugins renderElement function and ReactDOM

    html = decode(renderToStaticMarkup(createElementWithSlate({ ...slateProps,
      children: (_plugin$serializeHtml = (_plugin$serializeHtml2 = plugin.serializeHtml) === null || _plugin$serializeHtml2 === void 0 ? void 0 : _plugin$serializeHtml2.call(plugin, props)) !== null && _plugin$serializeHtml !== void 0 ? _plugin$serializeHtml : pluginRenderElement(editor, plugin)(props)
    }, dndWrapper)));
    html = stripClassNames(html, {
      preserveClassNames
    });
    return true;
  });
  return html;
};

const leafToHtml = (editor, {
  props,
  slateProps,
  preserveClassNames
}) => {
  const {
    children
  } = props;
  return editor.plugins.reduce((result, plugin) => {
    var _plugin$serializeHtml, _plugin$serializeHtml2;

    if (!plugin.isLeaf) return result;
    props = { ...pipeInjectProps(editor, props),
      children: result
    };
    const serialized = (_plugin$serializeHtml = (_plugin$serializeHtml2 = plugin.serializeHtml) === null || _plugin$serializeHtml2 === void 0 ? void 0 : _plugin$serializeHtml2.call(plugin, props)) !== null && _plugin$serializeHtml !== void 0 ? _plugin$serializeHtml : pluginRenderLeaf(editor, plugin)(props);
    if (serialized === children) return result;
    let html = decode(renderToStaticMarkup(createElementWithSlate({ ...slateProps,
      children: serialized
    })));
    html = stripClassNames(html, {
      preserveClassNames
    });
    return html;
  }, children);
};

// Convert new line characters to HTML <br /> tags
const newLinesToHtmlBr = html => html.replace(/\n/g, '<br />');

// Remove redundant data attributes
const stripSlateDataAttributes = rawHtml => rawHtml.replace(/( data-slate)(-node|-type|-leaf)="[^"]+"/gm, '').replace(/( data-testid)="[^"]+"/gm, '');

// Remove extra whitespace generated by ReactDOMServer
const trimWhitespace = rawHtml => rawHtml.replace(/(\r\n|\n|\r|\t)/gm, '');

/**
 * Convert Slate Nodes into HTML string
 */

const serializeHtml = (editor, {
  nodes,
  slateProps,
  stripDataAttributes = true,
  preserveClassNames,
  stripWhitespace = true,
  convertNewLinesToHtmlBr = false,
  dndWrapper
}) => {
  let result = nodes.map(node => {
    if (isText(node)) {
      const children = encode(node.text);
      return leafToHtml(editor, {
        props: {
          leaf: node,
          text: node,
          children: convertNewLinesToHtmlBr ? newLinesToHtmlBr(children) : children,
          attributes: {
            'data-slate-leaf': true
          },
          editor
        },
        slateProps,
        preserveClassNames
      });
    }

    return elementToHtml(editor, {
      props: {
        element: node,
        children: serializeHtml(editor, {
          nodes: node.children,
          preserveClassNames,
          stripWhitespace,
          convertNewLinesToHtmlBr
        }),
        attributes: {
          'data-slate-node': 'element',
          ref: null
        },
        editor
      },
      slateProps,
      preserveClassNames,
      dndWrapper
    });
  }).join('');

  if (stripWhitespace) {
    result = trimWhitespace(result);
  }

  if (stripDataAttributes) {
    result = stripSlateDataAttributes(result);
  }

  return result;
};

export { createElementWithSlate, elementToHtml, leafToHtml, newLinesToHtmlBr, serializeHtml, stripClassNames, stripSlateDataAttributes, trimWhitespace };
//# sourceMappingURL=index.es.js.map
