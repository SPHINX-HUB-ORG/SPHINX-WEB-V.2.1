import { someNode, getPluginType, getAboveNode, withoutNormalizing, removeNodes, setNodes, insertNodes, getBlockAbove, selectEditor, getStartPoint, getPluginTypes, findNode, getPluginOptions, insertElements, select, getNode, getEdgeBlocksAbove, hasNode, moveSelection, getEndPoint, isRangeAcrossBlocks, isRangeInSameBlock, getNodeEntry, isElement, findNodePath, getParentNode, Hotkeys, isCollapsed, replaceNodeChildren, getPointBefore, getPointAfter, getTEditor, isExpanded, collapseSelection, unwrapNodes, isText, wrapNodeChildren, createPluginFactory, createAtomStore, useEditorRef, unsetNodes, createComponentAs, usePlateEditorRef, useElement, createElementAs, useElementProps, Box, focusEditor, usePlateEditorState } from '@udecode/plate-common';
import { Path, Point, Range } from 'slate';
import React, { useCallback, useEffect, useMemo } from 'react';
import { ResizeHandle, resizeLengthClampStatic } from '@udecode/resizable';
import { useReadOnly, useSelected } from 'slate-react';

const keyShiftEdges = {
  'shift+up': 'top',
  'shift+right': 'right',
  'shift+down': 'bottom',
  'shift+left': 'left'
};

const deleteColumn = editor => {
  if (someNode(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_TABLE)
    }
  })) {
    const tdEntry = getAboveNode(editor, {
      match: {
        type: [getPluginType(editor, ELEMENT_TD), getPluginType(editor, ELEMENT_TH)]
      }
    });
    const trEntry = getAboveNode(editor, {
      match: {
        type: getPluginType(editor, ELEMENT_TR)
      }
    });
    const tableEntry = getAboveNode(editor, {
      match: {
        type: getPluginType(editor, ELEMENT_TABLE)
      }
    });

    if (tdEntry && trEntry && tableEntry && // Cannot delete the last cell
    trEntry[0].children.length > 1) {
      const [tableNode, tablePath] = tableEntry;
      const tdPath = tdEntry[1];
      const colIndex = tdPath[tdPath.length - 1];
      const pathToDelete = tdPath.slice();
      const replacePathPos = pathToDelete.length - 2;
      withoutNormalizing(editor, () => {
        tableEntry[0].children.forEach((row, rowIdx) => {
          pathToDelete[replacePathPos] = rowIdx; // for rows with different lengths

          if (row.children.length < replacePathPos + 1) return;
          removeNodes(editor, {
            at: pathToDelete
          });
        });
        const {
          colSizes
        } = tableNode;

        if (colSizes) {
          const newColSizes = [...colSizes];
          newColSizes.splice(colIndex, 1);
          setNodes(editor, {
            colSizes: newColSizes
          }, {
            at: tablePath
          });
        }
      });
    }
  }
};

const deleteRow = editor => {
  if (someNode(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_TABLE)
    }
  })) {
    const currentTableItem = getAboveNode(editor, {
      match: {
        type: getPluginType(editor, ELEMENT_TABLE)
      }
    });
    const currentRowItem = getAboveNode(editor, {
      match: {
        type: getPluginType(editor, ELEMENT_TR)
      }
    });

    if (currentRowItem && currentTableItem && // Cannot delete the last row
    currentTableItem[0].children.length > 1) {
      removeNodes(editor, {
        at: currentRowItem[1]
      });
    }
  }
};

const deleteTable = editor => {
  if (someNode(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_TABLE)
    }
  })) {
    const tableItem = getAboveNode(editor, {
      match: {
        type: getPluginType(editor, ELEMENT_TABLE)
      }
    });

    if (tableItem) {
      removeNodes(editor, {
        at: tableItem[1]
      });
    }
  }
};

const getEmptyCellNode = (editor, {
  header,
  newCellChildren = [editor.blockFactory()]
}) => {
  return {
    type: header ? getPluginType(editor, ELEMENT_TH) : getPluginType(editor, ELEMENT_TD),
    children: newCellChildren
  };
};

const getEmptyRowNode = (editor, {
  colCount,
  ...options
} = {}) => {
  return {
    type: getPluginType(editor, ELEMENT_TR),
    children: Array(colCount).fill(colCount).map(() => getEmptyCellNode(editor, options))
  };
};

const getEmptyTableNode = (editor, {
  header,
  rowCount = 0,
  colCount,
  newCellChildren
} = {}) => {
  const rows = Array(rowCount).fill(rowCount).map(() => getEmptyRowNode(editor, {
    header,
    colCount,
    newCellChildren
  }));
  return {
    type: getPluginType(editor, ELEMENT_TABLE),
    children: rows
  };
};

/**
 * Insert table if selection not in table.
 * Select start of table.
 */

const insertTable = (editor, {
  rowCount = 2,
  colCount = 2,
  header
}) => {
  withoutNormalizing(editor, () => {
    if (!someNode(editor, {
      match: {
        type: getPluginType(editor, ELEMENT_TABLE)
      }
    })) {
      insertNodes(editor, getEmptyTableNode(editor, {
        header,
        rowCount,
        colCount
      }));

      if (editor.selection) {
        const tableEntry = getBlockAbove(editor, {
          match: {
            type: getPluginType(editor, ELEMENT_TABLE)
          }
        });
        if (!tableEntry) return;
        selectEditor(editor, {
          at: getStartPoint(editor, tableEntry[1])
        });
      }
    }
  });
};

/**
 * Get td and th types
 */

const getCellTypes = editor => getPluginTypes(editor, [ELEMENT_TD, ELEMENT_TH]);

const insertTableColumn = (editor, {
  disableSelect,
  fromCell,
  at,
  header
} = {}) => {
  const cellEntry = fromCell ? findNode(editor, {
    at: fromCell,
    match: {
      type: getCellTypes(editor)
    }
  }) : getBlockAbove(editor, {
    match: {
      type: getCellTypes(editor)
    }
  });
  if (!cellEntry) return;
  const [, cellPath] = cellEntry;
  const tableEntry = getBlockAbove(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_TABLE)
    },
    at: cellPath
  });
  if (!tableEntry) return;
  const [tableNode, tablePath] = tableEntry;
  let nextCellPath;
  let nextColIndex;

  if (Path.isPath(at)) {
    nextCellPath = at;
    nextColIndex = at[at.length - 1];
  } else {
    nextCellPath = Path.next(cellPath);
    nextColIndex = cellPath[cellPath.length - 1] + 1;
  }

  const currentRowIndex = cellPath[cellPath.length - 2];
  const {
    newCellChildren,
    initialTableWidth,
    minColumnWidth
  } = getPluginOptions(editor, ELEMENT_TABLE);
  withoutNormalizing(editor, () => {
    // for each row, insert a new cell
    tableNode.children.forEach((row, rowIndex) => {
      const insertCellPath = [...nextCellPath];

      if (Path.isPath(at)) {
        insertCellPath[at.length - 2] = rowIndex;
      } else {
        insertCellPath[cellPath.length - 2] = rowIndex;
      }

      const isHeaderRow = header === undefined ? row.children[0].type === getPluginType(editor, ELEMENT_TH) : header;
      insertElements(editor, getEmptyCellNode(editor, {
        header: isHeaderRow,
        newCellChildren
      }), {
        at: insertCellPath,
        select: !disableSelect && rowIndex === currentRowIndex
      });
    });
    const {
      colSizes
    } = tableNode;

    if (colSizes) {
      let newColSizes = [...colSizes.slice(0, nextColIndex), 0, ...colSizes.slice(nextColIndex)];

      if (initialTableWidth) {
        var _ref, _colSizes$nextColInde;

        newColSizes[nextColIndex] = (_ref = (_colSizes$nextColInde = colSizes[nextColIndex]) !== null && _colSizes$nextColInde !== void 0 ? _colSizes$nextColInde : colSizes[nextColIndex - 1]) !== null && _ref !== void 0 ? _ref : initialTableWidth / colSizes.length;
        const oldTotal = colSizes.reduce((a, b) => a + b, 0);
        const newTotal = newColSizes.reduce((a, b) => a + b, 0);
        const maxTotal = Math.max(oldTotal, initialTableWidth);

        if (newTotal > maxTotal) {
          const factor = maxTotal / newTotal;
          newColSizes = newColSizes.map(size => Math.max(minColumnWidth !== null && minColumnWidth !== void 0 ? minColumnWidth : 0, Math.floor(size * factor)));
        }
      }

      setNodes(editor, {
        colSizes: newColSizes
      }, {
        at: tablePath
      });
    }
  });
};

const insertTableRow = (editor, {
  header,
  fromRow,
  at,
  disableSelect
} = {}) => {
  const trEntry = fromRow ? findNode(editor, {
    at: fromRow,
    match: {
      type: getPluginType(editor, ELEMENT_TR)
    }
  }) : getBlockAbove(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_TR)
    }
  });
  if (!trEntry) return;
  const [trNode, trPath] = trEntry;
  const tableEntry = getBlockAbove(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_TABLE)
    },
    at: trPath
  });
  if (!tableEntry) return;
  const {
    newCellChildren
  } = getPluginOptions(editor, ELEMENT_TABLE);
  withoutNormalizing(editor, () => {
    insertElements(editor, getEmptyRowNode(editor, {
      header,
      colCount: trNode.children.length,
      newCellChildren
    }), {
      at: Path.isPath(at) ? at : Path.next(trPath)
    });
  });

  if (!disableSelect) {
    const cellEntry = getBlockAbove(editor, {
      match: {
        type: getCellTypes(editor)
      }
    });
    if (!cellEntry) return;
    const [, nextCellPath] = cellEntry;

    if (Path.isPath(at)) {
      nextCellPath[nextCellPath.length - 2] = at[at.length - 2];
    } else {
      nextCellPath[nextCellPath.length - 2] += 1;
    }

    select(editor, nextCellPath);
  }
};

/**
 * Get sub table between 2 cell paths.
 */
const getTableGridByRange = (editor, {
  at,
  format = 'table'
}) => {
  const startCellPath = at.anchor.path;
  const endCellPath = at.focus.path;
  const _startRowIndex = startCellPath[startCellPath.length - 2];
  const _endRowIndex = endCellPath[endCellPath.length - 2];
  const _startColIndex = startCellPath[startCellPath.length - 1];
  const _endColIndex = endCellPath[endCellPath.length - 1];
  const startRowIndex = Math.min(_startRowIndex, _endRowIndex);
  const endRowIndex = Math.max(_startRowIndex, _endRowIndex);
  const startColIndex = Math.min(_startColIndex, _endColIndex);
  const endColIndex = Math.max(_startColIndex, _endColIndex);
  const tablePath = startCellPath.slice(0, -2);
  const relativeRowIndex = endRowIndex - startRowIndex;
  const relativeColIndex = endColIndex - startColIndex;
  const table = getEmptyTableNode(editor, {
    rowCount: relativeRowIndex + 1,
    colCount: relativeColIndex + 1,
    newCellChildren: []
  });
  let rowIndex = startRowIndex;
  let colIndex = startColIndex;
  const cellEntries = [];

  while (true) {
    const cellPath = tablePath.concat([rowIndex, colIndex]);
    const cell = getNode(editor, cellPath);
    if (!cell) break;
    const rows = table.children[rowIndex - startRowIndex].children;
    rows[colIndex - startColIndex] = cell;
    cellEntries.push([cell, cellPath]);

    if (colIndex + 1 <= endColIndex) {
      colIndex += 1;
    } else if (rowIndex + 1 <= endRowIndex) {
      colIndex = startColIndex;
      rowIndex += 1;
    } else {
      break;
    }
  }

  if (format === 'cell') {
    return cellEntries;
  }

  return [[table, tablePath]];
};

/**
 * Get sub table above anchor and focus.
 * Format: tables or cells.
 */
const getTableGridAbove = (editor, {
  format = 'table',
  ...options
} = {}) => {
  const edges = getEdgeBlocksAbove(editor, {
    match: {
      type: getCellTypes(editor)
    },
    ...options
  });

  if (edges) {
    const [start, end] = edges;

    if (!Path.equals(start[1], end[1])) {
      return getTableGridByRange(editor, {
        at: {
          anchor: {
            path: start[1],
            offset: 0
          },
          focus: {
            path: end[1],
            offset: 0
          }
        },
        format
      });
    }

    if (format === 'table') {
      const table = getEmptyTableNode(editor, {
        rowCount: 1
      });
      table.children[0].children = [start[0]];
      return [[table, start[1].slice(0, -2)]];
    }

    return [start];
  }

  return [];
};

/**
 * Move selection by cell unit.
 */

const moveSelectionFromCell = (editor, {
  at,
  reverse,
  edge,
  fromOneCell
} = {}) => {
  if (edge) {
    const cellEntries = getTableGridAbove(editor, {
      at,
      format: 'cell'
    });
    const minCell = fromOneCell ? 0 : 1;

    if (cellEntries.length > minCell) {
      const [, firstCellPath] = cellEntries[0];
      const [, lastCellPath] = cellEntries[cellEntries.length - 1];
      const anchorPath = [...firstCellPath];
      const focusPath = [...lastCellPath];

      if (edge === 'bottom') {
        focusPath[focusPath.length - 2] += 1;
      } else if (edge === 'top') {
        anchorPath[anchorPath.length - 2] -= 1;
      } else if (edge === 'right') {
        focusPath[focusPath.length - 1] += 1;
      } else if (edge === 'left') {
        anchorPath[anchorPath.length - 1] -= 1;
      }

      if (hasNode(editor, anchorPath) && hasNode(editor, focusPath)) {
        select(editor, {
          anchor: getStartPoint(editor, anchorPath),
          focus: getStartPoint(editor, focusPath)
        });
      }

      return true;
    }

    return;
  }

  const cellEntry = getBlockAbove(editor, {
    at,
    match: {
      type: getCellTypes(editor)
    }
  });

  if (cellEntry) {
    const [, cellPath] = cellEntry;
    const nextCellPath = [...cellPath];
    const offset = reverse ? -1 : 1;
    nextCellPath[nextCellPath.length - 2] += offset;

    if (hasNode(editor, nextCellPath)) {
      select(editor, getStartPoint(editor, nextCellPath));
    } else {
      const tablePath = cellPath.slice(0, -2);

      if (reverse) {
        withoutNormalizing(editor, () => {
          select(editor, getStartPoint(editor, tablePath));
          moveSelection(editor, {
            reverse: true
          });
        });
      } else {
        withoutNormalizing(editor, () => {
          select(editor, getEndPoint(editor, tablePath));
          moveSelection(editor);
        });
      }
    }

    return true;
  }
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var lib = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Constants.
 */

// We make this a function so it can be tested in describe block mocks with Jest.
var IS_MAC = () => typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);

var MODIFIERS = {
  alt: 'altKey',
  control: 'ctrlKey',
  meta: 'metaKey',
  shift: 'shiftKey'
};

// We make this a function so it can be tested in describe block mocks with Jest.
var ALIASES = () => ({
  add: '+',
  break: 'pause',
  cmd: 'meta',
  command: 'meta',
  ctl: 'control',
  ctrl: 'control',
  del: 'delete',
  down: 'arrowdown',
  esc: 'escape',
  ins: 'insert',
  left: 'arrowleft',
  mod: IS_MAC() ? 'meta' : 'control',
  opt: 'alt',
  option: 'alt',
  return: 'enter',
  right: 'arrowright',
  space: ' ',
  spacebar: ' ',
  up: 'arrowup',
  win: 'meta',
  windows: 'meta'
});

var CODES = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  ' ': 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ';': 186,
  '=': 187,
  ',': 188,
  '-': 189,
  '.': 190,
  '/': 191,
  '`': 192,
  '[': 219,
  '\\': 220,
  ']': 221,
  '\'': 222
};

for (var f = 1; f < 20; f++) {
  CODES['f' + f] = 111 + f;
}

/**
 * Is hotkey?
 */

function isHotkey(hotkey, options, event) {
  if (options && !('byKey' in options)) {
    event = options;
    options = null;
  }

  if (!Array.isArray(hotkey)) {
    hotkey = [hotkey];
  }

  var array = hotkey.map(function (string) {
    return parseHotkey(string, options);
  });
  var check = function check(e) {
    return array.some(function (object) {
      return compareHotkey(object, e);
    });
  };
  var ret = event == null ? check : check(event);
  return ret;
}

function isCodeHotkey(hotkey, event) {
  return isHotkey(hotkey, event);
}

function isKeyHotkey(hotkey, event) {
  return isHotkey(hotkey, { byKey: true }, event);
}

/**
 * Parse.
 */

function parseHotkey(hotkey, options) {
  var byKey = options && options.byKey;
  var ret = {};

  // Special case to handle the `+` key since we use it as a separator.
  hotkey = hotkey.replace('++', '+add');
  var values = hotkey.split('+');
  var length = values.length;

  // Ensure that all the modifiers are set to false unless the hotkey has them.

  for (var k in MODIFIERS) {
    ret[MODIFIERS[k]] = false;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;

      var optional = value.endsWith('?') && value.length > 1;

      if (optional) {
        value = value.slice(0, -1);
      }

      var name = toKeyName(value);
      var modifier = MODIFIERS[name];

      if (length === 1 || !modifier) {
        if (byKey) {
          ret.key = name;
        } else {
          ret.which = toKeyCode(value);
        }
      }

      if (modifier) {
        ret[modifier] = optional ? null : true;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return ret;
}

/**
 * Compare.
 */

function compareHotkey(object, event) {
  for (var key in object) {
    var expected = object[key];
    var actual = void 0;

    if (expected == null) {
      continue;
    }

    if (key === 'key' && event.key != null) {
      actual = event.key.toLowerCase();
    } else if (key === 'which') {
      actual = expected === 91 && event.which === 93 ? 91 : event.which;
    } else {
      actual = event[key];
    }

    if (actual == null && expected === false) {
      continue;
    }

    if (actual !== expected) {
      return false;
    }
  }

  return true;
}

/**
 * Utils.
 */

function toKeyCode(name) {
  name = toKeyName(name);
  var code = CODES[name] || name.toUpperCase().charCodeAt(0);
  return code;
}

function toKeyName(name) {
  name = name.toLowerCase();
  name = ALIASES()[name] || name;
  return name;
}

/**
 * Export.
 */

exports.default = isHotkey;
exports.isHotkey = isHotkey;
exports.isCodeHotkey = isCodeHotkey;
exports.isKeyHotkey = isKeyHotkey;
exports.parseHotkey = parseHotkey;
exports.compareHotkey = compareHotkey;
exports.toKeyCode = toKeyCode;
exports.toKeyName = toKeyName;
});

var isHotkey = unwrapExports(lib);
lib.isHotkey;
lib.isCodeHotkey;
lib.isKeyHotkey;
lib.parseHotkey;
lib.compareHotkey;
lib.toKeyCode;
lib.toKeyName;

/**
 * Override the new selection if the previous selection and the new one are in different cells.
 */

const overrideSelectionFromCell = (editor, newSelection) => {
  var _editor$selection;

  let hotkey;

  if (!editor.currentKeyboardEvent || !['up', 'down', 'shift+up', 'shift+right', 'shift+down', 'shift+left'].some(key => {
    const valid = isHotkey(key, editor.currentKeyboardEvent);
    if (valid) hotkey = key;
    return valid;
  }) || !((_editor$selection = editor.selection) !== null && _editor$selection !== void 0 && _editor$selection.focus) || !(newSelection !== null && newSelection !== void 0 && newSelection.focus) || !isRangeAcrossBlocks(editor, {
    at: {
      anchor: editor.selection.focus,
      focus: newSelection.focus
    },
    match: {
      type: getCellTypes(editor)
    }
  })) {
    return;
  }

  if (!hotkey) return;
  const edge = keyShiftEdges[hotkey]; // if the previous selection was in many cells, return

  if (edge && !isRangeInSameBlock(editor, {
    at: editor.selection,
    match: {
      type: getCellTypes(editor)
    }
  })) {
    return;
  }

  const prevSelection = editor.selection;
  const reverse = ['up', 'shift+up'].includes(hotkey);
  setTimeout(() => {
    moveSelectionFromCell(editor, {
      at: prevSelection,
      reverse,
      edge,
      fromOneCell: true
    });
  }, 0);
};

const getLeftTableCell = (editor, {
  at: cellPath
} = {}) => {
  if (!cellPath) {
    var _findNode;

    cellPath = (_findNode = findNode(editor, {
      match: {
        type: getCellTypes(editor)
      }
    })) === null || _findNode === void 0 ? void 0 : _findNode[1];
    if (!cellPath) return;
  }

  const cellIndex = cellPath[cellPath.length - 1];
  if (!cellIndex) return;
  const prevCellPath = Path.previous(cellPath);
  return getNodeEntry(editor, prevCellPath);
};

const getTopTableCell = (editor, {
  at: cellPath
} = {}) => {
  if (!cellPath) {
    var _findNode;

    cellPath = (_findNode = findNode(editor, {
      match: {
        type: getCellTypes(editor)
      }
    })) === null || _findNode === void 0 ? void 0 : _findNode[1];
    if (!cellPath) return;
  }

  const cellIndex = cellPath[cellPath.length - 1];
  const rowIndex = cellPath[cellPath.length - 2]; // If the current cell is in the first row, there is no cell above it

  if (rowIndex === 0) return;
  const cellAbovePath = [...Path.parent(Path.parent(cellPath)), rowIndex - 1, cellIndex];
  return getNodeEntry(editor, cellAbovePath);
};

const setBorderSize = (editor, size, {
  at,
  border = 'all'
} = {}) => {
  const cellEntry = findNode(editor, {
    at,
    match: {
      type: getCellTypes(editor)
    }
  });
  if (!cellEntry) return;
  const [cellNode, cellPath] = cellEntry;
  const cellIndex = cellPath[cellPath.length - 1];
  const rowIndex = cellPath[cellPath.length - 2]; // Default hidden border style

  const borderStyle = {
    size
  };
  const setNodesOptions = {
    match: n => isElement(n) && getCellTypes(editor).includes(n.type)
  };

  if (border === 'top') {
    const isFirstRow = rowIndex === 0;

    if (isFirstRow) {
      const newBorders = { ...cellNode.borders,
        top: borderStyle
      };
      setNodes(editor, {
        borders: newBorders
      }, {
        at: cellPath,
        ...setNodesOptions
      });
      return;
    }

    const cellAboveEntry = getTopTableCell(editor, {
      at: cellPath
    });
    if (!cellAboveEntry) return;
    const [cellAboveNode, cellAbovePath] = cellAboveEntry;
    const newBorders = { ...cellAboveNode.borders,
      bottom: borderStyle
    }; // Update the bottom border of the cell above

    setNodes(editor, {
      borders: newBorders
    }, {
      at: cellAbovePath,
      ...setNodesOptions
    });
  } else if (border === 'bottom') {
    const newBorders = { ...cellNode.borders,
      bottom: borderStyle
    }; // Update the bottom border of the current cell

    setNodes(editor, {
      borders: newBorders
    }, {
      at: cellPath,
      ...setNodesOptions
    });
  }

  if (border === 'left') {
    const isFirstCell = cellIndex === 0;

    if (isFirstCell) {
      const newBorders = { ...cellNode.borders,
        left: borderStyle
      };
      setNodes(editor, {
        borders: newBorders
      }, {
        at: cellPath,
        ...setNodesOptions
      });
      return;
    }

    const prevCellEntry = getLeftTableCell(editor, {
      at: cellPath
    });
    if (!prevCellEntry) return;
    const [prevCellNode, prevCellPath] = prevCellEntry;
    const newBorders = { ...prevCellNode.borders,
      right: borderStyle
    }; // Update the bottom border of the cell above

    setNodes(editor, {
      borders: newBorders
    }, {
      at: prevCellPath,
      ...setNodesOptions
    });
  } else if (border === 'right') {
    const newBorders = { ...cellNode.borders,
      right: borderStyle
    }; // Update the right border of the current cell

    setNodes(editor, {
      borders: newBorders
    }, {
      at: cellPath,
      ...setNodesOptions
    });
  }

  if (border === 'all') {
    withoutNormalizing(editor, () => {
      setBorderSize(editor, size, {
        at,
        border: 'top'
      });
      setBorderSize(editor, size, {
        at,
        border: 'bottom'
      });
      setBorderSize(editor, size, {
        at,
        border: 'left'
      });
      setBorderSize(editor, size, {
        at,
        border: 'right'
      });
    });
  }
};

const getTableColumnCount = tableNode => {
  var _$children$length, _, _$children;

  return (_$children$length = (_ = tableNode.children[0]) === null || _ === void 0 ? void 0 : (_$children = _.children) === null || _$children === void 0 ? void 0 : _$children.length) !== null && _$children$length !== void 0 ? _$children$length : 0;
};

const setTableColSize = (editor, {
  colIndex,
  width
}, options = {}) => {
  const table = findNode(editor, {
    match: {
      type: ELEMENT_TABLE
    },
    ...options
  });
  if (!table) return;
  const [tableNode, tablePath] = table;
  const colSizes = tableNode.colSizes ? [...tableNode.colSizes] : Array(getTableColumnCount(tableNode)).fill(0);
  colSizes[colIndex] = width;
  setNodes(editor, {
    colSizes
  }, {
    at: tablePath
  });
};

const setTableMarginLeft = (editor, {
  marginLeft
}, options = {}) => {
  const table = findNode(editor, {
    match: {
      type: ELEMENT_TABLE
    },
    ...options
  });
  if (!table) return;
  const [, tablePath] = table;
  setNodes(editor, {
    marginLeft
  }, {
    at: tablePath
  });
};

const setTableRowSize = (editor, {
  rowIndex,
  height
}, options = {}) => {
  const table = findNode(editor, {
    match: {
      type: ELEMENT_TABLE
    },
    ...options
  });
  if (!table) return;
  const [, tablePath] = table;
  const tableRowPath = [...tablePath, rowIndex];
  setNodes(editor, {
    size: height
  }, {
    at: tableRowPath
  });
};

const getCellInNextTableRow = (editor, currentRowPath) => {
  var _nextRowNode$children;

  const nextRow = getNodeEntry(editor, Path.next(currentRowPath));
  if (!nextRow) return; // TODO: Many tables in rich text editors (Google Docs, Word),
  // add a new row if we're in the last cell. Should we do the same?

  const [nextRowNode, nextRowPath] = nextRow;
  const nextCell = nextRowNode === null || nextRowNode === void 0 ? void 0 : (_nextRowNode$children = nextRowNode.children) === null || _nextRowNode$children === void 0 ? void 0 : _nextRowNode$children[0];
  const nextCellPath = nextRowPath.concat(0);

  if (nextCell && nextCellPath) {
    return getNodeEntry(editor, nextCellPath);
  }
};

const getCellInPreviousTableRow = (editor, currentRowPath) => {
  var _previousRowNode$chil;

  const previousRow = getNodeEntry(editor, Path.previous(currentRowPath));
  if (!previousRow) return;
  const [previousRowNode, previousRowPath] = previousRow;
  const previousCell = previousRowNode === null || previousRowNode === void 0 ? void 0 : (_previousRowNode$chil = previousRowNode.children) === null || _previousRowNode$chil === void 0 ? void 0 : _previousRowNode$chil[previousRowNode.children.length - 1];
  const previousCellPath = previousRowPath.concat(previousRowNode.children.length - 1);

  if (previousCell && previousCellPath) {
    return getNodeEntry(editor, previousCellPath);
  }
};

const getNextTableCell = (editor, currentCell, currentPath, currentRow) => {
  const cell = getNodeEntry(editor, Path.next(currentPath));
  if (cell) return cell;
  const [, currentRowPath] = currentRow;
  return getCellInNextTableRow(editor, currentRowPath);
};

const getPreviousTableCell = (editor, currentCell, currentPath, currentRow) => {
  const cell = getNodeEntry(editor, Path.previous(currentPath));
  if (cell) return cell;
  const [, currentRowPath] = currentRow;
  return getCellInPreviousTableRow(editor, currentRowPath);
};

const getTableAbove = (editor, options) => getBlockAbove(editor, {
  match: {
    type: getPluginType(editor, ELEMENT_TABLE)
  },
  ...options
});

/**
 * Get table column index of a cell node.
 */

const getTableColumnIndex = (editor, cellNode) => {
  var _getParentNode;

  const path = findNodePath(editor, cellNode);
  if (!path) return 0;
  const [trNode] = (_getParentNode = getParentNode(editor, path)) !== null && _getParentNode !== void 0 ? _getParentNode : [];
  if (!trNode) return 0;
  let colIndex = 0;
  trNode.children.some((item, index) => {
    if (item === cellNode) {
      colIndex = index;
      return true;
    }

    return false;
  });
  return colIndex;
};

/**
 * If at (default = selection) is in table>tr>td|th,
 * return table, row, and cell node entries.
 */

const getTableEntries = (editor, {
  at = editor.selection
} = {}) => {
  if (!at) return;
  const cellEntry = findNode(editor, {
    at,
    match: {
      type: getCellTypes(editor)
    }
  });
  if (!cellEntry) return;
  const [, cellPath] = cellEntry;
  const rowEntry = getAboveNode(editor, {
    at: cellPath,
    match: {
      type: getPluginType(editor, ELEMENT_TR)
    }
  });
  if (!rowEntry) return;
  const [, rowPath] = rowEntry;
  const tableEntry = getAboveNode(editor, {
    at: rowPath,
    match: {
      type: getPluginType(editor, ELEMENT_TABLE)
    }
  });
  if (!tableEntry) return;
  return {
    table: tableEntry,
    row: rowEntry,
    cell: cellEntry
  };
};

/**
 * Returns node.colSizes if it exists, applying overrides, otherwise returns a
 * 0-filled array.
 */

const getTableOverriddenColSizes = (tableNode, colSizeOverrides) => {
  const colCount = getTableColumnCount(tableNode);
  const colSizes = (tableNode.colSizes ? [...tableNode.colSizes] : Array(colCount).fill(0)).map((size, index) => {
    var _colSizeOverrides$get;

    return (_colSizeOverrides$get = colSizeOverrides === null || colSizeOverrides === void 0 ? void 0 : colSizeOverrides.get(index)) !== null && _colSizeOverrides$get !== void 0 ? _colSizeOverrides$get : size;
  });
  return colSizes;
};

/**
 * Get table row index of a cell node.
 */

const getTableRowIndex = (editor, cellNode) => {
  const path = findNodePath(editor, cellNode);
  if (!path) return 0;
  const rowPath = Path.parent(path);
  return rowPath[rowPath.length - 1];
};

const isTableBorderHidden = (editor, border) => {
  var _findNode, _findNode$0$borders, _findNode$0$borders$b;

  if (border === 'left') {
    var _getLeftTableCell;

    const node = (_getLeftTableCell = getLeftTableCell(editor)) === null || _getLeftTableCell === void 0 ? void 0 : _getLeftTableCell[0];

    if (node) {
      var _node$borders, _node$borders$right;

      return ((_node$borders = node.borders) === null || _node$borders === void 0 ? void 0 : (_node$borders$right = _node$borders.right) === null || _node$borders$right === void 0 ? void 0 : _node$borders$right.size) === 0;
    }
  }

  if (border === 'top') {
    var _getTopTableCell;

    const node = (_getTopTableCell = getTopTableCell(editor)) === null || _getTopTableCell === void 0 ? void 0 : _getTopTableCell[0];

    if (node) {
      var _node$borders2, _node$borders2$bottom;

      return ((_node$borders2 = node.borders) === null || _node$borders2 === void 0 ? void 0 : (_node$borders2$bottom = _node$borders2.bottom) === null || _node$borders2$bottom === void 0 ? void 0 : _node$borders2$bottom.size) === 0;
    }
  }

  return ((_findNode = findNode(editor, {
    match: {
      type: getCellTypes(editor)
    }
  })) === null || _findNode === void 0 ? void 0 : (_findNode$0$borders = _findNode[0].borders) === null || _findNode$0$borders === void 0 ? void 0 : (_findNode$0$borders$b = _findNode$0$borders[border]) === null || _findNode$0$borders$b === void 0 ? void 0 : _findNode$0$borders$b.size) === 0;
};

const onKeyDownTable = (editor, {
  type
}) => e => {
  if (e.defaultPrevented) return;
  const isKeyDown = {
    'shift+up': isHotkey('shift+up', e),
    'shift+down': isHotkey('shift+down', e),
    'shift+left': isHotkey('shift+left', e),
    'shift+right': isHotkey('shift+right', e)
  };
  Object.keys(isKeyDown).forEach(key => {
    if (isKeyDown[key]) {
      // if many cells are selected
      if (moveSelectionFromCell(editor, {
        reverse: key === 'shift+up',
        edge: keyShiftEdges[key]
      })) {
        e.preventDefault();
        e.stopPropagation();
      }
    }
  });
  const isTab = Hotkeys.isTab(editor, e);
  const isUntab = Hotkeys.isUntab(editor, e);

  if (isTab || isUntab) {
    const entries = getTableEntries(editor);
    if (!entries) return;
    const {
      row,
      cell
    } = entries;
    const [, cellPath] = cell;

    if (isUntab) {
      // move left with shift+tab
      const previousCell = getPreviousTableCell(editor, cell, cellPath, row);

      if (previousCell) {
        const [, previousCellPath] = previousCell;
        select(editor, previousCellPath);
      }
    } else if (isTab) {
      // move right with tab
      const nextCell = getNextTableCell(editor, cell, cellPath, row);

      if (nextCell) {
        const [, nextCellPath] = nextCell;
        select(editor, nextCellPath);
      }
    }

    e.preventDefault();
    e.stopPropagation();
  }

  if (isHotkey('mod+a', e)) {
    const res = getAboveNode(editor, {
      match: {
        type
      }
    });
    if (!res) return;
    const [, tablePath] = res; // select the whole table

    select(editor, tablePath);
    e.preventDefault();
    e.stopPropagation();
  }
};

/**
 * Return true if:
 * - at start/end of a cell.
 * - next to a table cell. Move selection to the table cell.
 */

const preventDeleteTableCell = (editor, {
  unit,
  reverse
}) => {
  const {
    selection
  } = editor;
  const getPoint = !reverse ? getStartPoint : getEndPoint;
  const getNextPoint = !reverse ? getPointBefore : getPointAfter;

  if (isCollapsed(selection)) {
    const cellEntry = getBlockAbove(editor, {
      match: {
        type: getCellTypes(editor)
      }
    });

    if (cellEntry) {
      // Prevent deleting cell at the start or end of a cell
      const [, cellPath] = cellEntry;
      const start = getPoint(editor, cellPath);

      if (selection && Point.equals(selection.anchor, start)) {
        return true;
      }
    } else {
      // Prevent deleting cell when selection is before or after a table
      const nextPoint = getNextPoint(editor, selection, {
        unit
      });
      const nextCellEntry = getBlockAbove(editor, {
        match: {
          type: getCellTypes(editor)
        },
        at: nextPoint
      });

      if (nextCellEntry) {
        moveSelection(editor, {
          reverse: !reverse
        });
        return true;
      }
    }
  }
};
/**
 * Prevent cell deletion.
 */

const withDeleteTable = editor => {
  const {
    deleteBackward,
    deleteForward,
    deleteFragment
  } = editor;

  editor.deleteBackward = unit => {
    if (preventDeleteTableCell(editor, {
      unit
    })) return;
    return deleteBackward(unit);
  };

  editor.deleteForward = unit => {
    if (preventDeleteTableCell(editor, {
      unit,
      reverse: true
    })) return;
    return deleteForward(unit);
  };

  editor.deleteFragment = direction => {
    isRangeInSameBlock(editor, {
      match: n => n.type === getPluginType(editor, ELEMENT_TABLE)
    });

    if (isRangeInSameBlock(editor, {
      match: n => n.type === getPluginType(editor, ELEMENT_TABLE)
    })) {
      const cellEntries = getTableGridAbove(editor, {
        format: 'cell'
      });

      if (cellEntries.length > 1) {
        withoutNormalizing(editor, () => {
          cellEntries.forEach(([, cellPath]) => {
            replaceNodeChildren(editor, {
              at: cellPath,
              nodes: editor.blockFactory()
            });
          }); // set back the selection

          select(editor, {
            anchor: getStartPoint(editor, cellEntries[0][1]),
            focus: getEndPoint(editor, cellEntries[cellEntries.length - 1][1])
          });
        });
        return;
      }
    }

    deleteFragment(direction);
  };

  return editor;
};

/**
 * If selection is in a table, get subtable above.
 */

const withGetFragmentTable = editor => {
  const {
    getFragment
  } = editor;

  editor.getFragment = () => {
    const fragment = getFragment();
    const newFragment = [];
    fragment.forEach(node => {
      if (node.type === getPluginType(editor, ELEMENT_TABLE)) {
        const rows = node.children;
        const rowCount = rows.length;
        if (!rowCount) return;
        const colCount = rows[0].children.length;
        const hasOneCell = rowCount <= 1 && colCount <= 1;

        if (!hasOneCell) {
          const subTable = getTableGridAbove(editor);

          if (subTable.length) {
            newFragment.push(subTable[0][0]);
            return;
          }
        } else {
          newFragment.push(...rows[0].children[0].children);
          return;
        }
      }

      newFragment.push(node);
    });
    return newFragment;
  };

  return editor;
};

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

var _listCacheClear = listCacheClear;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

var eq_1 = eq;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

var _assocIndexOf = assocIndexOf;

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

var _listCacheDelete = listCacheDelete;

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

var _listCacheGet = listCacheGet;

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}

var _listCacheHas = listCacheHas;

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

var _listCacheSet = listCacheSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClear;
ListCache.prototype['delete'] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;

var _ListCache = ListCache;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new _ListCache;
  this.size = 0;
}

var _stackClear = stackClear;

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

var _stackDelete = stackDelete;

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

var _stackGet = stackGet;

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

var _stackHas = stackHas;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal || freeSelf || Function('return this')();

var _root = root;

/** Built-in value references. */
var Symbol$1 = _root.Symbol;

var _Symbol = Symbol$1;

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$c.toString;

/** Built-in value references. */
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$9.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

var _getRawTag = getRawTag;

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$b.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

var _objectToString = objectToString;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

var _baseGetTag = baseGetTag;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject;

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$2 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject_1(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = _baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}

var isFunction_1 = isFunction;

/** Used to detect overreaching core-js shims. */
var coreJsData = _root['__core-js_shared__'];

var _coreJsData = coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

var _isMasked = isMasked;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

var _toSource = toSource;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$a = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty$8).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject_1(value) || _isMasked(value)) {
    return false;
  }
  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}

var _baseIsNative = baseIsNative;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

var _getValue = getValue;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = _getValue(object, key);
  return _baseIsNative(value) ? value : undefined;
}

var _getNative = getNative;

/* Built-in method references that are verified to be native. */
var Map$1 = _getNative(_root, 'Map');

var _Map = Map$1;

/* Built-in method references that are verified to be native. */
var nativeCreate = _getNative(Object, 'create');

var _nativeCreate = nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}

var _hashClear = hashClear;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var _hashDelete = hashDelete;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }
  return hasOwnProperty$7.call(data, key) ? data[key] : undefined;
}

var _hashGet = hashGet;

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$6.call(data, key);
}

var _hashHas = hashHas;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

var _hashSet = hashSet;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = _hashClear;
Hash.prototype['delete'] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;

var _Hash = Hash;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash,
    'map': new (_Map || _ListCache),
    'string': new _Hash
  };
}

var _mapCacheClear = mapCacheClear;

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

var _isKeyable = isKeyable;

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

var _getMapData = getMapData;

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = _getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

var _mapCacheDelete = mapCacheDelete;

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}

var _mapCacheGet = mapCacheGet;

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}

var _mapCacheHas = mapCacheHas;

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = _getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

var _mapCacheSet = mapCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype['delete'] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;

var _MapCache = MapCache;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache) {
    var pairs = data.__data__;
    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

var _stackSet = stackSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = _stackClear;
Stack.prototype['delete'] = _stackDelete;
Stack.prototype.get = _stackGet;
Stack.prototype.has = _stackHas;
Stack.prototype.set = _stackSet;

var _Stack = Stack;

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

var _arrayEach = arrayEach;

var defineProperty = (function() {
  try {
    var func = _getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

var _defineProperty = defineProperty;

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && _defineProperty) {
    _defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

var _baseAssignValue = baseAssignValue;

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$5.call(object, key) && eq_1(objValue, value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

var _assignValue = assignValue;

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      _baseAssignValue(object, key, newValue);
    } else {
      _assignValue(object, key, newValue);
    }
  }
  return object;
}

var _copyObject = copyObject;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

var _baseTimes = baseTimes;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike_1(value) && _baseGetTag(value) == argsTag$2;
}

var _baseIsArguments = baseIsArguments;

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
  return isObjectLike_1(value) && hasOwnProperty$4.call(value, 'callee') &&
    !propertyIsEnumerable$1.call(value, 'callee');
};

var isArguments_1 = isArguments;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

var isArray_1 = isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

var stubFalse_1 = stubFalse;

var isBuffer_1 = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports = exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse_1;

module.exports = isBuffer;
});

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

var _isIndex = isIndex;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

var isLength_1 = isLength;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$2 = '[object Boolean]',
    dateTag$2 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag$4 = '[object Map]',
    numberTag$2 = '[object Number]',
    objectTag$2 = '[object Object]',
    regexpTag$2 = '[object RegExp]',
    setTag$4 = '[object Set]',
    stringTag$2 = '[object String]',
    weakMapTag$2 = '[object WeakMap]';

var arrayBufferTag$2 = '[object ArrayBuffer]',
    dataViewTag$3 = '[object DataView]',
    float32Tag$2 = '[object Float32Array]',
    float64Tag$2 = '[object Float64Array]',
    int8Tag$2 = '[object Int8Array]',
    int16Tag$2 = '[object Int16Array]',
    int32Tag$2 = '[object Int32Array]',
    uint8Tag$2 = '[object Uint8Array]',
    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
    uint16Tag$2 = '[object Uint16Array]',
    uint32Tag$2 = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] =
typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] =
typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] =
typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] =
typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] =
typedArrayTags[weakMapTag$2] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike_1(value) &&
    isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
}

var _baseIsTypedArray = baseIsTypedArray;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

var _baseUnary = baseUnary;

var _nodeUtil = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports = exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && _freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;
});

/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

var isTypedArray_1 = isTypedArray;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_1(value),
      isArg = !isArr && isArguments_1(value),
      isBuff = !isArr && !isArg && isBuffer_1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? _baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$3.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           _isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

var _arrayLikeKeys = arrayLikeKeys;

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$4;

  return value === proto;
}

var _isPrototype = isPrototype;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

var _overArg = overArg;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = _overArg(Object.keys, Object);

var _nativeKeys = nativeKeys;

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!_isPrototype(object)) {
    return _nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

var _baseKeys = baseKeys;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength_1(value.length) && !isFunction_1(value);
}

var isArrayLike_1 = isArrayLike;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
}

var keys_1 = keys;

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && _copyObject(source, keys_1(source), object);
}

var _baseAssign = baseAssign;

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

var _nativeKeysIn = nativeKeysIn;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject_1(object)) {
    return _nativeKeysIn(object);
  }
  var isProto = _isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$1.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

var _baseKeysIn = baseKeysIn;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
}

var keysIn_1 = keysIn;

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && _copyObject(source, keysIn_1(source), object);
}

var _baseAssignIn = baseAssignIn;

var _cloneBuffer = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports = exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
});

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

var _copyArray = copyArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

var _arrayFilter = arrayFilter;

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

var stubArray_1 = stubArray;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return _arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

var _getSymbols = getSymbols;

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return _copyObject(source, _getSymbols(source), object);
}

var _copySymbols = copySymbols;

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

var _arrayPush = arrayPush;

/** Built-in value references. */
var getPrototype = _overArg(Object.getPrototypeOf, Object);

var _getPrototype = getPrototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray_1 : function(object) {
  var result = [];
  while (object) {
    _arrayPush(result, _getSymbols(object));
    object = _getPrototype(object);
  }
  return result;
};

var _getSymbolsIn = getSymbolsIn;

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return _copyObject(source, _getSymbolsIn(source), object);
}

var _copySymbolsIn = copySymbolsIn;

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
}

var _baseGetAllKeys = baseGetAllKeys;

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return _baseGetAllKeys(object, keys_1, _getSymbols);
}

var _getAllKeys = getAllKeys;

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
}

var _getAllKeysIn = getAllKeysIn;

/* Built-in method references that are verified to be native. */
var DataView = _getNative(_root, 'DataView');

var _DataView = DataView;

/* Built-in method references that are verified to be native. */
var Promise$1 = _getNative(_root, 'Promise');

var _Promise = Promise$1;

/* Built-in method references that are verified to be native. */
var Set = _getNative(_root, 'Set');

var _Set = Set;

/* Built-in method references that are verified to be native. */
var WeakMap = _getNative(_root, 'WeakMap');

var _WeakMap = WeakMap;

/** `Object#toString` result references. */
var mapTag$3 = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$3 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';

var dataViewTag$2 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = _toSource(_DataView),
    mapCtorString = _toSource(_Map),
    promiseCtorString = _toSource(_Promise),
    setCtorString = _toSource(_Set),
    weakMapCtorString = _toSource(_WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = _baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
    (_Map && getTag(new _Map) != mapTag$3) ||
    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
    (_Set && getTag(new _Set) != setTag$3) ||
    (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
  getTag = function(value) {
    var result = _baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? _toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$2;
        case mapCtorString: return mapTag$3;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$3;
        case weakMapCtorString: return weakMapTag$1;
      }
    }
    return result;
  };
}

var _getTag = getTag;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

var _initCloneArray = initCloneArray;

/** Built-in value references. */
var Uint8Array = _root.Uint8Array;

var _Uint8Array = Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
  return result;
}

var _cloneArrayBuffer = cloneArrayBuffer;

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

var _cloneDataView = cloneDataView;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

var _cloneRegExp = cloneRegExp;

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

var _cloneSymbol = cloneSymbol;

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

var _cloneTypedArray = cloneTypedArray;

/** `Object#toString` result references. */
var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return _cloneArrayBuffer(object);

    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);

    case dataViewTag$1:
      return _cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return _cloneTypedArray(object, isDeep);

    case mapTag$2:
      return new Ctor;

    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);

    case regexpTag$1:
      return _cloneRegExp(object);

    case setTag$2:
      return new Ctor;

    case symbolTag$1:
      return _cloneSymbol(object);
  }
}

var _initCloneByTag = initCloneByTag;

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject_1(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

var _baseCreate = baseCreate;

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !_isPrototype(object))
    ? _baseCreate(_getPrototype(object))
    : {};
}

var _initCloneObject = initCloneObject;

/** `Object#toString` result references. */
var mapTag$1 = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike_1(value) && _getTag(value) == mapTag$1;
}

var _baseIsMap = baseIsMap;

/* Node.js helper references. */
var nodeIsMap = _nodeUtil && _nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;

var isMap_1 = isMap;

/** `Object#toString` result references. */
var setTag$1 = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike_1(value) && _getTag(value) == setTag$1;
}

var _baseIsSet = baseIsSet;

/* Node.js helper references. */
var nodeIsSet = _nodeUtil && _nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;

var isSet_1 = isSet;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$1 = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG$1 = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG$1,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject_1(value)) {
    return value;
  }
  var isArr = isArray_1(value);
  if (isArr) {
    result = _initCloneArray(value);
    if (!isDeep) {
      return _copyArray(value, result);
    }
  } else {
    var tag = _getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer_1(value)) {
      return _cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : _initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? _copySymbolsIn(value, _baseAssignIn(result, value))
          : _copySymbols(value, _baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = _initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new _Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet_1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_1(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? _getAllKeysIn : _getAllKeys)
    : (isFlat ? keysIn_1 : keys_1);

  var props = isArr ? undefined : keysFunc(value);
  _arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

var _baseClone = baseClone;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return _baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

var cloneDeep_1 = cloneDeep;

/**
 * If inserting a table,
 * If block above anchor is a table,
 * - Replace each cell above by the inserted table until out of bounds.
 * - Select the inserted cells.
 */
const withInsertFragmentTable = (editor, {
  options
}) => {
  const {
    insertFragment
  } = editor;
  const {
    disableExpandOnInsert,
    insertColumn,
    insertRow
  } = options;
  const myEditor = getTEditor(editor);

  myEditor.insertFragment = fragment => {
    const insertedTable = fragment.find(n => n.type === getPluginType(editor, ELEMENT_TABLE));

    if (!insertedTable) {
      var _editor$selection;

      const tableEntry = getTableAbove(editor, {
        at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor
      });

      if (tableEntry) {
        const cellEntries = getTableGridAbove(editor, {
          format: 'cell'
        });

        if (cellEntries.length > 1) {
          cellEntries.forEach(cellEntry => {
            if (cellEntry) {
              const [, cellPath] = cellEntry;
              replaceNodeChildren(editor, {
                at: cellPath,
                nodes: cloneDeep_1(fragment)
              });
            }
          });
          select(editor, {
            anchor: getStartPoint(editor, cellEntries[0][1]),
            focus: getEndPoint(editor, cellEntries[cellEntries.length - 1][1])
          });
          return;
        }
      }
    }

    if (insertedTable) {
      var _editor$selection2;

      const tableEntry = getTableAbove(editor, {
        at: (_editor$selection2 = editor.selection) === null || _editor$selection2 === void 0 ? void 0 : _editor$selection2.anchor
      }); // inserting inside table

      if (tableEntry) {
        var _editor$selection3;

        const [cellEntry] = getTableGridAbove(editor, {
          at: (_editor$selection3 = editor.selection) === null || _editor$selection3 === void 0 ? void 0 : _editor$selection3.anchor,
          format: 'cell'
        });

        if (cellEntry) {
          withoutNormalizing(editor, () => {
            const [, startCellPath] = cellEntry;
            const cellPath = [...startCellPath];
            const startColIndex = cellPath[cellPath.length - 1];
            let lastCellPath = null;
            let initRow = true;
            const insertedRows = insertedTable.children;
            insertedRows.forEach(row => {
              cellPath[cellPath.length - 1] = startColIndex; // last inserted row

              if (!initRow) {
                const fromRow = cellPath.slice(0, -1);
                cellPath[cellPath.length - 2] += 1;

                if (!hasNode(editor, cellPath)) {
                  if (!disableExpandOnInsert) {
                    insertRow === null || insertRow === void 0 ? void 0 : insertRow(editor, {
                      fromRow
                    });
                  } else {
                    return;
                  }
                }
              }

              initRow = false;
              const insertedCells = row.children;
              let initCell = true;
              insertedCells.forEach(cell => {
                if (!initCell) {
                  const fromCell = [...cellPath];
                  cellPath[cellPath.length - 1] += 1;

                  if (!hasNode(editor, cellPath)) {
                    if (!disableExpandOnInsert) {
                      insertColumn === null || insertColumn === void 0 ? void 0 : insertColumn(editor, {
                        fromCell
                      });
                    } else {
                      return;
                    }
                  }
                }

                initCell = false;
                replaceNodeChildren(editor, {
                  at: cellPath,
                  nodes: cloneDeep_1(cell.children)
                });
                lastCellPath = [...cellPath];
              });
            });

            if (lastCellPath) {
              select(editor, {
                anchor: getStartPoint(editor, startCellPath),
                focus: getEndPoint(editor, lastCellPath)
              });
            }
          });
          return;
        }
      }
    }

    insertFragment(fragment);
  };

  return editor;
};

const withInsertTextTable = (editor, plugin) => {
  const {
    insertText
  } = editor;

  editor.insertText = text => {
    if (isExpanded(editor.selection)) {
      var _editor$selection;

      const entry = getTableAbove(editor, {
        at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor
      });

      if (entry) {
        const cellEntries = getTableGridAbove(editor, {
          format: 'cell'
        });

        if (cellEntries.length > 1) {
          collapseSelection(editor, {
            edge: 'focus'
          });
        }
      }
    }

    insertText(text);
  };

  return editor;
};

/**
 * Normalize table:
 * - Wrap cell children in a paragraph if they are texts.
 */
const withNormalizeTable = editor => {
  const {
    normalizeNode
  } = editor;
  const myEditor = getTEditor(editor);
  const {
    initialTableWidth
  } = getPluginOptions(editor, ELEMENT_TABLE);

  myEditor.normalizeNode = ([node, path]) => {
    if (isElement(node)) {
      if (node.type === getPluginType(editor, ELEMENT_TABLE)) {
        const tableEntry = getBlockAbove(editor, {
          at: path,
          match: {
            type: getPluginType(editor, ELEMENT_TABLE)
          }
        });

        if (tableEntry) {
          unwrapNodes(editor, {
            at: path
          });
          return;
        }

        if (initialTableWidth) {
          var _tableNode$children$, _tableNode$children$$;

          const tableNode = node;
          const colCount = (_tableNode$children$ = tableNode.children[0]) === null || _tableNode$children$ === void 0 ? void 0 : (_tableNode$children$$ = _tableNode$children$.children) === null || _tableNode$children$$ === void 0 ? void 0 : _tableNode$children$$.length;

          if (colCount) {
            const colSizes = [];

            if (!tableNode.colSizes) {
              for (let i = 0; i < colCount; i++) {
                colSizes.push(initialTableWidth / colCount);
              }
            } else if (tableNode.colSizes.some(size => !size)) {
              tableNode.colSizes.forEach(colSize => {
                colSizes.push(colSize || initialTableWidth / colCount);
              });
            }

            if (colSizes.length) {
              setNodes(editor, {
                colSizes
              }, {
                at: path
              });
              return;
            }
          }
        }
      }

      if (node.type === getPluginType(editor, ELEMENT_TR)) {
        const parentEntry = getParentNode(editor, path);

        if ((parentEntry === null || parentEntry === void 0 ? void 0 : parentEntry[0].type) !== getPluginType(editor, ELEMENT_TABLE)) {
          unwrapNodes(editor, {
            at: path
          });
          return;
        }
      }

      if (getCellTypes(editor).includes(node.type)) {
        const {
          children
        } = node;
        const parentEntry = getParentNode(editor, path);

        if ((parentEntry === null || parentEntry === void 0 ? void 0 : parentEntry[0].type) !== getPluginType(editor, ELEMENT_TR)) {
          unwrapNodes(editor, {
            at: path
          });
          return;
        }

        if (isText(children[0])) {
          wrapNodeChildren(editor, editor.blockFactory({}, path), {
            at: path
          });
          return;
        }
      }
    }

    return normalizeNode([node, path]);
  };

  return editor;
};

/**
 * Selection table:
 * - If anchor is in table, focus in a block before: set focus to start of table
 * - If anchor is in table, focus in a block after: set focus to end of table
 * - If focus is in table, anchor in a block before: set focus to end of table
 * - If focus is in table, anchor in a block after: set focus to the point before start of table
 */

const withSelectionTable = editor => {
  const {
    apply
  } = editor;

  editor.apply = op => {
    if (op.type === 'set_selection' && op.newProperties) {
      const newSelection = { ...editor.selection,
        ...op.newProperties
      };

      if (Range.isRange(newSelection) && isRangeAcrossBlocks(editor, {
        at: newSelection,
        match: n => n.type === getPluginType(editor, ELEMENT_TABLE)
      })) {
        const anchorEntry = getBlockAbove(editor, {
          at: newSelection.anchor,
          match: n => n.type === getPluginType(editor, ELEMENT_TABLE)
        });

        if (!anchorEntry) {
          const focusEntry = getBlockAbove(editor, {
            at: newSelection.focus,
            match: n => n.type === getPluginType(editor, ELEMENT_TABLE)
          });

          if (focusEntry) {
            const [, focusPath] = focusEntry;
            const isBackward = Range.isBackward(newSelection);

            if (isBackward) {
              const startPoint = getStartPoint(editor, focusPath);
              const pointBefore = getPointBefore(editor, startPoint);
              op.newProperties.focus = pointBefore !== null && pointBefore !== void 0 ? pointBefore : startPoint;
            } else {
              op.newProperties.focus = getEndPoint(editor, focusPath);
            }
          }
        } else {
          const [, anchorPath] = anchorEntry;
          const isBackward = Range.isBackward(newSelection);

          if (isBackward) {
            op.newProperties.focus = getStartPoint(editor, anchorPath);
          } else {
            const pointBefore = getPointBefore(editor, anchorPath); // if the table is the first block

            if (pointBefore) {
              op.newProperties.focus = getEndPoint(editor, anchorPath);
            }
          }
        }
      }

      overrideSelectionFromCell(editor, newSelection);
    }

    apply(op);
  };

  return editor;
};

const withSetFragmentDataTable = editor => {
  const {
    setFragmentData
  } = editor;

  editor.setFragmentData = (data, originEvent) => {
    var _getTableGridAbove;

    const tableEntry = (_getTableGridAbove = getTableGridAbove(editor, {
      format: 'table'
    })) === null || _getTableGridAbove === void 0 ? void 0 : _getTableGridAbove[0];
    const selectedCellEntries = getTableGridAbove(editor, {
      format: 'cell'
    });
    const initialSelection = editor.selection;

    if (!tableEntry || !initialSelection) {
      setFragmentData(data, originEvent);
      return;
    }

    const selectionStart = Path.compare(initialSelection.anchor.path, initialSelection.focus.path) < 1 ? initialSelection.anchor : initialSelection.focus;
    const [tableNode, tablePath] = tableEntry;
    const tableRows = tableNode.children;
    const tableSelectionStart = selectionStart.path.slice(tablePath.length, tablePath.length + 2);
    const [y, x] = tableSelectionStart;
    let textCsv = '';
    let textTsv = '';
    const divElement = document.createElement('div');
    const tableElement = document.createElement('table');
    /**
     * Cover single cell copy | cut operation. In this case, copy cell content instead of table structure.
     */

    if (tableEntry && initialSelection && selectedCellEntries.length === 1 && (originEvent === 'copy' || originEvent === 'cut')) {
      setFragmentData(data);
      return;
    }

    withoutNormalizing(editor, () => {
      tableRows.forEach((row, rowIndex) => {
        const rowCells = row.children;
        const rowPath = tablePath.concat(y + rowIndex);
        const cellStrings = [];
        const rowElement = row.type === getPluginType(editor, ELEMENT_TH) ? document.createElement('th') : document.createElement('tr');
        rowCells.forEach((_, cellIndex) => {
          const cellPath = rowPath.concat(x + cellIndex); // select cell by cell

          select(editor, {
            anchor: getStartPoint(editor, cellPath),
            focus: getEndPoint(editor, cellPath)
          }); // set data from selection

          setFragmentData(data); // get plain text

          cellStrings.push(data.getData('text/plain'));
          const cellElement = document.createElement('td');
          cellElement.innerHTML = data.getData('text/html');
          rowElement.appendChild(cellElement);
        });
        tableElement.appendChild(rowElement);
        textCsv += `${cellStrings.join(',')}\n`;
        textTsv += `${cellStrings.join('\t')}\n`;
      }); // select back original cells

      select(editor, initialSelection);
      divElement.appendChild(tableElement);
    });
    data.setData('text/csv', textCsv);
    data.setData('text/tsv', textTsv);
    data.setData('text/plain', textTsv);
    data.setData('text/html', divElement.innerHTML); // set slate fragment

    const selectedFragmentStr = JSON.stringify(tableNode);
    const encodedFragment = window.btoa(encodeURIComponent(selectedFragmentStr));
    data.setData('application/x-slate-fragment', encodedFragment);
  };

  return editor;
};

const withTable = (editor, plugin) => {
  editor = withNormalizeTable(editor);
  editor = withDeleteTable(editor);
  editor = withGetFragmentTable(editor);
  editor = withInsertFragmentTable(editor, plugin);
  editor = withInsertTextTable(editor);
  editor = withSelectionTable(editor);
  editor = withSetFragmentDataTable(editor);
  return editor;
};

const ELEMENT_TABLE = 'table';
const ELEMENT_TH = 'th';
const ELEMENT_TR = 'tr';
const ELEMENT_TD = 'td';
/**
 * Enables support for tables.
 */

const createTablePlugin = createPluginFactory({
  key: ELEMENT_TABLE,
  isElement: true,
  handlers: {
    onKeyDown: onKeyDownTable
  },
  deserializeHtml: {
    rules: [{
      validNodeName: 'TABLE'
    }]
  },
  options: {
    insertColumn: (e, {
      fromCell
    }) => {
      insertTableColumn(e, {
        fromCell,
        disableSelect: true
      });
    },
    insertRow: (e, {
      fromRow
    }) => {
      insertTableRow(e, {
        fromRow,
        disableSelect: true
      });
    },
    minColumnWidth: 48
  },
  withOverrides: withTable,
  plugins: [{
    key: ELEMENT_TR,
    isElement: true,
    deserializeHtml: {
      rules: [{
        validNodeName: 'TR'
      }]
    }
  }, {
    key: ELEMENT_TD,
    isElement: true,
    deserializeHtml: {
      attributeNames: ['rowspan', 'colspan'],
      rules: [{
        validNodeName: 'TD'
      }]
    },
    props: ({
      element
    }) => {
      var _element$attributes, _element$attributes2;

      return {
        nodeProps: {
          colSpan: element === null || element === void 0 ? void 0 : (_element$attributes = element.attributes) === null || _element$attributes === void 0 ? void 0 : _element$attributes.colspan,
          rowSpan: element === null || element === void 0 ? void 0 : (_element$attributes2 = element.attributes) === null || _element$attributes2 === void 0 ? void 0 : _element$attributes2.rowspan
        }
      };
    }
  }, {
    key: ELEMENT_TH,
    isElement: true,
    deserializeHtml: {
      attributeNames: ['rowspan', 'colspan'],
      rules: [{
        validNodeName: 'TH'
      }]
    },
    props: ({
      element
    }) => {
      var _element$attributes3, _element$attributes4;

      return {
        nodeProps: {
          colSpan: element === null || element === void 0 ? void 0 : (_element$attributes3 = element.attributes) === null || _element$attributes3 === void 0 ? void 0 : _element$attributes3.colspan,
          rowSpan: element === null || element === void 0 ? void 0 : (_element$attributes4 = element.attributes) === null || _element$attributes4 === void 0 ? void 0 : _element$attributes4.rowspan
        }
      };
    }
  }]
});

const {
  tableStore,
  useTableStore
} = createAtomStore({
  colSizeOverrides: new Map(),
  rowSizeOverrides: new Map(),
  marginLeftOverride: null,
  hoveredColIndex: null,
  selectedCells: null
}, {
  name: 'table',
  scope: ELEMENT_TABLE
});

const useOverrideSizeFactory = setOverrides => useCallback((index, size) => {
  setOverrides(overrides => {
    const newOverrides = new Map(overrides);

    if (size === null) {
      newOverrides.delete(index);
    } else {
      newOverrides.set(index, size);
    }

    return newOverrides;
  });
}, [setOverrides]); // jotai supports setting with functions, but createAtomStore doesn't know that


const useOverrideColSize = () => {
  const setColSizeOverrides = useTableStore().set.colSizeOverrides();
  return useOverrideSizeFactory(setColSizeOverrides);
};
const useOverrideRowSize = () => {
  const setRowSizeOverrides = useTableStore().set.rowSizeOverrides();
  return useOverrideSizeFactory(setRowSizeOverrides);
};
const useOverrideMarginLeft = () => useTableStore().set.marginLeftOverride();

/**
 * Returns colSizes with overrides applied.
 * Unset node.colSizes if `colCount` updates to 1.
 */
const useTableColSizes = (tableNode, {
  disableOverrides = false
} = {}) => {
  const editor = useEditorRef();
  const colSizeOverrides = useTableStore().get.colSizeOverrides();
  const {
    enableUnsetSingleColSize
  } = getPluginOptions(editor, ELEMENT_TABLE);
  const overriddenColSizes = getTableOverriddenColSizes(tableNode, disableOverrides ? undefined : colSizeOverrides);
  const colCount = getTableColumnCount(tableNode);
  useEffect(() => {
    var _tableNode$colSizes;

    if (enableUnsetSingleColSize && colCount < 2 && (_tableNode$colSizes = tableNode.colSizes) !== null && _tableNode$colSizes !== void 0 && _tableNode$colSizes.length) {
      unsetNodes(editor, 'colSizes', {
        at: findNodePath(editor, tableNode)
      });
    }
  }, [colCount, enableUnsetSingleColSize, editor, tableNode]);
  return overriddenColSizes;
};

/**
 * Rounds a cell size to the nearest step, or returns the size if the step is
 * not set.
 */
const roundCellSizeToStep = (size, step) => {
  return step ? Math.round(size / step) * step : size;
};

const useTableCellElementResizableProps = ({
  colIndex,
  rowIndex,
  step,
  stepX = step,
  stepY = step
}) => {
  const editor = usePlateEditorRef();
  const element = useElement();
  const tableElement = useElement(ELEMENT_TABLE);
  const {
    minColumnWidth = 0
  } = getPluginOptions(editor, ELEMENT_TABLE);
  const [hoveredColIndex, setHoveredColIndex] = useTableStore().use.hoveredColIndex();
  const colSizesWithoutOverrides = useTableColSizes(tableElement, {
    disableOverrides: true
  });
  const {
    marginLeft = 0
  } = tableElement;
  const overrideColSize = useOverrideColSize();
  const overrideRowSize = useOverrideRowSize();
  const overrideMarginLeft = useOverrideMarginLeft();
  /* eslint-disable @typescript-eslint/no-shadow */

  const setColSize = useCallback((colIndex, width) => {
    setTableColSize(editor, {
      colIndex,
      width
    }, {
      at: findNodePath(editor, element)
    }); // Prevent flickering

    setTimeout(() => overrideColSize(colIndex, null), 0);
  }, [editor, element, overrideColSize]);
  /* eslint-disable @typescript-eslint/no-shadow */

  const setRowSize = useCallback((rowIndex, height) => {
    setTableRowSize(editor, {
      rowIndex,
      height
    }, {
      at: findNodePath(editor, element)
    }); // Prevent flickering

    setTimeout(() => overrideRowSize(rowIndex, null), 0);
  }, [editor, element, overrideRowSize]);
  const setMarginLeft = useCallback(marginLeft => {
    setTableMarginLeft(editor, {
      marginLeft
    }, {
      at: findNodePath(editor, element)
    }); // Prevent flickering

    setTimeout(() => overrideMarginLeft(null), 0);
  }, [editor, element, overrideMarginLeft]);
  const handleResizeRight = useCallback(({
    initialSize: currentInitial,
    delta,
    finished
  }) => {
    const nextInitial = colSizesWithoutOverrides[colIndex + 1];

    const complement = width => currentInitial + nextInitial - width;

    const currentNew = roundCellSizeToStep(resizeLengthClampStatic(currentInitial + delta, {
      min: minColumnWidth,
      max: nextInitial ? complement(minColumnWidth) : undefined
    }), stepX);
    const nextNew = nextInitial ? complement(currentNew) : undefined;
    const fn = finished ? setColSize : overrideColSize;
    fn(colIndex, currentNew);
    if (nextNew) fn(colIndex + 1, nextNew);
  }, [colIndex, colSizesWithoutOverrides, minColumnWidth, overrideColSize, setColSize, stepX]);
  const handleResizeBottom = useCallback(event => {
    const newHeight = roundCellSizeToStep(event.initialSize + event.delta, stepY);

    if (event.finished) {
      setRowSize(rowIndex, newHeight);
    } else {
      overrideRowSize(rowIndex, newHeight);
    }
  }, [overrideRowSize, rowIndex, setRowSize, stepY]);
  const handleResizeLeft = useCallback(event => {
    const initial = colSizesWithoutOverrides[colIndex];

    const complement = width => initial + marginLeft - width;

    const newMargin = roundCellSizeToStep(resizeLengthClampStatic(marginLeft + event.delta, {
      min: 0,
      max: complement(minColumnWidth)
    }), stepX);
    const newWidth = complement(newMargin);

    if (event.finished) {
      setMarginLeft(newMargin);
      setColSize(colIndex, newWidth);
    } else {
      overrideMarginLeft(newMargin);
      overrideColSize(colIndex, newWidth);
    }
  }, [colIndex, colSizesWithoutOverrides, marginLeft, minColumnWidth, overrideColSize, overrideMarginLeft, setColSize, setMarginLeft, stepX]);
  /* eslint-disable @typescript-eslint/no-shadow */

  const getHandleHoverProps = colIndex => ({
    onHover: () => {
      if (hoveredColIndex === null) {
        setHoveredColIndex(colIndex);
      }
    },
    onHoverEnd: () => {
      if (hoveredColIndex === colIndex) {
        setHoveredColIndex(null);
      }
    }
  });

  const commonHandleProps = {
    startMargin: -12
  };
  return {
    rightProps: {
      direction: 'right',
      onResize: handleResizeRight,
      ...getHandleHoverProps(colIndex),
      ...commonHandleProps
    },
    bottomProps: {
      direction: 'bottom',
      onResize: handleResizeBottom,
      ...commonHandleProps
    },
    leftProps: {
      direction: 'left',
      onResize: handleResizeLeft,
      ...getHandleHoverProps(-1),
      ...commonHandleProps
    }
  };
};
const TableCellElementResizable = createComponentAs(props => {
  const editor = usePlateEditorRef();
  const {
    disableMarginLeft
  } = getPluginOptions(editor, ELEMENT_TABLE);
  const {
    readOnly,
    colIndex
  } = props;
  const {
    rightProps,
    bottomProps,
    leftProps
  } = useTableCellElementResizableProps(props);
  const hasLeftHandle = colIndex === 0 && !disableMarginLeft;
  return !readOnly && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ResizeHandle, rightProps), /*#__PURE__*/React.createElement(ResizeHandle, bottomProps), hasLeftHandle && /*#__PURE__*/React.createElement(ResizeHandle, leftProps));
});

const TableCellElementResizableWrapper = createComponentAs(props => createElementAs('div', {
  contentEditable: false,
  ...props
}));

const useTableCellElementRootProps = props => {
  const {
    element
  } = props;
  const setHoveredColIndex = useTableStore().set.hoveredColIndex();
  useEffect(() => {
    setHoveredColIndex(null);
  }, [element, setHoveredColIndex]);
  return {
    colSpan: element.colSpan,
    ...useElementProps(props)
  };
};
const TableCellElementRoot = createComponentAs(props => {
  const htmlProps = useTableCellElementRootProps(props);
  return createElementAs('td', htmlProps);
});

const TableCellElement = {
  Content: Box,
  Handle: Box,
  Resizable: TableCellElementResizable,
  ResizableWrapper: TableCellElementResizableWrapper,
  Root: TableCellElementRoot
};

const getOnSelectTableBorderFactory = (editor, selectedCells) => border => () => {
  if (selectedCells) return;

  if (border === 'none') {
    setBorderSize(editor, 0, {
      border: 'all'
    });
  } else if (border === 'outer') {
    setBorderSize(editor, 1, {
      border: 'all'
    });
  } else {
    const size = isTableBorderHidden(editor, border) ? 1 : 0;
    setBorderSize(editor, size, {
      border
    });
  }

  setTimeout(() => {
    focusEditor(editor);
  }, 50);
};

const getTableCellBorders = (element, {
  isFirstCell,
  isFirstRow,
  defaultBorder = {
    size: 1,
    style: 'solid',
    color: 'rgb(209 213 219)'
  }
} = {}) => {
  const getBorder = dir => {
    var _element$borders, _border$size, _border$style, _border$color;

    const border = (_element$borders = element.borders) === null || _element$borders === void 0 ? void 0 : _element$borders[dir];
    return {
      size: (_border$size = border === null || border === void 0 ? void 0 : border.size) !== null && _border$size !== void 0 ? _border$size : defaultBorder.size,
      style: (_border$style = border === null || border === void 0 ? void 0 : border.style) !== null && _border$style !== void 0 ? _border$style : defaultBorder.style,
      color: (_border$color = border === null || border === void 0 ? void 0 : border.color) !== null && _border$color !== void 0 ? _border$color : defaultBorder.color
    };
  };

  return {
    bottom: getBorder('bottom'),
    right: getBorder('right'),
    left: isFirstCell ? getBorder('left') : undefined,
    top: isFirstRow ? getBorder('top') : undefined
  };
};

const useIsCellSelected = element => {
  const selectedCells = useTableStore().get.selectedCells();
  return useMemo(() => !!(selectedCells !== null && selectedCells !== void 0 && selectedCells.includes(element)), [element, selectedCells]);
};

const useTableBordersDropdownMenuContentState = () => {
  const editor = usePlateEditorState();
  const selectedCells = useTableStore().get.selectedCells();
  const hasBottomBorder = !isTableBorderHidden(editor, 'bottom');
  const hasTopBorder = !isTableBorderHidden(editor, 'top');
  const hasLeftBorder = !isTableBorderHidden(editor, 'left');
  const hasRightBorder = !isTableBorderHidden(editor, 'right');
  const hasOuterBorders = hasBottomBorder && hasTopBorder && hasLeftBorder && hasRightBorder;
  const hasNoBorders = !hasBottomBorder && !hasTopBorder && !hasLeftBorder && !hasRightBorder;
  return {
    hasBottomBorder,
    hasTopBorder,
    hasLeftBorder,
    hasRightBorder,
    hasNoBorders,
    hasOuterBorders,
    getOnSelectTableBorder: getOnSelectTableBorderFactory(editor, selectedCells)
  };
};

const useTableCellElementState = ({
  ignoreReadOnly
} = {}) => {
  var _ref, _rowSizeOverrides$get;

  const editor = usePlateEditorRef();
  const cellElement = useElement();
  const colIndex = getTableColumnIndex(editor, cellElement);
  const rowIndex = getTableRowIndex(editor, cellElement);
  const readOnly = useReadOnly();
  const isCellSelected = useIsCellSelected(cellElement);
  const hoveredColIndex = useTableStore().get.hoveredColIndex();
  const tableElement = useElement(ELEMENT_TABLE);
  const rowElement = useElement(ELEMENT_TR);
  const rowSizeOverrides = useTableStore().get.rowSizeOverrides();
  const rowSize = (_ref = (_rowSizeOverrides$get = rowSizeOverrides.get(rowIndex)) !== null && _rowSizeOverrides$get !== void 0 ? _rowSizeOverrides$get : rowElement === null || rowElement === void 0 ? void 0 : rowElement.size) !== null && _ref !== void 0 ? _ref : undefined;
  const isFirstCell = colIndex === 0;
  const isFirstRow = tableElement.children[0] === rowElement;
  const borders = getTableCellBorders(cellElement, {
    isFirstCell,
    isFirstRow
  });
  return {
    colIndex,
    rowIndex,
    readOnly: !ignoreReadOnly && readOnly,
    selected: isCellSelected,
    hovered: hoveredColIndex === colIndex,
    hoveredLeft: isFirstCell && hoveredColIndex === -1,
    rowSize,
    borders
  };
};

const TableElementCol = createComponentAs(props => createElementAs('col', props));

const useTableElementColGroupProps = ({ ...props
}) => {
  return {
    contentEditable: false,
    style: {
      width: '100%'
    },
    ...props
  };
};
const TableElementColGroup = createComponentAs(props => {
  const htmlProps = useTableElementColGroupProps(props);
  return createElementAs('colgroup', htmlProps);
});

/**
 * Many grid cells above and diff -> set
 * No many grid cells above and diff -> unset
 * No selection -> unset
 */

const useSelectedCells = () => {
  const readOnly = useReadOnly();
  const selected = useSelected();
  const editor = useEditorRef();
  const [selectedCells, setSelectedCells] = useTableStore().use.selectedCells();
  useEffect(() => {
    if (!selected || readOnly) setSelectedCells(null);
  }, [selected, editor, setSelectedCells, readOnly]);
  useEffect(() => {
    if (readOnly) return;
    const cellEntries = getTableGridAbove(editor, {
      format: 'cell'
    });

    if (cellEntries.length > 1) {
      const cells = cellEntries.map(entry => entry[0]);

      if (JSON.stringify(cells) !== JSON.stringify(selectedCells)) {
        setSelectedCells(cells);
      }
    } else if (selectedCells) {
      setSelectedCells(null);
    }
  }, [editor, editor.selection, readOnly, selectedCells, setSelectedCells]);
};

const useTableElementRootProps = props => {
  const editor = usePlateEditorRef();
  const selectedCells = useTableStore().get.selectedCells();
  useSelectedCells();
  return {
    onMouseDown: () => {
      // until cell dnd is supported, we collapse the selection on mouse down
      if (selectedCells) {
        collapseSelection(editor);
      }
    },
    ...useElementProps(props)
  };
};
const TableElementRoot = createComponentAs(props => {
  const htmlProps = useTableElementRootProps(props);
  return createElementAs('table', htmlProps);
});

const TableElementTBody = createComponentAs(props => createElementAs('tbody', props));

const TableElement = {
  Wrapper: Box,
  Root: TableElementRoot,
  Col: TableElementCol,
  ColGroup: TableElementColGroup,
  TBody: TableElementTBody
};

const useTableElementState = ({
  transformColSizes
} = {}) => {
  var _ref;

  const editor = usePlateEditorRef();
  const {
    minColumnWidth,
    disableMarginLeft
  } = getPluginOptions(editor, ELEMENT_TABLE);
  const element = useElement();
  const selectedCells = useTableStore().get.selectedCells();
  const marginLeftOverride = useTableStore().get.marginLeftOverride();
  const marginLeft = disableMarginLeft ? 0 : (_ref = marginLeftOverride !== null && marginLeftOverride !== void 0 ? marginLeftOverride : element.marginLeft) !== null && _ref !== void 0 ? _ref : 0;
  let colSizes = useTableColSizes(element);

  if (transformColSizes) {
    colSizes = transformColSizes(colSizes);
  } // add a last col to fill the remaining space


  if (!colSizes.some(size => size === 0)) {
    colSizes.push('100%');
  }

  return {
    colSizes,
    isSelectingCell: !!selectedCells,
    minColumnWidth: minColumnWidth,
    marginLeft
  };
};

const TableRowElementRoot = createComponentAs(props => createElementAs('tr', useElementProps(props)));
const TableRowElement = {
  Root: TableRowElementRoot
};

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

const ArrowDropDownCircleIcon = props => /*#__PURE__*/React.createElement("svg", _extends({
  viewBox: "0 0 24 24",
  focusable: "false",
  role: "img",
  fill: "currentColor",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0V0z"
}), /*#__PURE__*/React.createElement("path", {
  d: "m7 10 5 5 5-5H7z"
}));

const BorderAllIcon = props => /*#__PURE__*/React.createElement("svg", _extends({
  viewBox: "0 0 24 24",
  focusable: "false",
  role: "img",
  fill: "currentColor",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
}), /*#__PURE__*/React.createElement("path", {
  d: "M3 3v18h18V3H3zm8 16H5v-6h6v6zm0-8H5V5h6v6zm8 8h-6v-6h6v6zm0-8h-6V5h6v6z"
}));

const BorderBottomIcon = props => /*#__PURE__*/React.createElement("svg", _extends({
  width: "15",
  height: "15",
  viewBox: "0 0 15 15",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  d: "M1 13.25L14 13.25V14.75L1 14.75V13.25Z",
  fill: "currentColor",
  fillRule: "evenodd",
  clipRule: "evenodd",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "5",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "13",
  y: "5",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "3",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "13",
  y: "3",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "1",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "13",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "13",
  y: "1",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "5",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "5",
  y: "1",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "3",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "3",
  y: "1",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "9",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "9",
  y: "1",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "11",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "11",
  y: "1",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "9",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "13",
  y: "9",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "11",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "13",
  y: "11",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "1",
  y: "5",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "1",
  y: "3",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "1",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "1",
  y: "1",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "1",
  y: "9",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}), /*#__PURE__*/React.createElement("rect", {
  x: "1",
  y: "11",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor",
  "data-darkreader-inline-fill": ""
}));

const BorderLeftIcon = props => /*#__PURE__*/React.createElement("svg", _extends({
  width: "15",
  height: "15",
  viewBox: "0 0 15 15",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  d: "M1.75 1L1.75 14L0.249999 14L0.25 1L1.75 1Z",
  fill: "currentColor",
  fillRule: "evenodd",
  clipRule: "evenodd"
}), /*#__PURE__*/React.createElement("rect", {
  x: "10",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 10 7)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "10",
  y: "13",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 10 13)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "12",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 12 7)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "12",
  y: "13",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 12 13)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "8",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 8 7)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "14",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 14 7)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "8",
  y: "13",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 8 13)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "14",
  y: "13",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 14 13)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "8",
  y: "5",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 8 5)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "14",
  y: "5",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 14 5)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "8",
  y: "3",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 8 3)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "14",
  y: "3",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 14 3)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "8",
  y: "9",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 8 9)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "14",
  y: "9",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 14 9)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "8",
  y: "11",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 8 11)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "14",
  y: "11",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 14 11)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "6",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 6 7)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "6",
  y: "13",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 6 13)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "4",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 4 7)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "4",
  y: "13",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 4 13)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "10",
  y: "1",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 10 1)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "12",
  y: "1",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 12 1)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "8",
  y: "1",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 8 1)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "14",
  y: "1",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 14 1)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "6",
  y: "1",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 6 1)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "4",
  y: "1",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(90 4 1)",
  fill: "currentColor"
}));

const BorderNoneIcon = props => /*#__PURE__*/React.createElement("svg", _extends({
  width: "15",
  height: "15",
  viewBox: "0 0 15 15",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "5.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "13",
  y: "5.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "3.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "13",
  y: "3.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "7.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "13.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "1.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "13",
  y: "7.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "13",
  y: "13.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "13",
  y: "1.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "5",
  y: "7.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "5",
  y: "13.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "5",
  y: "1.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "3",
  y: "7.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "3",
  y: "13.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "3",
  y: "1.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "9",
  y: "7.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "9",
  y: "13.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "9",
  y: "1.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "11",
  y: "7.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "11",
  y: "13.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "11",
  y: "1.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "9.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "13",
  y: "9.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "11.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "13",
  y: "11.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "1",
  y: "5.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "1",
  y: "3.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "1",
  y: "7.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "1",
  y: "13.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "1",
  y: "1.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "1",
  y: "9.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "1",
  y: "11.025",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}));

const BorderOuterIcon = props => /*#__PURE__*/React.createElement("svg", _extends({
  width: "15",
  height: "15",
  viewBox: "0 0 15 15",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  d: "M0.25 1C0.25 0.585786 0.585786 0.25 1 0.25H14C14.4142 0.25 14.75 0.585786 14.75 1V14C14.75 14.4142 14.4142 14.75 14 14.75H1C0.585786 14.75 0.25 14.4142 0.25 14V1ZM1.75 1.75V13.25H13.25V1.75H1.75Z",
  fill: "currentColor",
  fillRule: "evenodd",
  clipRule: "evenodd"
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "5",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "3",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "5",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "3",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "9",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "11",
  y: "7",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "9",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "7",
  y: "11",
  width: "1",
  height: "1",
  rx: ".5",
  fill: "currentColor"
}));

const BorderRightIcon = props => /*#__PURE__*/React.createElement("svg", _extends({
  width: "15",
  height: "15",
  viewBox: "0 0 15 15",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  d: "M13.25 1L13.25 14L14.75 14L14.75 1L13.25 1Z",
  fill: "currentColor",
  fillRule: "evenodd",
  clipRule: "evenodd"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 5 7)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 5 13)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 3 7)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 3 13)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 7 7)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 1 7)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 7 13)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 1 13)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 7 5)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 1 5)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 7 3)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 1 3)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 7 9)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 1 9)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 7 11)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 1 11)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 9 7)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 9 13)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 11 7)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 11 13)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 5 1)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 3 1)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 7 1)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 1 1)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 9 1)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  width: "1",
  height: "1",
  rx: ".5",
  transform: "matrix(0 1 1 0 11 1)",
  fill: "currentColor"
}));

const BorderTopIcon = props => /*#__PURE__*/React.createElement("svg", _extends({
  width: "15",
  height: "15",
  viewBox: "0 0 15 15",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React.createElement("path", {
  d: "M14 1.75L1 1.75L1 0.249999L14 0.25L14 1.75Z",
  fill: "currentColor",
  fillRule: "evenodd",
  clipRule: "evenodd"
}), /*#__PURE__*/React.createElement("rect", {
  x: "8",
  y: "10",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 8 10)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "2",
  y: "10",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 2 10)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "8",
  y: "12",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 8 12)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "2",
  y: "12",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 2 12)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "8",
  y: "8",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 8 8)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "8",
  y: "14",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 8 14)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "2",
  y: "8",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 2 8)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "2",
  y: "14",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 2 14)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "10",
  y: "8",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 10 8)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "10",
  y: "14",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 10 14)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "12",
  y: "8",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 12 8)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "12",
  y: "14",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 12 14)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "6",
  y: "8",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 6 8)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "6",
  y: "14",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 6 14)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "4",
  y: "8",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 4 8)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "4",
  y: "14",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 4 14)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "8",
  y: "6",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 8 6)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "2",
  y: "6",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 2 6)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "8",
  y: "4",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 8 4)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "2",
  y: "4",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 2 4)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "14",
  y: "10",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 14 10)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "14",
  y: "12",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 14 12)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "14",
  y: "8",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 14 8)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "14",
  y: "14",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 14 14)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "14",
  y: "6",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 14 6)",
  fill: "currentColor"
}), /*#__PURE__*/React.createElement("rect", {
  x: "14",
  y: "4",
  width: "1",
  height: "1",
  rx: ".5",
  transform: "rotate(-180 14 4)",
  fill: "currentColor"
}));

export { ArrowDropDownCircleIcon, BorderAllIcon, BorderBottomIcon, BorderLeftIcon, BorderNoneIcon, BorderOuterIcon, BorderRightIcon, BorderTopIcon, ELEMENT_TABLE, ELEMENT_TD, ELEMENT_TH, ELEMENT_TR, TableCellElement, TableCellElementResizable, TableCellElementResizableWrapper, TableCellElementRoot, TableElement, TableElementCol, TableElementColGroup, TableElementRoot, TableElementTBody, TableRowElement, TableRowElementRoot, createTablePlugin, deleteColumn, deleteRow, deleteTable, getCellInNextTableRow, getCellInPreviousTableRow, getCellTypes, getEmptyCellNode, getEmptyRowNode, getEmptyTableNode, getLeftTableCell, getNextTableCell, getOnSelectTableBorderFactory, getPreviousTableCell, getTableAbove, getTableCellBorders, getTableColumnCount, getTableColumnIndex, getTableEntries, getTableGridAbove, getTableGridByRange, getTableOverriddenColSizes, getTableRowIndex, getTopTableCell, insertTable, insertTableColumn, insertTableRow, isTableBorderHidden, keyShiftEdges, moveSelectionFromCell, onKeyDownTable, overrideSelectionFromCell, preventDeleteTableCell, roundCellSizeToStep, setBorderSize, setTableColSize, setTableMarginLeft, setTableRowSize, tableStore, useIsCellSelected, useOverrideColSize, useOverrideMarginLeft, useOverrideRowSize, useSelectedCells, useTableBordersDropdownMenuContentState, useTableCellElementResizableProps, useTableCellElementRootProps, useTableCellElementState, useTableColSizes, useTableElementColGroupProps, useTableElementRootProps, useTableElementState, useTableStore, withDeleteTable, withGetFragmentTable, withInsertFragmentTable, withInsertTextTable, withNormalizeTable, withSelectionTable, withSetFragmentDataTable, withTable };
//# sourceMappingURL=index.es.js.map
