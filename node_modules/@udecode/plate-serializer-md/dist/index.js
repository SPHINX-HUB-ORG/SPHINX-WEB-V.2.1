'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var plateCommon = require('@udecode/plate-common');
var plateBlockQuote = require('@udecode/plate-block-quote');
var plateCodeBlock = require('@udecode/plate-code-block');
var plateHeading = require('@udecode/plate-heading');
var plateLink = require('@udecode/plate-link');
var plateList = require('@udecode/plate-list');
var slateReact = require('slate-react');
var React = require('react');
var slate = require('slate');
var ReactTextareaAutosize = require('react-textarea-autosize');
var plateParagraph = require('@udecode/plate-paragraph');
var markdown = require('remark-parse');
var unified = require('unified');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var ReactTextareaAutosize__default = /*#__PURE__*/_interopDefaultLegacy(ReactTextareaAutosize);
var markdown__default = /*#__PURE__*/_interopDefaultLegacy(markdown);
var unified__default = /*#__PURE__*/_interopDefaultLegacy(unified);

const ELEMENT_HR = 'hr';
plateCommon.createPluginFactory({
  key: ELEMENT_HR,
  isElement: true,
  isVoid: true,
  deserializeHtml: {
    rules: [{
      validNodeName: 'HR'
    }]
  }
});

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule$1(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var jsVideoUrlParser = createCommonjsModule$1(function (module, exports) {
(function (global, factory) {
  module.exports = factory() ;
}(commonjsGlobal, (function () {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  var getQueryParams = function getQueryParams(qs) {
    if (typeof qs !== 'string') {
      return {};
    }

    qs = qs.split('+').join(' ');
    var params = {};
    var match = qs.match(/(?:[?](?:[^=]+)=(?:[^&#]*)(?:[&](?:[^=]+)=(?:[^&#]*))*(?:[#].*)?)|(?:[#].*)/);
    var split;

    if (match === null) {
      return {};
    }

    split = match[0].substr(1).split(/[&#=]/);

    for (var i = 0; i < split.length; i += 2) {
      params[decodeURIComponent(split[i])] = decodeURIComponent(split[i + 1] || '');
    }

    return params;
  };

  var combineParams = function combineParams(params, hasParams) {
    if (_typeof(params) !== 'object') {
      return '';
    }

    var combined = '';
    var i = 0;
    var keys = Object.keys(params);

    if (keys.length === 0) {
      return '';
    } //always have parameters in the same order


    keys.sort();

    if (!hasParams) {
      combined += '?' + keys[0] + '=' + params[keys[0]];
      i += 1;
    }

    for (; i < keys.length; i += 1) {
      combined += '&' + keys[i] + '=' + params[keys[i]];
    }

    return combined;
  }; //parses strings like 1h30m20s to seconds


  function getLetterTime(timeString) {
    var totalSeconds = 0;
    var timeValues = {
      's': 1,
      'm': 1 * 60,
      'h': 1 * 60 * 60,
      'd': 1 * 60 * 60 * 24,
      'w': 1 * 60 * 60 * 24 * 7
    };
    var timePairs; //expand to "1 h 30 m 20 s" and split

    timeString = timeString.replace(/([smhdw])/g, ' $1 ').trim();
    timePairs = timeString.split(' ');

    for (var i = 0; i < timePairs.length; i += 2) {
      totalSeconds += parseInt(timePairs[i], 10) * timeValues[timePairs[i + 1] || 's'];
    }

    return totalSeconds;
  } //parses strings like 1:30:20 to seconds


  function getColonTime(timeString) {
    var totalSeconds = 0;
    var timeValues = [1, 1 * 60, 1 * 60 * 60, 1 * 60 * 60 * 24, 1 * 60 * 60 * 24 * 7];
    var timePairs = timeString.split(':');

    for (var i = 0; i < timePairs.length; i++) {
      totalSeconds += parseInt(timePairs[i], 10) * timeValues[timePairs.length - i - 1];
    }

    return totalSeconds;
  }

  var getTime = function getTime(timeString) {
    if (typeof timeString === 'undefined') {
      return 0;
    }

    if (timeString.match(/^(\d+[smhdw]?)+$/)) {
      return getLetterTime(timeString);
    }

    if (timeString.match(/^(\d+:?)+$/)) {
      return getColonTime(timeString);
    }

    return 0;
  };

  var util = {
    getQueryParams: getQueryParams,
    combineParams: combineParams,
    getTime: getTime
  };

  var getQueryParams$1 = util.getQueryParams;

  function UrlParser() {
    for (var _i = 0, _arr = ['parseProvider', 'parse', 'bind', 'create']; _i < _arr.length; _i++) {
      var key = _arr[_i];
      this[key] = this[key].bind(this);
    }

    this.plugins = {};
  }

  var urlParser = UrlParser;

  UrlParser.prototype.parseProvider = function (url) {
    var match = url.match(/(?:(?:https?:)?\/\/)?(?:[^.]+\.)?(\w+)\./i);
    return match ? match[1] : undefined;
  };

  UrlParser.prototype.parse = function (url) {
    if (typeof url === 'undefined') {
      return undefined;
    }

    var provider = this.parseProvider(url);
    var result;
    var plugin = this.plugins[provider];

    if (!provider || !plugin || !plugin.parse) {
      return undefined;
    }

    result = plugin.parse.call(plugin, url, getQueryParams$1(url));

    if (result) {
      result = removeEmptyParameters(result);
      result.provider = plugin.provider;
    }

    return result;
  };

  UrlParser.prototype.bind = function (plugin) {
    this.plugins[plugin.provider] = plugin;

    if (plugin.alternatives) {
      for (var i = 0; i < plugin.alternatives.length; i += 1) {
        this.plugins[plugin.alternatives[i]] = plugin;
      }
    }
  };

  UrlParser.prototype.create = function (op) {
    if (_typeof(op) !== 'object' || _typeof(op.videoInfo) !== 'object') {
      return undefined;
    }

    var vi = op.videoInfo;
    var params = op.params;
    var plugin = this.plugins[vi.provider];
    params = params === 'internal' ? vi.params : params || {};

    if (plugin) {
      op.format = op.format || plugin.defaultFormat; // eslint-disable-next-line no-prototype-builtins

      if (plugin.formats.hasOwnProperty(op.format)) {
        return plugin.formats[op.format].apply(plugin, [vi, Object.assign({}, params)]);
      }
    }

    return undefined;
  };

  function removeEmptyParameters(result) {
    if (result.params && Object.keys(result.params).length === 0) {
      delete result.params;
    }

    return result;
  }

  var parser = new urlParser();
  var base = parser;

  function Allocine() {
    this.provider = 'allocine';
    this.alternatives = [];
    this.defaultFormat = 'embed';
    this.formats = {
      embed: this.createEmbedUrl
    };
    this.mediaTypes = {
      VIDEO: 'video'
    };
  }

  Allocine.prototype.parseUrl = function (url) {
    var match = url.match(/(?:\/video\/player_gen_cmedia=)([A-Za-z0-9]+)/i);
    return match ? match[1] : undefined;
  };

  Allocine.prototype.parse = function (url) {
    var result = {
      mediaType: this.mediaTypes.VIDEO,
      id: this.parseUrl(url)
    };
    return result.id ? result : undefined;
  };

  Allocine.prototype.createEmbedUrl = function (vi) {
    if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
      return undefined;
    }

    return 'https://player.allocine.fr/' + vi.id + '.html';
  };

  base.bind(new Allocine());

  var combineParams$1 = util.combineParams;

  function CanalPlus() {
    this.provider = 'canalplus';
    this.defaultFormat = 'embed';
    this.formats = {
      embed: this.createEmbedUrl
    };
    this.mediaTypes = {
      VIDEO: 'video'
    };
  }

  CanalPlus.prototype.parseParameters = function (params) {
    delete params.vid;
    return params;
  };

  CanalPlus.prototype.parse = function (url, params) {
    var _this = this;

    var result = {
      mediaType: this.mediaTypes.VIDEO,
      id: params.vid
    };
    result.params = _this.parseParameters(params);

    if (!result.id) {
      return undefined;
    }

    return result;
  };

  CanalPlus.prototype.createEmbedUrl = function (vi, params) {
    if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
      return undefined;
    }

    var url = 'http://player.canalplus.fr/embed/';
    params.vid = vi.id;
    url += combineParams$1(params);
    return url;
  };

  base.bind(new CanalPlus());

  var combineParams$2 = util.combineParams;

  function Coub() {
    this.provider = 'coub';
    this.defaultFormat = 'long';
    this.formats = {
      "long": this.createLongUrl,
      embed: this.createEmbedUrl
    };
    this.mediaTypes = {
      VIDEO: 'video'
    };
  }

  Coub.prototype.parseUrl = function (url) {
    var match = url.match(/(?:embed|view)\/([a-zA-Z\d]+)/i);
    return match ? match[1] : undefined;
  };

  Coub.prototype.parse = function (url, params) {
    var result = {
      mediaType: this.mediaTypes.VIDEO,
      params: params,
      id: this.parseUrl(url)
    };

    if (!result.id) {
      return undefined;
    }

    return result;
  };

  Coub.prototype.createUrl = function (baseUrl, vi, params) {
    if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
      return undefined;
    }

    var url = baseUrl + vi.id;
    url += combineParams$2(params);
    return url;
  };

  Coub.prototype.createLongUrl = function (vi, params) {
    return this.createUrl('https://coub.com/view/', vi, params);
  };

  Coub.prototype.createEmbedUrl = function (vi, params) {
    return this.createUrl('//coub.com/embed/', vi, params);
  };

  base.bind(new Coub());

  var combineParams$3 = util.combineParams,
      getTime$1 = util.getTime;

  function Dailymotion() {
    this.provider = 'dailymotion';
    this.alternatives = ['dai'];
    this.defaultFormat = 'long';
    this.formats = {
      "short": this.createShortUrl,
      "long": this.createLongUrl,
      embed: this.createEmbedUrl,
      image: this.createImageUrl
    };
    this.mediaTypes = {
      VIDEO: 'video'
    };
  }

  Dailymotion.prototype.parseParameters = function (params) {
    return this.parseTime(params);
  };

  Dailymotion.prototype.parseTime = function (params) {
    if (params.start) {
      params.start = getTime$1(params.start);
    }

    return params;
  };

  Dailymotion.prototype.parseUrl = function (url) {
    var match = url.match(/(?:\/video|ly)\/([A-Za-z0-9]+)/i);
    return match ? match[1] : undefined;
  };

  Dailymotion.prototype.parse = function (url, params) {
    var _this = this;

    var result = {
      mediaType: this.mediaTypes.VIDEO,
      params: _this.parseParameters(params),
      id: _this.parseUrl(url)
    };
    return result.id ? result : undefined;
  };

  Dailymotion.prototype.createUrl = function (base, vi, params) {
    if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
      return undefined;
    }

    return base + vi.id + combineParams$3(params);
  };

  Dailymotion.prototype.createShortUrl = function (vi, params) {
    return this.createUrl('https://dai.ly/', vi, params);
  };

  Dailymotion.prototype.createLongUrl = function (vi, params) {
    return this.createUrl('https://dailymotion.com/video/', vi, params);
  };

  Dailymotion.prototype.createEmbedUrl = function (vi, params) {
    return this.createUrl('https://www.dailymotion.com/embed/video/', vi, params);
  };

  Dailymotion.prototype.createImageUrl = function (vi, params) {
    delete params.start;
    return this.createUrl('https://www.dailymotion.com/thumbnail/video/', vi, params);
  };

  base.bind(new Dailymotion());

  var combineParams$4 = util.combineParams;

  function Loom() {
    this.provider = 'loom';
    this.defaultFormat = 'long';
    this.formats = {
      "long": this.createLongUrl,
      embed: this.createEmbedUrl
    };
    this.mediaTypes = {
      VIDEO: 'video'
    };
  }

  Loom.prototype.parseUrl = function (url) {
    var match = url.match(/(?:share|embed)\/([a-zA-Z\d]+)/i);
    return match ? match[1] : undefined;
  };

  Loom.prototype.parse = function (url, params) {
    var result = {
      mediaType: this.mediaTypes.VIDEO,
      params: params,
      id: this.parseUrl(url)
    };
    return result.id ? result : undefined;
  };

  Loom.prototype.createUrl = function (baseUrl, vi, params) {
    if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
      return undefined;
    }

    var url = baseUrl + vi.id;
    url += combineParams$4(params);
    return url;
  };

  Loom.prototype.createLongUrl = function (vi, params) {
    return this.createUrl('https://loom.com/share/', vi, params);
  };

  Loom.prototype.createEmbedUrl = function (vi, params) {
    return this.createUrl('//loom.com/embed/', vi, params);
  };

  base.bind(new Loom());

  var combineParams$5 = util.combineParams,
      getTime$2 = util.getTime;

  function Twitch() {
    this.provider = 'twitch';
    this.defaultFormat = 'long';
    this.formats = {
      "long": this.createLongUrl,
      embed: this.createEmbedUrl
    };
    this.mediaTypes = {
      VIDEO: 'video',
      STREAM: 'stream',
      CLIP: 'clip'
    };
  }

  Twitch.prototype.seperateId = function (id) {
    return {
      pre: id[0],
      id: id.substr(1)
    };
  };

  Twitch.prototype.parseChannel = function (result, params) {
    var channel = params.channel || params.utm_content || result.channel;
    delete params.utm_content;
    delete params.channel;
    return channel;
  };

  Twitch.prototype.parseUrl = function (url, result, params) {
    var match;
    match = url.match(/(clips\.)?twitch\.tv\/(?:(?:videos\/(\d+))|(\w+(?:-[\w\d-]+)?)(?:\/clip\/(\w+))?)/i);

    if (match && match[2]) {
      //video
      result.id = 'v' + match[2];
    } else if (params.video) {
      //video embed
      result.id = params.video;
      delete params.video;
    } else if (params.clip) {
      //clips embed
      result.id = params.clip;
      result.isClip = true;
      delete params.clip;
    } else if (match && match[1] && match[3]) {
      //clips.twitch.tv/id
      result.id = match[3];
      result.isClip = true;
    } else if (match && match[3] && match[4]) {
      //twitch.tv/channel/clip/id
      result.channel = match[3];
      result.id = match[4];
      result.isClip = true;
    } else if (match && match[3]) {
      result.channel = match[3];
    }

    return result;
  };

  Twitch.prototype.parseMediaType = function (result) {
    var mediaType;

    if (result.id) {
      if (result.isClip) {
        mediaType = this.mediaTypes.CLIP;
        delete result.isClip;
      } else {
        mediaType = this.mediaTypes.VIDEO;
      }
    } else if (result.channel) {
      mediaType = this.mediaTypes.STREAM;
    }

    return mediaType;
  };

  Twitch.prototype.parseParameters = function (params) {
    if (params.t) {
      params.start = getTime$2(params.t);
      delete params.t;
    }

    return params;
  };

  Twitch.prototype.parse = function (url, params) {
    var _this = this;

    var result = {};
    result = _this.parseUrl(url, result, params);
    result.channel = _this.parseChannel(result, params);
    result.mediaType = _this.parseMediaType(result);
    result.params = _this.parseParameters(params);
    return result.channel || result.id ? result : undefined;
  };

  Twitch.prototype.createLongUrl = function (vi, params) {
    var url = '';

    if (vi.mediaType === this.mediaTypes.STREAM && vi.channel) {
      url = 'https://twitch.tv/' + vi.channel;
    } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
      var sep = this.seperateId(vi.id);
      url = 'https://twitch.tv/videos/' + sep.id;

      if (params.start) {
        params.t = params.start + 's';
        delete params.start;
      }
    } else if (vi.mediaType === this.mediaTypes.CLIP && vi.id) {
      if (vi.channel) {
        url = 'https://www.twitch.tv/' + vi.channel + '/clip/' + vi.id;
      } else {
        url = 'https://clips.twitch.tv/' + vi.id;
      }
    } else {
      return undefined;
    }

    url += combineParams$5(params);
    return url;
  };

  Twitch.prototype.createEmbedUrl = function (vi, params) {
    var url = 'https://player.twitch.tv/';

    if (vi.mediaType === this.mediaTypes.STREAM && vi.channel) {
      params.channel = vi.channel;
    } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
      params.video = vi.id;

      if (params.start) {
        params.t = params.start + 's';
        delete params.start;
      }
    } else if (vi.mediaType === this.mediaTypes.CLIP && vi.id) {
      url = 'https://clips.twitch.tv/embed';
      params.clip = vi.id;
    } else {
      return undefined;
    }

    url += combineParams$5(params);
    return url;
  };

  base.bind(new Twitch());

  var combineParams$6 = util.combineParams,
      getTime$3 = util.getTime;

  function Vimeo() {
    this.provider = 'vimeo';
    this.alternatives = ['vimeopro'];
    this.defaultFormat = 'long';
    this.formats = {
      "long": this.createLongUrl,
      embed: this.createEmbedUrl
    };
    this.mediaTypes = {
      VIDEO: 'video'
    };
  }

  Vimeo.prototype.parseUrl = function (url) {
    var match = url.match(/(?:\/showcase\/\d+)?(?:\/(?:channels\/[\w]+|(?:(?:album\/\d+|groups\/[\w]+)\/)?videos?))?\/(\d+)/i);
    return match ? match[1] : undefined;
  };

  Vimeo.prototype.parseHash = function (url) {
    var match = url.match(/\/\d+\/(\w+)$/i);
    return match ? match[1] : undefined;
  };

  Vimeo.prototype.parseParameters = function (params) {
    if (params.t) {
      params.start = getTime$3(params.t);
      delete params.t;
    }

    if (params.h) {
      params.hash = params.h;
      delete params.h;
    }

    return params;
  };

  Vimeo.prototype.parse = function (url, params) {
    var result = {
      mediaType: this.mediaTypes.VIDEO,
      params: this.parseParameters(params),
      id: this.parseUrl(url)
    };
    var hash = this.parseHash(url, params);

    if (hash) {
      result.params.hash = hash;
    }

    return result.id ? result : undefined;
  };

  Vimeo.prototype.createUrl = function (baseUrl, vi, params, type) {
    if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
      return undefined;
    }

    var url = baseUrl + vi.id;
    var startTime = params.start;
    delete params.start;

    if (params.hash) {
      if (type === 'embed') {
        params.h = params.hash;
      } else if (type === 'long') {
        url += '/' + params.hash;
      }

      delete params.hash;
    }

    url += combineParams$6(params);

    if (startTime) {
      url += '#t=' + startTime;
    }

    return url;
  };

  Vimeo.prototype.createLongUrl = function (vi, params) {
    return this.createUrl('https://vimeo.com/', vi, params, 'long');
  };

  Vimeo.prototype.createEmbedUrl = function (vi, params) {
    return this.createUrl('//player.vimeo.com/video/', vi, params, 'embed');
  };

  base.bind(new Vimeo());

  var combineParams$7 = util.combineParams,
      getTime$4 = util.getTime;

  function Wistia() {
    this.provider = 'wistia';
    this.alternatives = [];
    this.defaultFormat = 'long';
    this.formats = {
      "long": this.createLongUrl,
      embed: this.createEmbedUrl,
      embedjsonp: this.createEmbedJsonpUrl
    };
    this.mediaTypes = {
      VIDEO: 'video',
      EMBEDVIDEO: 'embedvideo'
    };
  }

  Wistia.prototype.parseUrl = function (url) {
    var match = url.match(/(?:(?:medias|iframe)\/|wvideo=)([\w-]+)/);
    return match ? match[1] : undefined;
  };

  Wistia.prototype.parseChannel = function (url) {
    var match = url.match(/(?:(?:https?:)?\/\/)?([^.]*)\.wistia\./);
    var channel = match ? match[1] : undefined;

    if (channel === 'fast' || channel === 'content') {
      return undefined;
    }

    return channel;
  };

  Wistia.prototype.parseParameters = function (params, result) {
    if (params.wtime) {
      params.start = getTime$4(params.wtime);
      delete params.wtime;
    }

    if (params.wvideo === result.id) {
      delete params.wvideo;
    }

    return params;
  };

  Wistia.prototype.parseMediaType = function (result) {
    if (result.id && result.channel) {
      return this.mediaTypes.VIDEO;
    } else if (result.id) {
      delete result.channel;
      return this.mediaTypes.EMBEDVIDEO;
    } else {
      return undefined;
    }
  };

  Wistia.prototype.parse = function (url, params) {
    var result = {
      id: this.parseUrl(url),
      channel: this.parseChannel(url)
    };
    result.params = this.parseParameters(params, result);
    result.mediaType = this.parseMediaType(result);

    if (!result.id) {
      return undefined;
    }

    return result;
  };

  Wistia.prototype.createUrl = function (vi, params, url) {
    if (params.start) {
      params.wtime = params.start;
      delete params.start;
    }

    url += combineParams$7(params);
    return url;
  };

  Wistia.prototype.createLongUrl = function (vi, params) {
    if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
      return undefined;
    }

    var url = 'https://' + vi.channel + '.wistia.com/medias/' + vi.id;
    return this.createUrl(vi, params, url);
  };

  Wistia.prototype.createEmbedUrl = function (vi, params) {
    if (!vi.id || !(vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.EMBEDVIDEO)) {
      return undefined;
    }

    var url = 'https://fast.wistia.com/embed/iframe/' + vi.id;
    return this.createUrl(vi, params, url);
  };

  Wistia.prototype.createEmbedJsonpUrl = function (vi) {
    if (!vi.id || !(vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.EMBEDVIDEO)) {
      return undefined;
    }

    return 'https://fast.wistia.com/embed/medias/' + vi.id + '.jsonp';
  };

  base.bind(new Wistia());

  var combineParams$8 = util.combineParams;

  function Youku() {
    this.provider = 'youku';
    this.defaultFormat = 'long';
    this.formats = {
      embed: this.createEmbedUrl,
      "long": this.createLongUrl,
      flash: this.createFlashUrl,
      "static": this.createStaticUrl
    };
    this.mediaTypes = {
      VIDEO: 'video'
    };
  }

  Youku.prototype.parseUrl = function (url) {
    var match = url.match(/(?:(?:embed|sid)\/|v_show\/id_|VideoIDS=)([a-zA-Z0-9]+)/);
    return match ? match[1] : undefined;
  };

  Youku.prototype.parseParameters = function (params) {
    if (params.VideoIDS) {
      delete params.VideoIDS;
    }

    return params;
  };

  Youku.prototype.parse = function (url, params) {
    var _this = this;

    var result = {
      mediaType: this.mediaTypes.VIDEO,
      id: _this.parseUrl(url),
      params: _this.parseParameters(params)
    };

    if (!result.id) {
      return undefined;
    }

    return result;
  };

  Youku.prototype.createUrl = function (baseUrl, vi, params) {
    if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
      return undefined;
    }

    var url = baseUrl + vi.id;
    url += combineParams$8(params);
    return url;
  };

  Youku.prototype.createEmbedUrl = function (vi, params) {
    return this.createUrl('http://player.youku.com/embed/', vi, params);
  };

  Youku.prototype.createLongUrl = function (vi, params) {
    return this.createUrl('http://v.youku.com/v_show/id_', vi, params);
  };

  Youku.prototype.createStaticUrl = function (vi, params) {
    return this.createUrl('http://static.youku.com/v1.0.0638/v/swf/loader.swf?VideoIDS=', vi, params);
  };

  Youku.prototype.createFlashUrl = function (vi, params) {
    if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
      return undefined;
    }

    var url = 'http://player.youku.com/player.php/sid/' + vi.id + '/v.swf';
    url += combineParams$8(params);
    return url;
  };

  base.bind(new Youku());

  var combineParams$9 = util.combineParams,
      getTime$5 = util.getTime;

  function YouTube() {
    this.provider = 'youtube';
    this.alternatives = ['youtu', 'ytimg'];
    this.defaultFormat = 'long';
    this.formats = {
      "short": this.createShortUrl,
      "long": this.createLongUrl,
      embed: this.createEmbedUrl,
      shortImage: this.createShortImageUrl,
      longImage: this.createLongImageUrl
    };
    this.imageQualities = {
      '0': '0',
      '1': '1',
      '2': '2',
      '3': '3',
      DEFAULT: 'default',
      HQDEFAULT: 'hqdefault',
      SDDEFAULT: 'sddefault',
      MQDEFAULT: 'mqdefault',
      MAXRESDEFAULT: 'maxresdefault'
    };
    this.defaultImageQuality = this.imageQualities.HQDEFAULT;
    this.mediaTypes = {
      VIDEO: 'video',
      PLAYLIST: 'playlist',
      SHARE: 'share',
      CHANNEL: 'channel'
    };
  }

  YouTube.prototype.parseVideoUrl = function (url) {
    var match = url.match(/(?:(?:v|vi|be|videos|embed)\/(?!videoseries)|(?:v|ci)=)([\w-]{11})/i);
    return match ? match[1] : undefined;
  };

  YouTube.prototype.parseChannelUrl = function (url) {
    // Match an opaque channel ID
    var match = url.match(/\/channel\/([\w-]+)/);

    if (match) {
      return {
        id: match[1],
        mediaType: this.mediaTypes.CHANNEL
      };
    } // Match a vanity channel name or a user name. User urls are deprecated and
    // currently redirect to the channel of that same name.


    match = url.match(/\/(?:c|user)\/([\w-]+)/);

    if (match) {
      return {
        name: match[1],
        mediaType: this.mediaTypes.CHANNEL
      };
    }
  };

  YouTube.prototype.parseParameters = function (params, result) {
    if (params.start || params.t) {
      params.start = getTime$5(params.start || params.t);
      delete params.t;
    }

    if (params.v === result.id) {
      delete params.v;
    }

    if (params.list === result.id) {
      delete params.list;
    }

    return params;
  };

  YouTube.prototype.parseMediaType = function (result) {
    if (result.params.list) {
      result.list = result.params.list;
      delete result.params.list;
    }

    if (result.id && !result.params.ci) {
      result.mediaType = this.mediaTypes.VIDEO;
    } else if (result.list) {
      delete result.id;
      result.mediaType = this.mediaTypes.PLAYLIST;
    } else if (result.params.ci) {
      delete result.params.ci;
      result.mediaType = this.mediaTypes.SHARE;
    } else {
      return undefined;
    }

    return result;
  };

  YouTube.prototype.parse = function (url, params) {
    var channelResult = this.parseChannelUrl(url);

    if (channelResult) {
      return channelResult;
    } else {
      var result = {
        params: params,
        id: this.parseVideoUrl(url)
      };
      result.params = this.parseParameters(params, result);
      result = this.parseMediaType(result);
      return result;
    }
  };

  YouTube.prototype.createShortUrl = function (vi, params) {
    if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
      return undefined;
    }

    var url = 'https://youtu.be/' + vi.id;

    if (params.start) {
      url += '#t=' + params.start;
    }

    return url;
  };

  YouTube.prototype.createLongUrl = function (vi, params) {
    var url = '';
    var startTime = params.start;
    delete params.start;

    if (vi.mediaType === this.mediaTypes.CHANNEL) {
      if (vi.id) {
        url += 'https://www.youtube.com/channel/' + vi.id;
      } else if (vi.name) {
        url += 'https://www.youtube.com/c/' + vi.name;
      } else {
        return undefined;
      }
    } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list) {
      params.feature = 'share';
      url += 'https://www.youtube.com/playlist';
    } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
      params.v = vi.id;
      url += 'https://www.youtube.com/watch';
    } else if (vi.mediaType === this.mediaTypes.SHARE && vi.id) {
      params.ci = vi.id;
      url += 'https://www.youtube.com/shared';
    } else {
      return undefined;
    }

    if (vi.list) {
      params.list = vi.list;
    }

    url += combineParams$9(params);

    if (vi.mediaType !== this.mediaTypes.PLAYLIST && startTime) {
      url += '#t=' + startTime;
    }

    return url;
  };

  YouTube.prototype.createEmbedUrl = function (vi, params) {
    var url = 'https://www.youtube.com/embed';

    if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list) {
      params.listType = 'playlist';
    } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
      url += '/' + vi.id; //loop hack

      if (params.loop === '1') {
        params.playlist = vi.id;
      }
    } else {
      return undefined;
    }

    if (vi.list) {
      params.list = vi.list;
    }

    url += combineParams$9(params);
    return url;
  };

  YouTube.prototype.createImageUrl = function (baseUrl, vi, params) {
    if (!vi.id || vi.mediaType !== this.mediaTypes.VIDEO) {
      return undefined;
    }

    var url = baseUrl + vi.id + '/';
    var quality = params.imageQuality || this.defaultImageQuality;
    return url + quality + '.jpg';
  };

  YouTube.prototype.createShortImageUrl = function (vi, params) {
    return this.createImageUrl('https://i.ytimg.com/vi/', vi, params);
  };

  YouTube.prototype.createLongImageUrl = function (vi, params) {
    return this.createImageUrl('https://img.youtube.com/vi/', vi, params);
  };

  base.bind(new YouTube());

  var combineParams$a = util.combineParams,
      getTime$6 = util.getTime;

  function SoundCloud() {
    this.provider = 'soundcloud';
    this.defaultFormat = 'long';
    this.formats = {
      "long": this.createLongUrl,
      embed: this.createEmbedUrl
    };
    this.mediaTypes = {
      TRACK: 'track',
      PLAYLIST: 'playlist',
      APITRACK: 'apitrack',
      APIPLAYLIST: 'apiplaylist'
    };
  }

  SoundCloud.prototype.parseUrl = function (url, result) {
    var match = url.match(/(?:m\.)?soundcloud\.com\/(?:([\w-]+)\/(sets\/)?)([\w-]+)/i);

    if (!match) {
      return result;
    }

    result.channel = match[1];

    if (match[1] === 'playlists' || match[2]) {
      //playlist
      result.list = match[3];
    } else {
      //track
      result.id = match[3];
    }

    return result;
  };

  SoundCloud.prototype.parseParameters = function (params) {
    if (params.t) {
      params.start = getTime$6(params.t);
      delete params.t;
    }

    return params;
  };

  SoundCloud.prototype.parseMediaType = function (result) {
    if (result.id) {
      if (result.channel === 'tracks') {
        delete result.channel;
        delete result.params.url;
        result.mediaType = this.mediaTypes.APITRACK;
      } else {
        result.mediaType = this.mediaTypes.TRACK;
      }
    }

    if (result.list) {
      if (result.channel === 'playlists') {
        delete result.channel;
        delete result.params.url;
        result.mediaType = this.mediaTypes.APIPLAYLIST;
      } else {
        result.mediaType = this.mediaTypes.PLAYLIST;
      }
    }

    return result;
  };

  SoundCloud.prototype.parse = function (url, params) {
    var result = {};
    result = this.parseUrl(url, result);
    result.params = this.parseParameters(params);
    result = this.parseMediaType(result);

    if (!result.id && !result.list) {
      return undefined;
    }

    return result;
  };

  SoundCloud.prototype.createLongUrl = function (vi, params) {
    var url = '';
    var startTime = params.start;
    delete params.start;

    if (vi.mediaType === this.mediaTypes.TRACK && vi.id && vi.channel) {
      url = 'https://soundcloud.com/' + vi.channel + '/' + vi.id;
    } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.list && vi.channel) {
      url = 'https://soundcloud.com/' + vi.channel + '/sets/' + vi.list;
    } else if (vi.mediaType === this.mediaTypes.APITRACK && vi.id) {
      url = 'https://api.soundcloud.com/tracks/' + vi.id;
    } else if (vi.mediaType === this.mediaTypes.APIPLAYLIST && vi.list) {
      url = 'https://api.soundcloud.com/playlists/' + vi.list;
    } else {
      return undefined;
    }

    url += combineParams$a(params);

    if (startTime) {
      url += '#t=' + startTime;
    }

    return url;
  };

  SoundCloud.prototype.createEmbedUrl = function (vi, params) {
    var url = 'https://w.soundcloud.com/player/';
    delete params.start;

    if (vi.mediaType === this.mediaTypes.APITRACK && vi.id) {
      params.url = 'https%3A//api.soundcloud.com/tracks/' + vi.id;
    } else if (vi.mediaType === this.mediaTypes.APIPLAYLIST && vi.list) {
      params.url = 'https%3A//api.soundcloud.com/playlists/' + vi.list;
    } else {
      return undefined;
    }

    url += combineParams$a(params);
    return url;
  };

  base.bind(new SoundCloud());

  var combineParams$b = util.combineParams;

  function TeacherTube() {
    this.provider = 'teachertube';
    this.alternatives = [];
    this.defaultFormat = 'long';
    this.formats = {
      "long": this.createLongUrl,
      embed: this.createEmbedUrl
    };
    this.mediaTypes = {
      VIDEO: 'video',
      AUDIO: 'audio',
      DOCUMENT: 'document',
      CHANNEL: 'channel',
      COLLECTION: 'collection',
      GROUP: 'group'
    };
  }

  TeacherTube.prototype.parse = function (url, params) {
    var result = {};
    result.list = this.parsePlaylist(params);
    result.params = params;
    var match = url.match(/\/(audio|video|document|user\/channel|collection|group)\/(?:[\w-]+-)?(\w+)/);

    if (!match) {
      return undefined;
    }

    result.mediaType = this.parseMediaType(match[1]);
    result.id = match[2];
    return result;
  };

  TeacherTube.prototype.parsePlaylist = function (params) {
    if (params['playlist-id']) {
      var list = params['playlist-id'];
      delete params['playlist-id'];
      return list;
    }

    return undefined;
  };

  TeacherTube.prototype.parseMediaType = function (mediaTypeMatch) {
    switch (mediaTypeMatch) {
      case 'audio':
        return this.mediaTypes.AUDIO;

      case 'video':
        return this.mediaTypes.VIDEO;

      case 'document':
        return this.mediaTypes.DOCUMENT;

      case 'user/channel':
        return this.mediaTypes.CHANNEL;

      case 'collection':
        return this.mediaTypes.COLLECTION;

      case 'group':
        return this.mediaTypes.GROUP;
    }
  };

  TeacherTube.prototype.createLongUrl = function (vi, params) {
    if (!vi.id) {
      return undefined;
    }

    var url = 'https://www.teachertube.com/';

    if (vi.list) {
      params['playlist-id'] = vi.list;
    }

    if (vi.mediaType === this.mediaTypes.CHANNEL) {
      url += 'user/channel/';
    } else {
      url += vi.mediaType + '/';
    }

    url += vi.id;
    url += combineParams$b(params);
    return url;
  };

  TeacherTube.prototype.createEmbedUrl = function (vi, params) {
    if (!vi.id) {
      return undefined;
    }

    var url = 'https://www.teachertube.com/embed/';

    if (vi.mediaType === this.mediaTypes.VIDEO || vi.mediaType === this.mediaTypes.AUDIO) {
      url += vi.mediaType + '/' + vi.id;
    } else {
      return undefined;
    }

    url += combineParams$b(params);
    return url;
  };

  base.bind(new TeacherTube());

  var combineParams$c = util.combineParams;

  function TikTok() {
    this.provider = 'tiktok';
    this.defaultFormat = 'long';
    this.formats = {
      "long": this.createLongUrl
    };
    this.mediaTypes = {
      VIDEO: 'video'
    };
  }

  TikTok.prototype.parse = function (url, params) {
    var result = {
      params: params,
      mediaType: this.mediaTypes.VIDEO
    };
    var match = url.match(/@([^/]+)\/video\/(\d{19})/);

    if (!match) {
      return;
    }

    result.channel = match[1];
    result.id = match[2];
    return result;
  };

  TikTok.prototype.createLongUrl = function (vi, params) {
    var url = '';

    if (vi.mediaType === this.mediaTypes.VIDEO && vi.id && vi.channel) {
      url += "https://www.tiktok.com/@".concat(vi.channel, "/video/").concat(vi.id);
    } else {
      return undefined;
    }

    url += combineParams$c(params);
    return url;
  };

  base.bind(new TikTok());

  var combineParams$d = util.combineParams;

  function Ted() {
    this.provider = 'ted';
    this.formats = {
      "long": this.createLongUrl,
      embed: this.createEmbedUrl
    };
    this.mediaTypes = {
      VIDEO: 'video',
      PLAYLIST: 'playlist'
    };
  }

  Ted.prototype.parseUrl = function (url, result) {
    var match = url.match(/\/(talks|playlists\/(\d+))\/([\w-]+)/i);
    var channel = match ? match[1] : undefined;

    if (!channel) {
      return result;
    }

    result.channel = channel.split('/')[0];
    result.id = match[3];

    if (result.channel === 'playlists') {
      result.list = match[2];
    }

    return result;
  };

  Ted.prototype.parseMediaType = function (result) {
    if (result.id && result.channel === 'playlists') {
      delete result.channel;
      result.mediaType = this.mediaTypes.PLAYLIST;
    }

    if (result.id && result.channel === 'talks') {
      delete result.channel;
      result.mediaType = this.mediaTypes.VIDEO;
    }

    return result;
  };

  Ted.prototype.parse = function (url, params) {
    var result = {
      params: params
    };
    result = this.parseUrl(url, result);
    result = this.parseMediaType(result);

    if (!result.id) {
      return undefined;
    }

    return result;
  };

  Ted.prototype.createLongUrl = function (vi, params) {
    var url = '';

    if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
      url += 'https://ted.com/talks/' + vi.id;
    } else if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.id) {
      url += 'https://ted.com/playlists/' + vi.list + '/' + vi.id;
    } else {
      return undefined;
    }

    url += combineParams$d(params);
    return url;
  };

  Ted.prototype.createEmbedUrl = function (vi, params) {
    var url = 'https://embed.ted.com/';

    if (vi.mediaType === this.mediaTypes.PLAYLIST && vi.id) {
      url += 'playlists/' + vi.list + '/' + vi.id;
    } else if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
      url += 'talks/' + vi.id;
    } else {
      return undefined;
    }

    url += combineParams$d(params);
    return url;
  };

  base.bind(new Ted());

  var combineParams$e = util.combineParams;

  function Facebook() {
    this.provider = 'facebook';
    this.alternatives = [];
    this.defaultFormat = 'long';
    this.formats = {
      "long": this.createLongUrl,
      watch: this.createWatchUrl
    };
    this.mediaTypes = {
      VIDEO: 'video'
    };
  }

  Facebook.prototype.parse = function (url, params) {
    var result = {
      params: params,
      mediaType: this.mediaTypes.VIDEO
    };
    var match = url.match(/(?:\/(\d+))?\/videos(?:\/.*?)?\/(\d+)/i);

    if (match) {
      if (match[1]) {
        result.pageId = match[1];
      }

      result.id = match[2];
    }

    if (params.v && !result.id) {
      result.id = params.v;
      delete params.v;
      result.params = params;
    }

    if (!result.id) {
      return undefined;
    }

    return result;
  };

  Facebook.prototype.createWatchUrl = function (vi, params) {
    var url = 'https://facebook.com/watch/';

    if (vi.mediaType !== this.mediaTypes.VIDEO || !vi.id) {
      return undefined;
    }

    params = {
      v: vi.id
    };
    url += combineParams$e(params);
    return url;
  };

  Facebook.prototype.createLongUrl = function (vi, params) {
    var url = 'https://facebook.com/';

    if (vi.pageId) {
      url += vi.pageId;
    } else {
      return undefined;
    }

    if (vi.mediaType === this.mediaTypes.VIDEO && vi.id) {
      url += '/videos/' + vi.id;
    } else {
      return undefined;
    }

    url += combineParams$e(params);
    return url;
  };

  base.bind(new Facebook());

  var lib = base;

  return lib;

})));
});

const resizeLengthToRelative = (length, parentLength) => {
  if (typeof length === 'number') {
    return `${length / parentLength * 100}%`;
  }

  return length;
};

const resizeLengthToStatic = (length, parentLength) => {
  if (typeof length === 'string') {
    return parentLength * parseFloat(length) / 100;
  }

  return length;
};

const resizeLengthClampStatic = (length, {
  min,
  max
}) => {
  if (min !== undefined) {
    length = Math.max(length, min);
  }

  if (max !== undefined) {
    length = Math.min(length, max);
  }

  return length;
};

const resizeLengthClamp = (length, parentLength, {
  min,
  max
}) => {
  const staticLength = resizeLengthToStatic(length, parentLength);
  const clampedStaticLength = resizeLengthClampStatic(staticLength, {
    min: min !== undefined ? resizeLengthToStatic(min, parentLength) : undefined,
    max: max !== undefined ? resizeLengthToStatic(max, parentLength) : undefined
  });

  switch (typeof length) {
    case 'string':
      return resizeLengthToRelative(clampedStaticLength, parentLength);

    case 'number':
      return clampedStaticLength;

    default:
      throw new Error('Invalid length type');
  }
};

const isTouchEvent = event => 'touches' in event;

const useResizeHandleProps = ({
  direction,
  width = 10,
  startMargin = 0,
  endMargin = 0,
  zIndex = 40,
  onResize,
  onMouseDown,
  onTouchStart,
  onHover,
  onHoverEnd,
  style,
  ...props
}) => {
  const [isResizing, setIsResizing] = React.useState(false);
  const [initialPosition, setInitialPosition] = React.useState(0);
  const [initialSize, setInitialSize] = React.useState(0);
  const isHorizontal = direction === 'left' || direction === 'right';

  const handleMouseDown = event => {
    const {
      clientX,
      clientY
    } = event;
    setInitialPosition(isHorizontal ? clientX : clientY);
    const element = event.target.parentElement;
    setInitialSize(isHorizontal ? element.offsetWidth : element.offsetHeight);
    setIsResizing(true);
    onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(event);
  };

  const handleTouchStart = event => {
    const {
      touches
    } = event;
    const touch = touches[0];
    const {
      clientX,
      clientY
    } = touch;
    setInitialPosition(isHorizontal ? clientX : clientY);
    const element = event.target.parentElement;
    setInitialSize(isHorizontal ? element.offsetWidth : element.offsetHeight);
    setIsResizing(true);
    onTouchStart === null || onTouchStart === void 0 ? void 0 : onTouchStart(event);
  };

  React.useEffect(() => {
    if (!isResizing) return;

    const sendResizeEvent = (event, finished) => {
      const {
        clientX,
        clientY
      } = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
      const currentPosition = isHorizontal ? clientX : clientY;
      const delta = currentPosition - initialPosition;
      onResize === null || onResize === void 0 ? void 0 : onResize({
        initialSize,
        delta,
        finished,
        direction
      });
    };

    const handleMouseMove = event => sendResizeEvent(event, false);

    const handleMouseUp = event => {
      setIsResizing(false);
      onHoverEnd === null || onHoverEnd === void 0 ? void 0 : onHoverEnd();
      sendResizeEvent(event, true);
    };

    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);
    window.addEventListener('touchmove', handleMouseMove);
    window.addEventListener('touchend', handleMouseUp);
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
      window.removeEventListener('touchmove', handleMouseMove);
      window.removeEventListener('touchend', handleMouseUp);
    };
  }, [isResizing, initialPosition, initialSize, onResize, isHorizontal, onHoverEnd, direction]);

  const handleMouseOver = () => {
    onHover === null || onHover === void 0 ? void 0 : onHover();
  };

  const handleMouseOut = () => {
    if (!isResizing) {
      onHoverEnd === null || onHoverEnd === void 0 ? void 0 : onHoverEnd();
    }
  };

  const nearSide = direction;
  const start = isHorizontal ? 'top' : 'left';
  const end = isHorizontal ? 'bottom' : 'right';
  const size = isHorizontal ? 'width' : 'height';
  return {
    style: {
      position: 'absolute',
      [nearSide]: -width / 2,
      [start]: startMargin,
      [end]: endMargin,
      [size]: width,
      zIndex,
      cursor: isHorizontal ? 'col-resize' : 'row-resize',
      ...style
    },
    onMouseDown: handleMouseDown,
    onTouchStart: handleTouchStart,
    onMouseOver: handleMouseOver,
    onMouseOut: handleMouseOut,
    onTouchMove: handleMouseOver,
    onTouchEnd: handleMouseOut,
    ...props
  };
};

plateCommon.createComponentAs(props => {
  const htmlProps = useResizeHandleProps(props);
  return plateCommon.createElementAs('div', htmlProps);
});

const captionGlobalStore = plateCommon.createStore('caption')({
  /**
   * When defined, focus end of caption textarea with the same path.
   */
  focusEndCaptionPath: null,

  /**
   * When defined, focus start of caption textarea with the same path.
   */
  focusStartCaptionPath: null
});

function unwrapExports(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var lib = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * Constants.
   */
  // We make this a function so it can be tested in describe block mocks with Jest.

  var IS_MAC = () => typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);

  var MODIFIERS = {
    alt: 'altKey',
    control: 'ctrlKey',
    meta: 'metaKey',
    shift: 'shiftKey'
  }; // We make this a function so it can be tested in describe block mocks with Jest.

  var ALIASES = () => ({
    add: '+',
    break: 'pause',
    cmd: 'meta',
    command: 'meta',
    ctl: 'control',
    ctrl: 'control',
    del: 'delete',
    down: 'arrowdown',
    esc: 'escape',
    ins: 'insert',
    left: 'arrowleft',
    mod: IS_MAC() ? 'meta' : 'control',
    opt: 'alt',
    option: 'alt',
    return: 'enter',
    right: 'arrowright',
    space: ' ',
    spacebar: ' ',
    up: 'arrowup',
    win: 'meta',
    windows: 'meta'
  });

  var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    ' ': 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ';': 186,
    '=': 187,
    ',': 188,
    '-': 189,
    '.': 190,
    '/': 191,
    '`': 192,
    '[': 219,
    '\\': 220,
    ']': 221,
    '\'': 222
  };

  for (var f = 1; f < 20; f++) {
    CODES['f' + f] = 111 + f;
  }
  /**
   * Is hotkey?
   */


  function isHotkey(hotkey, options, event) {
    if (options && !('byKey' in options)) {
      event = options;
      options = null;
    }

    if (!Array.isArray(hotkey)) {
      hotkey = [hotkey];
    }

    var array = hotkey.map(function (string) {
      return parseHotkey(string, options);
    });

    var check = function check(e) {
      return array.some(function (object) {
        return compareHotkey(object, e);
      });
    };

    var ret = event == null ? check : check(event);
    return ret;
  }

  function isCodeHotkey(hotkey, event) {
    return isHotkey(hotkey, event);
  }

  function isKeyHotkey(hotkey, event) {
    return isHotkey(hotkey, {
      byKey: true
    }, event);
  }
  /**
   * Parse.
   */


  function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {}; // Special case to handle the `+` key since we use it as a separator.

    hotkey = hotkey.replace('++', '+add');
    var values = hotkey.split('+');
    var length = values.length; // Ensure that all the modifiers are set to false unless the hotkey has them.

    for (var k in MODIFIERS) {
      ret[MODIFIERS[k]] = false;
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        var optional = value.endsWith('?') && value.length > 1;

        if (optional) {
          value = value.slice(0, -1);
        }

        var name = toKeyName(value);
        var modifier = MODIFIERS[name];

        if (length === 1 || !modifier) {
          if (byKey) {
            ret.key = name;
          } else {
            ret.which = toKeyCode(value);
          }
        }

        if (modifier) {
          ret[modifier] = optional ? null : true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return ret;
  }
  /**
   * Compare.
   */


  function compareHotkey(object, event) {
    for (var key in object) {
      var expected = object[key];
      var actual = void 0;

      if (expected == null) {
        continue;
      }

      if (key === 'key' && event.key != null) {
        actual = event.key.toLowerCase();
      } else if (key === 'which') {
        actual = expected === 91 && event.which === 93 ? 91 : event.which;
      } else {
        actual = event[key];
      }

      if (actual == null && expected === false) {
        continue;
      }

      if (actual !== expected) {
        return false;
      }
    }

    return true;
  }
  /**
   * Utils.
   */


  function toKeyCode(name) {
    name = toKeyName(name);
    var code = CODES[name] || name.toUpperCase().charCodeAt(0);
    return code;
  }

  function toKeyName(name) {
    name = name.toLowerCase();
    name = ALIASES()[name] || name;
    return name;
  }
  /**
   * Export.
   */


  exports.default = isHotkey;
  exports.isHotkey = isHotkey;
  exports.isCodeHotkey = isCodeHotkey;
  exports.isKeyHotkey = isKeyHotkey;
  exports.parseHotkey = parseHotkey;
  exports.compareHotkey = compareHotkey;
  exports.toKeyCode = toKeyCode;
  exports.toKeyName = toKeyName;
});
var isHotkey = unwrapExports(lib);
lib.isHotkey;
lib.isCodeHotkey;
lib.isKeyHotkey;
lib.parseHotkey;
lib.compareHotkey;
lib.toKeyCode;
lib.toKeyName;

const getOnKeyDownCaption = pluginKey => editor => e => {
  if (e.defaultPrevented) return; // focus caption from image

  if (isHotkey('down', e)) {
    const entry = plateCommon.getBlockAbove(editor, {
      match: {
        type: plateCommon.getPluginType(editor, pluginKey)
      }
    });
    if (!entry) return;
    captionGlobalStore.set.focusEndCaptionPath(entry[1]);
  }
};
/**
 * TODO: tests
 * https://github.com/udecode/editor-protocol/issues/79
 */

/**
 * Selection table:
 * - If anchor is in table, focus in a block before: set focus to start of table
 * - If anchor is in table, focus in a block after: set focus to end of table
 * - If focus is in table, anchor in a block before: set focus to end of table
 * - If focus is in table, anchor in a block after: set focus to the point before start of table
 */


const getWithSelectionCaption = pluginKey => (editor, plugin) => {
  const {
    apply
  } = editor;

  editor.apply = operation => {
    if (operation.type === 'set_selection') {
      const newSelection = { ...editor.selection,
        ...operation.newProperties
      };

      if (editor.currentKeyboardEvent && isHotkey('up', editor.currentKeyboardEvent)) {
        if (newSelection && plateCommon.isCollapsed(newSelection)) {
          const entry = plateCommon.getAboveNode(editor, {
            at: newSelection,
            match: {
              type: plateCommon.getPluginType(editor, pluginKey)
            }
          });

          if (entry) {
            const [node] = entry;

            if (node.caption && plateCommon.getNodeString({
              children: node.caption
            }).length) {
              setTimeout(() => {
                captionGlobalStore.set.focusEndCaptionPath(entry[1]);
              }, 0);
            }
          }
        }
      }
    }

    apply(operation);
  };

  return editor;
};

const {
  resizableStore,
  useResizableStore
} = plateCommon.createAtomStore({
  width: 0
}, {
  name: 'resizable',
  scope: plateCommon.SCOPE_ELEMENT
});

const useCaptionString = () => {
  const {
    caption: nodeCaption = [{
      children: [{
        text: ''
      }]
    }]
  } = plateCommon.useElement();
  return React.useMemo(() => {
    return plateCommon.getNodeString(nodeCaption[0]) || '';
  }, [nodeCaption]);
};

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}
/**
 * `<textarea />` component for React which grows with content.
 * @see https://github.com/Andarist/react-textarea-autosize
 * @see https://github.com/Andarist/react-textarea-autosize/issues/337
 */


const TextareaAutosize = /*#__PURE__*/React.forwardRef((props, ref) => {
  const [isRerendered, setIsRerendered] = React.useState(false);
  React.useLayoutEffect(() => setIsRerendered(true), []);
  return isRerendered ? /*#__PURE__*/React__default["default"].createElement(ReactTextareaAutosize__default["default"], _extends({}, props, {
    ref: ref
  })) : null;
});
/**
 * Focus textareaRef when focusCaptionPath is set to the image path.
 */

const useCaptionTextareaFocus = textareaRef => {
  const editor = plateCommon.useEditorRef();
  const element = plateCommon.useElement();
  const focusCaptionPath = captionGlobalStore.use.focusEndCaptionPath();
  React.useEffect(() => {
    if (focusCaptionPath && textareaRef.current) {
      const path = plateCommon.findNodePath(editor, element);

      if (path && slate.Path.equals(path, focusCaptionPath)) {
        textareaRef.current.focus();
        captionGlobalStore.set.focusEndCaptionPath(null);
      }
    }
  }, [editor, element, focusCaptionPath, textareaRef]);
};

const useCaptionTextarea = props => {
  const element = plateCommon.useElement();
  const {
    caption: nodeCaption = [{
      children: [{
        text: ''
      }]
    }]
  } = element;
  const [captionValue, setCaptionValue] = React.useState(plateCommon.getNodeString(nodeCaption[0]));
  const editor = plateCommon.useEditorRef();
  const readOnly = slateReact.useReadOnly();
  const textareaRef = React.useRef(null);
  const ref = plateCommon.useComposedRef(textareaRef, props.ref);
  useCaptionTextareaFocus(textareaRef);
  const onChange = React.useCallback(e => {
    const newValue = e.target.value; // local state

    setCaptionValue(newValue);
    const path = plateCommon.findNodePath(editor, element);
    if (!path) return; // saved state

    plateCommon.setNodes(editor, {
      caption: [{
        text: newValue
      }]
    }, {
      at: path
    });
  }, [editor, element]);

  const onKeyDown = e => {
    // select image
    if (isHotkey('up', e)) {
      const path = plateCommon.findNodePath(editor, element);
      if (!path) return;
      e.preventDefault();
      plateCommon.focusEditor(editor, path);
    } // select next block


    if (isHotkey('down', e)) {
      const path = plateCommon.findNodePath(editor, element);
      if (!path) return;
      const nextNodePath = plateCommon.getPointAfter(editor, path);
      if (!nextNodePath) return;
      e.preventDefault();
      plateCommon.focusEditor(editor, nextNodePath);
    }
  };

  return {
    value: captionValue,
    readOnly,
    onChange,
    onKeyDown,
    ...props,
    ref
  };
};

plateCommon.createComponentAs(({
  as,
  ...props
}) => {
  const htmlProps = useCaptionTextarea({
    as: as,
    ...props
  });
  return /*#__PURE__*/React__default["default"].createElement(TextareaAutosize, htmlProps);
});

const useCaption = ({
  readOnly,
  ...props
} = {}) => {
  const width = useResizableStore().get.width();
  return {
    style: {
      width
    },
    ...props
  };
};

const useCaptionState = props => {
  const captionString = useCaptionString();
  const selected = slateReact.useSelected();

  const _readOnly = slateReact.useReadOnly();

  const readOnly = props.readOnly || _readOnly;
  return {
    captionString,
    selected,
    readOnly
  };
};

plateCommon.createComponentAs(props => {
  const htmlProps = useCaption(props);
  const {
    captionString,
    selected,
    readOnly
  } = useCaptionState(props);

  if (!captionString.length && (readOnly || !selected)) {
    return null;
  }

  return plateCommon.createElementAs('figcaption', htmlProps);
});

const insertImage = (editor, url) => {
  const text = {
    text: ''
  };
  const image = {
    type: plateCommon.getPluginType(editor, ELEMENT_IMAGE),
    url: url,
    children: [text]
  };
  plateCommon.insertNodes(editor, image);
};

const imageExtensions = ['ase', 'art', 'bmp', 'blp', 'cd5', 'cit', 'cpt', 'cr2', 'cut', 'dds', 'dib', 'djvu', 'egt', 'exif', 'gif', 'gpl', 'grf', 'icns', 'ico', 'iff', 'jng', 'jpeg', 'jpg', 'jfif', 'jp2', 'jps', 'lbm', 'max', 'miff', 'mng', 'msp', 'nitf', 'ota', 'pbm', 'pc1', 'pc2', 'pc3', 'pcf', 'pcx', 'pdn', 'pgm', 'PI1', 'PI2', 'PI3', 'pict', 'pct', 'pnm', 'pns', 'ppm', 'psb', 'psd', 'pdd', 'psp', 'px', 'pxm', 'pxr', 'qfx', 'raw', 'rle', 'sct', 'sgi', 'rgb', 'int', 'bw', 'tga', 'tiff', 'tif', 'vtf', 'xbm', 'xcf', 'xpm', '3dv', 'amf', 'ai', 'awg', 'cgm', 'cdr', 'cmx', 'dxf', 'e2d', 'egt', 'eps', 'fs', 'gbr', 'odg', 'svg', 'stl', 'vrml', 'x3d', 'sxd', 'v2d', 'vnd', 'wmf', 'emf', 'art', 'xar', 'png', 'webp', 'jxr', 'hdp', 'wdp', 'cur', 'ecw', 'iff', 'lbm', 'liff', 'nrrd', 'pam', 'pcx', 'pgf', 'sgi', 'rgb', 'rgba', 'bw', 'int', 'inta', 'sid', 'ras', 'sun', 'tga'];

const isImageUrl = url => {
  if (!plateCommon.isUrl(url)) return false;
  const ext = new URL(url).pathname.split('.').pop();
  return imageExtensions.includes(ext);
};
/**
 * If inserted text is image url, insert image instead.
 */


const withImageEmbed = (editor, plugin) => {
  const {
    insertData
  } = editor;

  editor.insertData = dataTransfer => {
    const text = dataTransfer.getData('text/plain');

    if (isImageUrl(text)) {
      insertImage(editor, text);
      return;
    }

    insertData(dataTransfer);
  };

  return editor;
};
/**
 * Allows for pasting images from clipboard.
 * Not yet: dragging and dropping images, selecting them through a file system dialog.
 */


const withImageUpload = (editor, plugin) => {
  const {
    options: {
      uploadImage
    }
  } = plugin;
  const {
    insertData
  } = editor;

  editor.insertData = dataTransfer => {
    const text = dataTransfer.getData('text/plain');
    const {
      files
    } = dataTransfer;

    if (!text && files && files.length > 0) {
      const injectedPlugins = plateCommon.getInjectedPlugins(editor, plugin);

      if (!plateCommon.pipeInsertDataQuery(injectedPlugins, {
        data: text,
        dataTransfer
      })) {
        return insertData(dataTransfer);
      }

      for (const file of files) {
        const reader = new FileReader();
        const [mime] = file.type.split('/');

        if (mime === 'image') {
          reader.addEventListener('load', async () => {
            if (!reader.result) {
              return;
            }

            const uploadedUrl = uploadImage ? await uploadImage(reader.result) : reader.result;
            insertImage(editor, uploadedUrl);
          });
          reader.readAsDataURL(file);
        }
      }
    } else {
      insertData(dataTransfer);
    }
  };

  return editor;
};
/**
 * @see withImageUpload
 * @see withImageEmbed
 */


const withImage = (editor, plugin) => {
  const {
    options: {
      disableUploadInsert,
      disableEmbedInsert,
      disableCaption
    }
  } = plugin;

  if (!disableUploadInsert) {
    editor = withImageUpload(editor, plugin);
  }

  if (!disableEmbedInsert) {
    editor = withImageEmbed(editor);
  }

  if (!disableCaption) {
    editor = getWithSelectionCaption(ELEMENT_IMAGE)(editor, plugin);
  }

  return editor;
};

const ELEMENT_IMAGE = 'img';
/**
 * Enables support for images.
 */

plateCommon.createPluginFactory({
  key: ELEMENT_IMAGE,
  isElement: true,
  isVoid: true,
  withOverrides: withImage,
  handlers: {
    onKeyDown: getOnKeyDownCaption(ELEMENT_IMAGE)
  },
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      rules: [{
        validNodeName: 'IMG'
      }],
      getNode: el => ({
        type,
        url: el.getAttribute('src')
      })
    }
  })
});

const useImage = props => {
  const {
    url
  } = plateCommon.useElement();
  const captionString = useCaptionString();
  return {
    src: url,
    alt: captionString,
    draggable: true,
    ...props
  };
};

plateCommon.createComponentAs(props => {
  const htmlProps = useImage(props);
  return plateCommon.createElementAs('img', htmlProps);
});
const twitterRegex = /^https?:\/\/twitter\.com\/(?:#!\/)?(\w+)\/status(es)?\/(?<id>\d+)/;

const parseTwitterUrl = url => {
  if (url.match(twitterRegex)) {
    var _twitterRegex$exec, _twitterRegex$exec$gr;

    return {
      provider: 'twitter',
      id: (_twitterRegex$exec = twitterRegex.exec(url)) === null || _twitterRegex$exec === void 0 ? void 0 : (_twitterRegex$exec$gr = _twitterRegex$exec.groups) === null || _twitterRegex$exec$gr === void 0 ? void 0 : _twitterRegex$exec$gr.id,
      url
    };
  }
};

const useMediaEmbedTweet = ({
  id,
  ...props
}) => {
  return {
    tweetId: id,
    ...props
  };
};

const MediaEmbedTweet = props => {
  const htmlProps = useMediaEmbedTweet(props);
  return /*#__PURE__*/React__default["default"].createElement(Tweet, htmlProps);
};

const WIDGET_SCRIPT_URL = 'https://platform.twitter.com/widgets.js';

const Tweet = ({
  tweetId,
  onError,
  onLoad,
  loadingComponent,
  twitterOptions = {}
}) => {
  const [isLoading, setIsLoading] = React.useState(true);
  const containerRef = React.useRef(null);
  const previousTweetIDRef = React.useRef('');
  const {
    cards,
    theme
  } = twitterOptions;
  const createTweet = React.useCallback(async () => {
    try {
      await window.twttr.widgets.createTweet(tweetId, containerRef.current, {
        cards,
        theme
      });
      setIsLoading(false);

      if (onLoad) {
        onLoad();
      }
    } catch (error) {
      if (onError) {
        onError(String(error));
      }
    }
  }, [onError, onLoad, tweetId, cards, theme]);
  React.useEffect(() => {
    if (tweetId !== previousTweetIDRef.current) {
      let isComponentMounted = true;

      const script = require('scriptjs');

      script(WIDGET_SCRIPT_URL, 'twitter-embed', () => {
        if (!window.twttr) {
          return console.error('Failure to load window.twttr.');
        }

        if (isComponentMounted) createTweet();
      });

      if (previousTweetIDRef) {
        previousTweetIDRef.current = tweetId;
      }

      return () => {
        isComponentMounted = false;
      };
    }
  }, [createTweet, onError, onLoad, tweetId]);
  return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, isLoading ? loadingComponent : null, /*#__PURE__*/React__default["default"].createElement("div", {
    key: tweetId,
    ref: containerRef
  }));
};

const YOUTUBE_PREFIX = 'https://www.youtube.com/embed/';
const VIMEO_PREFIX = 'https://player.vimeo.com/video/';
const DAILYMOTION_PREFIX = 'https://www.dailymotion.com/embed/video/';
const YOUKU_PREFIX = 'https://player.youku.com/embed/';
const COUB_PREFIX = 'https://coub.com/embed/';

const parseVideoUrl = url => {
  if (!plateCommon.isUrl(url)) return;
  const videoData = jsVideoUrlParser.parse(url);

  if (videoData !== null && videoData !== void 0 && videoData.provider && videoData.id) {
    const {
      id,
      provider
    } = videoData;
    const providerUrls = {
      youtube: `${YOUTUBE_PREFIX}${id}`,
      vimeo: `${VIMEO_PREFIX}${id}`,
      dailymotion: `${DAILYMOTION_PREFIX}${id}`,
      youku: `${YOUKU_PREFIX}${id}`,
      coub: `${COUB_PREFIX}${id}`
    };
    return {
      id,
      provider,
      url: providerUrls[provider]
    };
  }
};

const useMediaEmbedVideo = ({ ...props
}) => {
  const {
    url
  } = useMediaStore().get.urlData();
  return {
    title: 'embed',
    frameBorder: '0',
    allowFullScreen: true,
    src: url,
    ...props
  };
};

const MediaEmbedVideo = props => {
  const htmlProps = useMediaEmbedVideo(props);
  return plateCommon.createElementAs('iframe', htmlProps);
};

const parseIframeUrl = url => {
  // if not starting with http, assume pasting of full iframe embed code
  if (url.substring(0, 4) !== 'http') {
    var _url$match, _src$match;

    const regexMatchSrc = /src=".*?"/;
    const regexGroupQuotes = /"([^"]*)"/;
    const src = (_url$match = url.match(regexMatchSrc)) === null || _url$match === void 0 ? void 0 : _url$match[0];
    const returnString = src === null || src === void 0 ? void 0 : (_src$match = src.match(regexGroupQuotes)) === null || _src$match === void 0 ? void 0 : _src$match[1];

    if (returnString) {
      url = returnString;
    }
  }

  return url;
};

const ELEMENT_MEDIA_EMBED = 'media_embed';
/**
 * Enables support for embeddable media such as YouTube
 * or Vimeo videos, Instagram posts and tweets or Google Maps.
 */

plateCommon.createPluginFactory({
  key: ELEMENT_MEDIA_EMBED,
  isElement: true,
  isVoid: true,
  handlers: {
    onKeyDown: getOnKeyDownCaption(ELEMENT_MEDIA_EMBED)
  },
  withOverrides: (editor, plugin) => {
    const {
      options: {
        disableCaption
      }
    } = plugin;

    if (!disableCaption) {
      editor = getWithSelectionCaption(ELEMENT_MEDIA_EMBED)(editor, plugin);
    }

    return editor;
  },
  options: {
    transformUrl: parseIframeUrl,
    rules: [{
      parser: parseTwitterUrl,
      component: MediaEmbedTweet
    }, {
      parser: parseVideoUrl,
      component: MediaEmbedVideo
    }]
  },
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      rules: [{
        validNodeName: 'IFRAME'
      }],
      getNode: el => {
        const url = el.getAttribute('src');

        if (url) {
          return {
            type,
            url
          };
        }
      }
    }
  })
});
const {
  mediaStore,
  useMediaStore
} = plateCommon.createAtomStore({
  urlData: {}
}, {
  name: 'media',
  scope: plateCommon.SCOPE_ELEMENT
});

const useResizable = ({
  align = 'center',
  readOnly,
  minWidth = 92,
  maxWidth = '100%',
  renderHandleLeft,
  renderHandleRight,
  ...props
}) => {
  var _element$width;

  const element = plateCommon.useElement();
  const editor = plateCommon.useEditorRef();

  const _readOnly = slateReact.useReadOnly();

  readOnly = plateCommon.isDefined(readOnly) ? readOnly : _readOnly;
  const wrapperRef = React.useRef(null);
  const nodeWidth = (_element$width = element === null || element === void 0 ? void 0 : element.width) !== null && _element$width !== void 0 ? _element$width : '100%';
  const [width, setWidth] = useResizableStore().use.width();
  const setNodeWidth = React.useCallback(w => {
    const path = plateCommon.findNodePath(editor, element);
    if (!path) return;

    if (w === nodeWidth) {
      // Focus the node if not resized
      plateCommon.select(editor, path);
    } else {
      plateCommon.setNodes(editor, {
        width: w
      }, {
        at: path
      });
    }
  }, [editor, element, nodeWidth]);
  React.useEffect(() => {
    setWidth(nodeWidth);
  }, [nodeWidth, setWidth]);
  const handleResize = React.useCallback(({
    initialSize,
    delta,
    finished,
    direction
  }) => {
    const wrapperStaticWidth = wrapperRef.current.offsetWidth;
    const deltaFactor = (align === 'center' ? 2 : 1) * (direction === 'left' ? -1 : 1);
    const newWidth = resizeLengthClamp(initialSize + delta * deltaFactor, wrapperStaticWidth, {
      min: minWidth,
      max: maxWidth
    });

    if (finished) {
      setNodeWidth(newWidth);
    } else {
      setWidth(newWidth);
    }
  }, [align, maxWidth, minWidth, setNodeWidth, setWidth]); // Remove style except for cursor

  const handlePropsLeft = { ...useResizeHandleProps({
      direction: 'left',
      onResize: handleResize
    }),
    style: {
      cursor: 'ew-resize'
    }
  };
  const handlePropsRight = { ...useResizeHandleProps({
      direction: 'right',
      onResize: handleResize
    }),
    style: {
      cursor: 'ew-resize'
    }
  };
  const handleLeft = !readOnly && align !== 'left' && (renderHandleLeft === null || renderHandleLeft === void 0 ? void 0 : renderHandleLeft(handlePropsLeft));
  const handleRight = !readOnly && align !== 'right' && (renderHandleRight === null || renderHandleRight === void 0 ? void 0 : renderHandleRight(handlePropsRight));
  return {
    wrapperProps: {
      ref: wrapperRef,
      style: {
        position: 'relative'
      }
    },
    resizableProps: {
      style: {
        width,
        minWidth,
        maxWidth,
        position: 'relative'
      }
    },
    handleLeft,
    handleRight,
    restProps: props
  };
};

plateCommon.createComponentAs(({
  children,
  ...props
}) => {
  const {
    wrapperProps,
    resizableProps,
    handleLeft,
    handleRight,
    restProps
  } = useResizable(props);
  return /*#__PURE__*/React__default["default"].createElement("div", wrapperProps, /*#__PURE__*/React__default["default"].createElement("div", _extends({}, resizableProps, restProps), handleLeft, children, handleRight));
});

const parseMediaUrl = (editor, {
  pluginKey,
  url
}) => {
  if (!url) return;
  const {
    rules
  } = plateCommon.getPluginOptions(editor, pluginKey);
  if (!rules) return;

  for (const {
    parser,
    component
  } of rules) {
    const parsed = parser(url);

    if (parsed) {
      return { ...parsed,
        component
      };
    }
  }
};

const useMedia = ({
  pluginKey = ELEMENT_MEDIA_EMBED,
  ...props
}) => {
  const editor = plateCommon.useEditorRef();
  const element = plateCommon.useElement();
  const setUrlData = useMediaStore().set.urlData();
  const {
    url: elementUrl
  } = element;
  React.useEffect(() => {
    const parsed = parseMediaUrl(editor, {
      pluginKey,
      url: elementUrl
    });

    if (parsed) {
      setUrlData(parsed);
    }
  }, [editor, elementUrl, pluginKey, setUrlData]);
  return plateCommon.useElementProps(props);
};

plateCommon.createComponentAs(props => {
  const htmlProps = useMedia(props);
  return plateCommon.createElementAs('div', htmlProps);
});
const ELEMENT_MEDIA = 'media';
const floatingMediaStore = plateCommon.createStore('floatingMedia')({
  url: '',
  isEditing: false
}).extendActions(set => ({
  reset: () => {
    set.url('');
    set.isEditing(false);
  }
}));
const floatingMediaActions = floatingMediaStore.set;
const floatingMediaSelectors = floatingMediaStore.get;

const useFloatingMediaEditButton = props => {
  const element = plateCommon.useElement();
  return {
    onClick: React.useCallback(() => {
      floatingMediaActions.url(element.url);
      floatingMediaActions.isEditing(true);
    }, [element.url]),
    ...props
  };
};

plateCommon.createComponentAs(props => {
  const htmlProps = useFloatingMediaEditButton(props);
  return plateCommon.createElementAs('button', htmlProps);
});

const submitFloatingMedia = (editor, {
  element,
  pluginKey = ELEMENT_MEDIA
}) => {
  let url = floatingMediaSelectors.url();

  if (url === element.url) {
    floatingMediaActions.reset();
    return true;
  }

  const {
    isUrl: _isUrl = plateCommon.isUrl,
    transformUrl
  } = plateCommon.getPluginOptions(editor, pluginKey);

  const isValid = _isUrl(url);

  if (!isValid) return;

  if (transformUrl) {
    url = transformUrl(url);
  }

  plateCommon.setNodes(editor, {
    url
  });
  floatingMediaActions.reset();
  plateCommon.focusEditor(editor, editor.selection);
  return true;
};

const useFloatingMediaUrlInput = ({
  pluginKey,
  ...props
}) => {
  const editor = plateCommon.useEditorRef();
  const element = plateCommon.useElement();
  React.useEffect(() => {
    return () => {
      floatingMediaActions.isEditing(false);
    };
  }, []);
  plateCommon.useHotkeys('enter', e => {
    if (submitFloatingMedia(editor, {
      element,
      pluginKey
    })) {
      e.preventDefault();
    }
  }, {
    enableOnFormTags: ['INPUT']
  }, []);
  plateCommon.useHotkeys('escape', () => {
    if (floatingMediaSelectors.isEditing()) {
      floatingMediaActions.reset();
      plateCommon.focusEditor(editor, editor.selection);
    }
  }, {
    enableOnFormTags: ['INPUT'],
    enableOnContentEditable: true
  }, []);
  const onChange = React.useCallback(e => {
    floatingMediaActions.url(e.target.value);
  }, []);
  return plateCommon.mergeProps({
    onChange,
    autoFocus: true,
    defaultValue: floatingMediaSelectors.url()
  }, props);
};

plateCommon.createComponentAs(props => {
  const htmlProps = useFloatingMediaUrlInput(props);
  return plateCommon.createElementAs('input', htmlProps);
});

const remarkTextTypes = ['emphasis', 'strong', 'delete', 'inlineCode', 'html', 'text'];

const remarkTransformElement = (node, options) => {
  const {
    elementRules
  } = options;
  const {
    type
  } = node;
  const elementRule = elementRules[type];
  if (!elementRule) return [];
  return elementRule.transform(node, options);
};

const MARK_BOLD = 'bold';
/**
 * Enables support for bold formatting
 */

const createBoldPlugin = plateCommon.createPluginFactory({
  key: MARK_BOLD,
  isLeaf: true,
  deserializeHtml: {
    rules: [{
      validNodeName: ['STRONG', 'B']
    }, {
      validStyle: {
        fontWeight: ['600', '700', 'bold']
      }
    }],
    query: el => !plateCommon.someHtmlElement(el, node => node.style.fontWeight === 'normal')
  },
  handlers: {
    onKeyDown: plateCommon.onKeyDownToggleMark
  },
  options: {
    hotkey: 'mod+b'
  }
});
const MARK_CODE = 'code';
/**
 * Enables support for code formatting
 */

const createCodePlugin = plateCommon.createPluginFactory({
  key: MARK_CODE,
  isLeaf: true,
  deserializeHtml: {
    rules: [{
      validNodeName: ['CODE']
    }, {
      validStyle: {
        wordWrap: 'break-word'
      }
    }, {
      validStyle: {
        fontFamily: 'Consolas'
      }
    }],

    query(el) {
      const blockAbove = plateCommon.findHtmlParentElement(el, 'P');
      if ((blockAbove === null || blockAbove === void 0 ? void 0 : blockAbove.style.fontFamily) === 'Consolas') return false;
      return !plateCommon.findHtmlParentElement(el, 'PRE');
    }

  },
  handlers: {
    onKeyDown: plateCommon.onKeyDownToggleMark
  },
  options: {
    hotkey: 'mod+e'
  }
});
const MARK_ITALIC = 'italic';
/**
 * Enables support for italic formatting.
 */

const createItalicPlugin = plateCommon.createPluginFactory({
  key: MARK_ITALIC,
  isLeaf: true,
  handlers: {
    onKeyDown: plateCommon.onKeyDownToggleMark
  },
  options: {
    hotkey: 'mod+i'
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ['EM', 'I']
    }, {
      validStyle: {
        fontStyle: 'italic'
      }
    }],
    query: el => !plateCommon.someHtmlElement(el, node => node.style.fontStyle === 'normal')
  }
});
const MARK_STRIKETHROUGH = 'strikethrough';
/**
 * Enables support for strikethrough formatting.
 */

const createStrikethroughPlugin = plateCommon.createPluginFactory({
  key: MARK_STRIKETHROUGH,
  isLeaf: true,
  handlers: {
    onKeyDown: plateCommon.onKeyDownToggleMark
  },
  options: {
    hotkey: 'mod+shift+x'
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ['S', 'DEL', 'STRIKE']
    }, {
      validStyle: {
        textDecoration: 'line-through'
      }
    }],
    query: el => !plateCommon.someHtmlElement(el, node => node.style.textDecoration === 'none')
  }
});
const MARK_SUBSCRIPT$1 = 'subscript';
const MARK_SUPERSCRIPT$1 = 'superscript';
/**
 * Enables support for subscript formatting.
 */

const createSubscriptPlugin = plateCommon.createPluginFactory({
  key: MARK_SUBSCRIPT$1,
  isLeaf: true,
  handlers: {
    onKeyDown: plateCommon.onKeyDownToggleMark
  },
  options: {
    hotkey: 'mod+,',
    clear: MARK_SUPERSCRIPT$1
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ['SUB']
    }, {
      validStyle: {
        verticalAlign: 'sub'
      }
    }]
  }
});
const MARK_SUPERSCRIPT = 'superscript';
const MARK_SUBSCRIPT = 'subscript';
/**
 * Enables support for superscript formatting.
 */

const createSuperscriptPlugin = plateCommon.createPluginFactory({
  key: MARK_SUPERSCRIPT,
  isLeaf: true,
  handlers: {
    onKeyDown: plateCommon.onKeyDownToggleMark
  },
  options: {
    hotkey: 'mod+.',
    clear: MARK_SUBSCRIPT
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ['SUP']
    }, {
      validStyle: {
        verticalAlign: 'super'
      }
    }]
  }
});
const MARK_UNDERLINE = 'underline';
/**
 * Enables support for underline formatting.
 */

const createUnderlinePlugin = plateCommon.createPluginFactory({
  key: MARK_UNDERLINE,
  isLeaf: true,
  handlers: {
    onKeyDown: plateCommon.onKeyDownToggleMark
  },
  options: {
    hotkey: 'mod+u'
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ['U']
    }, {
      validStyle: {
        textDecoration: ['underline']
      }
    }],
    query: el => !plateCommon.someHtmlElement(el, node => node.style.textDecoration === 'none')
  }
});
/**
 * Enables support for basic marks:
 * - Bold
 * - Code
 * - Italic
 * - Strikethrough
 * - Subscript
 * - Superscript
 * - Underline
 */

plateCommon.createPluginFactory({
  key: 'basicMarks',
  plugins: [createBoldPlugin(), createCodePlugin(), createItalicPlugin(), createStrikethroughPlugin(), createSubscriptPlugin(), createSuperscriptPlugin(), createUnderlinePlugin()]
});

const remarkDefaultTextRules = {
  text: {},
  emphasis: {
    mark: ({
      editor
    }) => plateCommon.getPluginType(editor, MARK_ITALIC)
  },
  strong: {
    mark: ({
      editor
    }) => plateCommon.getPluginType(editor, MARK_BOLD)
  },
  inlineCode: {
    mark: ({
      editor
    }) => plateCommon.getPluginType(editor, MARK_CODE)
  },
  html: {
    transform: text => text.replace(/<br>/g, '\n')
  }
};

const remarkTransformText = (node, options, inheritedMarkProps = {}) => {
  const {
    editor,
    textRules
  } = options;
  const {
    type,
    value,
    children
  } = node;
  const textRule = textRules[type] || remarkDefaultTextRules.text;
  const {
    mark,
    transform = text => text
  } = textRule;
  const markProps = mark ? { ...inheritedMarkProps,
    [mark({
      editor
    })]: true
  } : inheritedMarkProps;
  const childTextNodes = (children === null || children === void 0 ? void 0 : children.flatMap(child => remarkTransformText(child, options, markProps))) || [];
  const currentTextNodes = value || childTextNodes.length === 0 ? [{
    text: transform(value || ''),
    ...markProps
  }] : [];
  return [...currentTextNodes, ...childTextNodes];
};

const remarkTransformNode = (node, options) => {
  const {
    type
  } = node;

  if (remarkTextTypes.includes(type)) {
    return remarkTransformText(node, options);
  }

  return remarkTransformElement(node, options);
};

const remarkTransformElementChildren = (node, options) => {
  const {
    children
  } = node;
  if (!children) return [];
  return children.flatMap(child => remarkTransformNode(child, options));
};

// FIXME: underline, subscript superscript not yet supported by remark-slate
const remarkDefaultElementRules = {
  heading: {
    transform: (node, options) => {
      var _node$depth;

      const headingType = {
        1: plateHeading.ELEMENT_H1,
        2: plateHeading.ELEMENT_H2,
        3: plateHeading.ELEMENT_H3,
        4: plateHeading.ELEMENT_H4,
        5: plateHeading.ELEMENT_H5,
        6: plateHeading.ELEMENT_H6
      }[(_node$depth = node.depth) !== null && _node$depth !== void 0 ? _node$depth : 1];
      return {
        type: plateCommon.getPluginType(options.editor, headingType),
        children: remarkTransformElementChildren(node, options)
      };
    }
  },
  list: {
    transform: (node, options) => ({
      type: plateCommon.getPluginType(options.editor, node.ordered ? plateList.ELEMENT_OL : plateList.ELEMENT_UL),
      children: remarkTransformElementChildren(node, options)
    })
  },
  listItem: {
    transform: (node, options) => ({
      type: plateCommon.getPluginType(options.editor, plateList.ELEMENT_LI),
      children: remarkTransformElementChildren(node, options).map(child => ({ ...child,
        type: child.type === plateCommon.getPluginType(options.editor, plateParagraph.ELEMENT_PARAGRAPH) ? plateCommon.getPluginType(options.editor, plateList.ELEMENT_LIC) : child.type
      }))
    })
  },
  paragraph: {
    transform: (node, options) => {
      const children = remarkTransformElementChildren(node, options);
      const paragraphType = plateCommon.getPluginType(options.editor, plateParagraph.ELEMENT_PARAGRAPH);
      const splitBlockTypes = [plateCommon.getPluginType(options.editor, ELEMENT_IMAGE)];
      const elements = [];
      let inlineNodes = [];

      const flushInlineNodes = () => {
        if (inlineNodes.length > 0) {
          elements.push({
            type: paragraphType,
            children: inlineNodes
          });
          inlineNodes = [];
        }
      };

      children.forEach(child => {
        const {
          type
        } = child;

        if (type && splitBlockTypes.includes(type)) {
          flushInlineNodes();
          elements.push(child);
        } else {
          inlineNodes.push(child);
        }
      });
      flushInlineNodes();
      return elements;
    }
  },
  link: {
    transform: (node, options) => ({
      type: plateCommon.getPluginType(options.editor, plateLink.ELEMENT_LINK),
      url: node.url,
      children: remarkTransformElementChildren(node, options)
    })
  },
  image: {
    transform: (node, options) => ({
      type: plateCommon.getPluginType(options.editor, ELEMENT_IMAGE),
      children: [{
        text: ''
      }],
      url: node.url,
      caption: [{
        text: node.alt
      }]
    })
  },
  blockquote: {
    transform: (node, options) => {
      return {
        type: plateCommon.getPluginType(options.editor, plateBlockQuote.ELEMENT_BLOCKQUOTE),
        children: node.children.flatMap(paragraph => remarkTransformElementChildren(paragraph, options))
      };
    }
  },
  code: {
    transform: (node, options) => {
      var _node$lang;

      return {
        type: plateCommon.getPluginType(options.editor, plateCodeBlock.ELEMENT_CODE_BLOCK),
        lang: (_node$lang = node.lang) !== null && _node$lang !== void 0 ? _node$lang : undefined,
        children: (node.value || '').split('\n').map(line => ({
          type: plateCommon.getPluginType(options.editor, plateCodeBlock.ELEMENT_CODE_LINE),
          children: [{
            text: line
          }]
        }))
      };
    }
  },
  thematicBreak: {
    transform: (node, options) => ({
      type: plateCommon.getPluginType(options.editor, ELEMENT_HR),
      children: [{
        text: ''
      }]
    })
  }
};

function remarkPlugin(options) {
  const compiler = node => {
    return node.children.flatMap(child => remarkTransformNode(child, options));
  }; // @ts-ignore


  this.Compiler = compiler;
}

/**
 * Deserialize content from Markdown format to Slate format.
 * `editor` needs
 */
const deserializeMd = (editor, data) => {
  const {
    elementRules,
    textRules
  } = plateCommon.getPluginOptions(editor, KEY_DESERIALIZE_MD);
  const tree = unified__default["default"]().use(markdown__default["default"]).use(remarkPlugin, {
    editor,
    elementRules,
    textRules
  }).processSync(data);
  return tree.result;
};

const filterBreaklines = item => !item.text;

const KEY_DESERIALIZE_MD = 'deserializeMd';
const createDeserializeMdPlugin = plateCommon.createPluginFactory({
  key: KEY_DESERIALIZE_MD,
  then: editor => ({
    editor: {
      insertData: {
        format: 'text/plain',
        query: ({
          data,
          dataTransfer
        }) => {
          const htmlData = dataTransfer.getData('text/html');
          if (htmlData) return false;
          const {
            files
          } = dataTransfer;

          if (!(files !== null && files !== void 0 && files.length)) {
            // if content is simply a URL pass through to not break LinkPlugin
            if (plateCommon.isUrl(data)) {
              return false;
            }
          }

          return true;
        },
        getFragment: ({
          data
        }) => deserializeMd(editor, data)
      }
    }
  }),
  options: {
    elementRules: remarkDefaultElementRules,
    textRules: remarkDefaultTextRules
  }
});

exports.KEY_DESERIALIZE_MD = KEY_DESERIALIZE_MD;
exports.createDeserializeMdPlugin = createDeserializeMdPlugin;
exports.deserializeMd = deserializeMd;
exports.filterBreaklines = filterBreaklines;
exports.remarkDefaultElementRules = remarkDefaultElementRules;
exports.remarkDefaultTextRules = remarkDefaultTextRules;
exports.remarkPlugin = remarkPlugin;
exports.remarkTextTypes = remarkTextTypes;
exports.remarkTransformElement = remarkTransformElement;
exports.remarkTransformElementChildren = remarkTransformElementChildren;
exports.remarkTransformNode = remarkTransformNode;
exports.remarkTransformText = remarkTransformText;
//# sourceMappingURL=index.js.map
