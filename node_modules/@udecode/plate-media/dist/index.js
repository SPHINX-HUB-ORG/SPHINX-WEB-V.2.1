'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var plateCommon = require('@udecode/plate-common');
var slateReact = require('slate-react');
var React = require('react');
var slate = require('slate');
var ReactTextareaAutosize = require('react-textarea-autosize');
var videoParser = require('js-video-url-parser');
var resizable = require('@udecode/resizable');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var ReactTextareaAutosize__default = /*#__PURE__*/_interopDefaultLegacy(ReactTextareaAutosize);
var videoParser__default = /*#__PURE__*/_interopDefaultLegacy(videoParser);

const captionGlobalStore = plateCommon.createStore('caption')({
  /**
   * When defined, focus end of caption textarea with the same path.
   */
  focusEndCaptionPath: null,

  /**
   * When defined, focus start of caption textarea with the same path.
   */
  focusStartCaptionPath: null
});

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var lib = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Constants.
 */

// We make this a function so it can be tested in describe block mocks with Jest.
var IS_MAC = () => typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);

var MODIFIERS = {
  alt: 'altKey',
  control: 'ctrlKey',
  meta: 'metaKey',
  shift: 'shiftKey'
};

// We make this a function so it can be tested in describe block mocks with Jest.
var ALIASES = () => ({
  add: '+',
  break: 'pause',
  cmd: 'meta',
  command: 'meta',
  ctl: 'control',
  ctrl: 'control',
  del: 'delete',
  down: 'arrowdown',
  esc: 'escape',
  ins: 'insert',
  left: 'arrowleft',
  mod: IS_MAC() ? 'meta' : 'control',
  opt: 'alt',
  option: 'alt',
  return: 'enter',
  right: 'arrowright',
  space: ' ',
  spacebar: ' ',
  up: 'arrowup',
  win: 'meta',
  windows: 'meta'
});

var CODES = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  ' ': 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ';': 186,
  '=': 187,
  ',': 188,
  '-': 189,
  '.': 190,
  '/': 191,
  '`': 192,
  '[': 219,
  '\\': 220,
  ']': 221,
  '\'': 222
};

for (var f = 1; f < 20; f++) {
  CODES['f' + f] = 111 + f;
}

/**
 * Is hotkey?
 */

function isHotkey(hotkey, options, event) {
  if (options && !('byKey' in options)) {
    event = options;
    options = null;
  }

  if (!Array.isArray(hotkey)) {
    hotkey = [hotkey];
  }

  var array = hotkey.map(function (string) {
    return parseHotkey(string, options);
  });
  var check = function check(e) {
    return array.some(function (object) {
      return compareHotkey(object, e);
    });
  };
  var ret = event == null ? check : check(event);
  return ret;
}

function isCodeHotkey(hotkey, event) {
  return isHotkey(hotkey, event);
}

function isKeyHotkey(hotkey, event) {
  return isHotkey(hotkey, { byKey: true }, event);
}

/**
 * Parse.
 */

function parseHotkey(hotkey, options) {
  var byKey = options && options.byKey;
  var ret = {};

  // Special case to handle the `+` key since we use it as a separator.
  hotkey = hotkey.replace('++', '+add');
  var values = hotkey.split('+');
  var length = values.length;

  // Ensure that all the modifiers are set to false unless the hotkey has them.

  for (var k in MODIFIERS) {
    ret[MODIFIERS[k]] = false;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;

      var optional = value.endsWith('?') && value.length > 1;

      if (optional) {
        value = value.slice(0, -1);
      }

      var name = toKeyName(value);
      var modifier = MODIFIERS[name];

      if (length === 1 || !modifier) {
        if (byKey) {
          ret.key = name;
        } else {
          ret.which = toKeyCode(value);
        }
      }

      if (modifier) {
        ret[modifier] = optional ? null : true;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return ret;
}

/**
 * Compare.
 */

function compareHotkey(object, event) {
  for (var key in object) {
    var expected = object[key];
    var actual = void 0;

    if (expected == null) {
      continue;
    }

    if (key === 'key' && event.key != null) {
      actual = event.key.toLowerCase();
    } else if (key === 'which') {
      actual = expected === 91 && event.which === 93 ? 91 : event.which;
    } else {
      actual = event[key];
    }

    if (actual == null && expected === false) {
      continue;
    }

    if (actual !== expected) {
      return false;
    }
  }

  return true;
}

/**
 * Utils.
 */

function toKeyCode(name) {
  name = toKeyName(name);
  var code = CODES[name] || name.toUpperCase().charCodeAt(0);
  return code;
}

function toKeyName(name) {
  name = name.toLowerCase();
  name = ALIASES()[name] || name;
  return name;
}

/**
 * Export.
 */

exports.default = isHotkey;
exports.isHotkey = isHotkey;
exports.isCodeHotkey = isCodeHotkey;
exports.isKeyHotkey = isKeyHotkey;
exports.parseHotkey = parseHotkey;
exports.compareHotkey = compareHotkey;
exports.toKeyCode = toKeyCode;
exports.toKeyName = toKeyName;
});

var isHotkey = unwrapExports(lib);
lib.isHotkey;
lib.isCodeHotkey;
lib.isKeyHotkey;
lib.parseHotkey;
lib.compareHotkey;
lib.toKeyCode;
lib.toKeyName;

const getOnKeyDownCaption = pluginKey => editor => e => {
  if (e.defaultPrevented) return; // focus caption from image

  if (isHotkey('down', e)) {
    const entry = plateCommon.getBlockAbove(editor, {
      match: {
        type: plateCommon.getPluginType(editor, pluginKey)
      }
    });
    if (!entry) return;
    captionGlobalStore.set.focusEndCaptionPath(entry[1]);
  }
};

/**
 * TODO: tests
 * https://github.com/udecode/editor-protocol/issues/79
 */

/**
 * Selection table:
 * - If anchor is in table, focus in a block before: set focus to start of table
 * - If anchor is in table, focus in a block after: set focus to end of table
 * - If focus is in table, anchor in a block before: set focus to end of table
 * - If focus is in table, anchor in a block after: set focus to the point before start of table
 */

const getWithSelectionCaption = pluginKey => (editor, plugin) => {
  const {
    apply
  } = editor;

  editor.apply = operation => {
    if (operation.type === 'set_selection') {
      const newSelection = { ...editor.selection,
        ...operation.newProperties
      };

      if (editor.currentKeyboardEvent && isHotkey('up', editor.currentKeyboardEvent)) {
        if (newSelection && plateCommon.isCollapsed(newSelection)) {
          const entry = plateCommon.getAboveNode(editor, {
            at: newSelection,
            match: {
              type: plateCommon.getPluginType(editor, pluginKey)
            }
          });

          if (entry) {
            const [node] = entry;

            if (node.caption && plateCommon.getNodeString({
              children: node.caption
            }).length) {
              setTimeout(() => {
                captionGlobalStore.set.focusEndCaptionPath(entry[1]);
              }, 0);
            }
          }
        }
      }
    }

    apply(operation);
  };

  return editor;
};

const {
  resizableStore,
  useResizableStore
} = plateCommon.createAtomStore({
  width: 0
}, {
  name: 'resizable',
  scope: plateCommon.SCOPE_ELEMENT
});

const useCaptionString = () => {
  const {
    caption: nodeCaption = [{
      children: [{
        text: ''
      }]
    }]
  } = plateCommon.useElement();
  return React.useMemo(() => {
    return plateCommon.getNodeString(nodeCaption[0]) || '';
  }, [nodeCaption]);
};

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

/**
 * `<textarea />` component for React which grows with content.
 * @see https://github.com/Andarist/react-textarea-autosize
 * @see https://github.com/Andarist/react-textarea-autosize/issues/337
 */

const TextareaAutosize = /*#__PURE__*/React.forwardRef((props, ref) => {
  const [isRerendered, setIsRerendered] = React.useState(false);
  React.useLayoutEffect(() => setIsRerendered(true), []);
  return isRerendered ? /*#__PURE__*/React__default["default"].createElement(ReactTextareaAutosize__default["default"], _extends({}, props, {
    ref: ref
  })) : null;
});

/**
 * Focus textareaRef when focusCaptionPath is set to the image path.
 */
const useCaptionTextareaFocus = textareaRef => {
  const editor = plateCommon.useEditorRef();
  const element = plateCommon.useElement();
  const focusCaptionPath = captionGlobalStore.use.focusEndCaptionPath();
  React.useEffect(() => {
    if (focusCaptionPath && textareaRef.current) {
      const path = plateCommon.findNodePath(editor, element);

      if (path && slate.Path.equals(path, focusCaptionPath)) {
        textareaRef.current.focus();
        captionGlobalStore.set.focusEndCaptionPath(null);
      }
    }
  }, [editor, element, focusCaptionPath, textareaRef]);
};
const useCaptionTextarea = props => {
  const element = plateCommon.useElement();
  const {
    caption: nodeCaption = [{
      children: [{
        text: ''
      }]
    }]
  } = element;
  const [captionValue, setCaptionValue] = React.useState(plateCommon.getNodeString(nodeCaption[0]));
  const editor = plateCommon.useEditorRef();
  const readOnly = slateReact.useReadOnly();
  const textareaRef = React.useRef(null);
  const ref = plateCommon.useComposedRef(textareaRef, props.ref);
  useCaptionTextareaFocus(textareaRef);
  const onChange = React.useCallback(e => {
    const newValue = e.target.value; // local state

    setCaptionValue(newValue);
    const path = plateCommon.findNodePath(editor, element);
    if (!path) return; // saved state

    plateCommon.setNodes(editor, {
      caption: [{
        text: newValue
      }]
    }, {
      at: path
    });
  }, [editor, element]);

  const onKeyDown = e => {
    // select image
    if (isHotkey('up', e)) {
      const path = plateCommon.findNodePath(editor, element);
      if (!path) return;
      e.preventDefault();
      plateCommon.focusEditor(editor, path);
    } // select next block


    if (isHotkey('down', e)) {
      const path = plateCommon.findNodePath(editor, element);
      if (!path) return;
      const nextNodePath = plateCommon.getPointAfter(editor, path);
      if (!nextNodePath) return;
      e.preventDefault();
      plateCommon.focusEditor(editor, nextNodePath);
    }
  };

  return {
    value: captionValue,
    readOnly,
    onChange,
    onKeyDown,
    ...props,
    ref
  };
};
const CaptionTextarea = plateCommon.createComponentAs(({
  as,
  ...props
}) => {
  const htmlProps = useCaptionTextarea({
    as: as,
    ...props
  });
  return /*#__PURE__*/React__default["default"].createElement(TextareaAutosize, htmlProps);
});

const useCaption = ({
  readOnly,
  ...props
} = {}) => {
  const width = useResizableStore().get.width();
  return {
    style: {
      width
    },
    ...props
  };
};
const useCaptionState = props => {
  const captionString = useCaptionString();
  const selected = slateReact.useSelected();

  const _readOnly = slateReact.useReadOnly();

  const readOnly = props.readOnly || _readOnly;
  return {
    captionString,
    selected,
    readOnly
  };
};
const CaptionRoot = plateCommon.createComponentAs(props => {
  const htmlProps = useCaption(props);
  const {
    captionString,
    selected,
    readOnly
  } = useCaptionState(props);

  if (!captionString.length && (readOnly || !selected)) {
    return null;
  }

  return plateCommon.createElementAs('figcaption', htmlProps);
});
const Caption = {
  Root: CaptionRoot,
  Textarea: CaptionTextarea
};

const insertImage = (editor, url) => {
  const text = {
    text: ''
  };
  const image = {
    type: plateCommon.getPluginType(editor, ELEMENT_IMAGE),
    url: url,
    children: [text]
  };
  plateCommon.insertNodes(editor, image);
};

const imageExtensions = ['ase', 'art', 'bmp', 'blp', 'cd5', 'cit', 'cpt', 'cr2', 'cut', 'dds', 'dib', 'djvu', 'egt', 'exif', 'gif', 'gpl', 'grf', 'icns', 'ico', 'iff', 'jng', 'jpeg', 'jpg', 'jfif', 'jp2', 'jps', 'lbm', 'max', 'miff', 'mng', 'msp', 'nitf', 'ota', 'pbm', 'pc1', 'pc2', 'pc3', 'pcf', 'pcx', 'pdn', 'pgm', 'PI1', 'PI2', 'PI3', 'pict', 'pct', 'pnm', 'pns', 'ppm', 'psb', 'psd', 'pdd', 'psp', 'px', 'pxm', 'pxr', 'qfx', 'raw', 'rle', 'sct', 'sgi', 'rgb', 'int', 'bw', 'tga', 'tiff', 'tif', 'vtf', 'xbm', 'xcf', 'xpm', '3dv', 'amf', 'ai', 'awg', 'cgm', 'cdr', 'cmx', 'dxf', 'e2d', 'egt', 'eps', 'fs', 'gbr', 'odg', 'svg', 'stl', 'vrml', 'x3d', 'sxd', 'v2d', 'vnd', 'wmf', 'emf', 'art', 'xar', 'png', 'webp', 'jxr', 'hdp', 'wdp', 'cur', 'ecw', 'iff', 'lbm', 'liff', 'nrrd', 'pam', 'pcx', 'pgf', 'sgi', 'rgb', 'rgba', 'bw', 'int', 'inta', 'sid', 'ras', 'sun', 'tga'];
const isImageUrl = url => {
  if (!plateCommon.isUrl(url)) return false;
  const ext = new URL(url).pathname.split('.').pop();
  return imageExtensions.includes(ext);
};

/**
 * If inserted text is image url, insert image instead.
 */
const withImageEmbed = (editor, plugin) => {
  const {
    insertData
  } = editor;

  editor.insertData = dataTransfer => {
    const text = dataTransfer.getData('text/plain');

    if (isImageUrl(text)) {
      insertImage(editor, text);
      return;
    }

    insertData(dataTransfer);
  };

  return editor;
};

/**
 * Allows for pasting images from clipboard.
 * Not yet: dragging and dropping images, selecting them through a file system dialog.
 */
const withImageUpload = (editor, plugin) => {
  const {
    options: {
      uploadImage
    }
  } = plugin;
  const {
    insertData
  } = editor;

  editor.insertData = dataTransfer => {
    const text = dataTransfer.getData('text/plain');
    const {
      files
    } = dataTransfer;

    if (!text && files && files.length > 0) {
      const injectedPlugins = plateCommon.getInjectedPlugins(editor, plugin);

      if (!plateCommon.pipeInsertDataQuery(injectedPlugins, {
        data: text,
        dataTransfer
      })) {
        return insertData(dataTransfer);
      }

      for (const file of files) {
        const reader = new FileReader();
        const [mime] = file.type.split('/');

        if (mime === 'image') {
          reader.addEventListener('load', async () => {
            if (!reader.result) {
              return;
            }

            const uploadedUrl = uploadImage ? await uploadImage(reader.result) : reader.result;
            insertImage(editor, uploadedUrl);
          });
          reader.readAsDataURL(file);
        }
      }
    } else {
      insertData(dataTransfer);
    }
  };

  return editor;
};

/**
 * @see withImageUpload
 * @see withImageEmbed
 */

const withImage = (editor, plugin) => {
  const {
    options: {
      disableUploadInsert,
      disableEmbedInsert,
      disableCaption
    }
  } = plugin;

  if (!disableUploadInsert) {
    editor = withImageUpload(editor, plugin);
  }

  if (!disableEmbedInsert) {
    editor = withImageEmbed(editor);
  }

  if (!disableCaption) {
    editor = getWithSelectionCaption(ELEMENT_IMAGE)(editor, plugin);
  }

  return editor;
};

const ELEMENT_IMAGE = 'img';
/**
 * Enables support for images.
 */

const createImagePlugin = plateCommon.createPluginFactory({
  key: ELEMENT_IMAGE,
  isElement: true,
  isVoid: true,
  withOverrides: withImage,
  handlers: {
    onKeyDown: getOnKeyDownCaption(ELEMENT_IMAGE)
  },
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      rules: [{
        validNodeName: 'IMG'
      }],
      getNode: el => ({
        type,
        url: el.getAttribute('src')
      })
    }
  })
});

const useImage = props => {
  const {
    url
  } = plateCommon.useElement();
  const captionString = useCaptionString();
  return {
    src: url,
    alt: captionString,
    draggable: true,
    ...props
  };
};
const Image = plateCommon.createComponentAs(props => {
  const htmlProps = useImage(props);
  return plateCommon.createElementAs('img', htmlProps);
});

const twitterRegex = /^https?:\/\/twitter\.com\/(?:#!\/)?(\w+)\/status(es)?\/(?<id>\d+)/;
const parseTwitterUrl = url => {
  if (url.match(twitterRegex)) {
    var _twitterRegex$exec, _twitterRegex$exec$gr;

    return {
      provider: 'twitter',
      id: (_twitterRegex$exec = twitterRegex.exec(url)) === null || _twitterRegex$exec === void 0 ? void 0 : (_twitterRegex$exec$gr = _twitterRegex$exec.groups) === null || _twitterRegex$exec$gr === void 0 ? void 0 : _twitterRegex$exec$gr.id,
      url
    };
  }
};

const useMediaEmbedTweet = ({
  id,
  ...props
}) => {
  return {
    tweetId: id,
    ...props
  };
};
const MediaEmbedTweet = props => {
  const htmlProps = useMediaEmbedTweet(props);
  return /*#__PURE__*/React__default["default"].createElement(Tweet, htmlProps);
};

const WIDGET_SCRIPT_URL = 'https://platform.twitter.com/widgets.js';
const Tweet = ({
  tweetId,
  onError,
  onLoad,
  loadingComponent,
  twitterOptions = {}
}) => {
  const [isLoading, setIsLoading] = React.useState(true);
  const containerRef = React.useRef(null);
  const previousTweetIDRef = React.useRef('');
  const {
    cards,
    theme
  } = twitterOptions;
  const createTweet = React.useCallback(async () => {
    try {
      await window.twttr.widgets.createTweet(tweetId, containerRef.current, {
        cards,
        theme
      });
      setIsLoading(false);

      if (onLoad) {
        onLoad();
      }
    } catch (error) {
      if (onError) {
        onError(String(error));
      }
    }
  }, [onError, onLoad, tweetId, cards, theme]);
  React.useEffect(() => {
    if (tweetId !== previousTweetIDRef.current) {
      let isComponentMounted = true;

      const script = require('scriptjs');

      script(WIDGET_SCRIPT_URL, 'twitter-embed', () => {
        if (!window.twttr) {
          return console.error('Failure to load window.twttr.');
        }

        if (isComponentMounted) createTweet();
      });

      if (previousTweetIDRef) {
        previousTweetIDRef.current = tweetId;
      }

      return () => {
        isComponentMounted = false;
      };
    }
  }, [createTweet, onError, onLoad, tweetId]);
  return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, isLoading ? loadingComponent : null, /*#__PURE__*/React__default["default"].createElement("div", {
    key: tweetId,
    ref: containerRef
  }));
};

const YOUTUBE_PREFIX = 'https://www.youtube.com/embed/';
const VIMEO_PREFIX = 'https://player.vimeo.com/video/';
const DAILYMOTION_PREFIX = 'https://www.dailymotion.com/embed/video/';
const YOUKU_PREFIX = 'https://player.youku.com/embed/';
const COUB_PREFIX = 'https://coub.com/embed/';
const parseVideoUrl = url => {
  if (!plateCommon.isUrl(url)) return;
  const videoData = videoParser__default["default"].parse(url);

  if (videoData !== null && videoData !== void 0 && videoData.provider && videoData.id) {
    const {
      id,
      provider
    } = videoData;
    const providerUrls = {
      youtube: `${YOUTUBE_PREFIX}${id}`,
      vimeo: `${VIMEO_PREFIX}${id}`,
      dailymotion: `${DAILYMOTION_PREFIX}${id}`,
      youku: `${YOUKU_PREFIX}${id}`,
      coub: `${COUB_PREFIX}${id}`
    };
    return {
      id,
      provider,
      url: providerUrls[provider]
    };
  }
};

const useMediaEmbedVideo = ({ ...props
}) => {
  const {
    url
  } = useMediaStore().get.urlData();
  return {
    title: 'embed',
    frameBorder: '0',
    allowFullScreen: true,
    src: url,
    ...props
  };
};
const MediaEmbedVideo = props => {
  const htmlProps = useMediaEmbedVideo(props);
  return plateCommon.createElementAs('iframe', htmlProps);
};

const parseIframeUrl = url => {
  // if not starting with http, assume pasting of full iframe embed code
  if (url.substring(0, 4) !== 'http') {
    var _url$match, _src$match;

    const regexMatchSrc = /src=".*?"/;
    const regexGroupQuotes = /"([^"]*)"/;
    const src = (_url$match = url.match(regexMatchSrc)) === null || _url$match === void 0 ? void 0 : _url$match[0];
    const returnString = src === null || src === void 0 ? void 0 : (_src$match = src.match(regexGroupQuotes)) === null || _src$match === void 0 ? void 0 : _src$match[1];

    if (returnString) {
      url = returnString;
    }
  }

  return url;
};

const ELEMENT_MEDIA_EMBED = 'media_embed';
/**
 * Enables support for embeddable media such as YouTube
 * or Vimeo videos, Instagram posts and tweets or Google Maps.
 */

const createMediaEmbedPlugin = plateCommon.createPluginFactory({
  key: ELEMENT_MEDIA_EMBED,
  isElement: true,
  isVoid: true,
  handlers: {
    onKeyDown: getOnKeyDownCaption(ELEMENT_MEDIA_EMBED)
  },
  withOverrides: (editor, plugin) => {
    const {
      options: {
        disableCaption
      }
    } = plugin;

    if (!disableCaption) {
      editor = getWithSelectionCaption(ELEMENT_MEDIA_EMBED)(editor, plugin);
    }

    return editor;
  },
  options: {
    transformUrl: parseIframeUrl,
    rules: [{
      parser: parseTwitterUrl,
      component: MediaEmbedTweet
    }, {
      parser: parseVideoUrl,
      component: MediaEmbedVideo
    }]
  },
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      rules: [{
        validNodeName: 'IFRAME'
      }],
      getNode: el => {
        const url = el.getAttribute('src');

        if (url) {
          return {
            type,
            url
          };
        }
      }
    }
  })
});

const {
  mediaStore,
  useMediaStore
} = plateCommon.createAtomStore({
  urlData: {}
}, {
  name: 'media',
  scope: plateCommon.SCOPE_ELEMENT
});

const MediaEmbed = props => {
  const {
    component: Component,
    ...embedData
  } = useMediaStore().get.urlData();
  if (!Component) return null;
  return /*#__PURE__*/React__default["default"].createElement(Component, _extends({}, embedData, props));
};

const insertMediaEmbed = (editor, {
  url = '',
  key = ELEMENT_MEDIA_EMBED
}) => {
  if (!editor.selection) return;
  const selectionParentEntry = plateCommon.getParentNode(editor, editor.selection);
  if (!selectionParentEntry) return;
  const [, path] = selectionParentEntry;
  plateCommon.insertNodes(editor, {
    type: key,
    url,
    children: [{
      text: ''
    }]
  }, {
    at: path
  });
};

const useResizable = ({
  align = 'center',
  readOnly,
  minWidth = 92,
  maxWidth = '100%',
  renderHandleLeft,
  renderHandleRight,
  ...props
}) => {
  var _element$width;

  const element = plateCommon.useElement();
  const editor = plateCommon.useEditorRef();

  const _readOnly = slateReact.useReadOnly();

  readOnly = plateCommon.isDefined(readOnly) ? readOnly : _readOnly;
  const wrapperRef = React.useRef(null);
  const nodeWidth = (_element$width = element === null || element === void 0 ? void 0 : element.width) !== null && _element$width !== void 0 ? _element$width : '100%';
  const [width, setWidth] = useResizableStore().use.width();
  const setNodeWidth = React.useCallback(w => {
    const path = plateCommon.findNodePath(editor, element);
    if (!path) return;

    if (w === nodeWidth) {
      // Focus the node if not resized
      plateCommon.select(editor, path);
    } else {
      plateCommon.setNodes(editor, {
        width: w
      }, {
        at: path
      });
    }
  }, [editor, element, nodeWidth]);
  React.useEffect(() => {
    setWidth(nodeWidth);
  }, [nodeWidth, setWidth]);
  const handleResize = React.useCallback(({
    initialSize,
    delta,
    finished,
    direction
  }) => {
    const wrapperStaticWidth = wrapperRef.current.offsetWidth;
    const deltaFactor = (align === 'center' ? 2 : 1) * (direction === 'left' ? -1 : 1);
    const newWidth = resizable.resizeLengthClamp(initialSize + delta * deltaFactor, wrapperStaticWidth, {
      min: minWidth,
      max: maxWidth
    });

    if (finished) {
      setNodeWidth(newWidth);
    } else {
      setWidth(newWidth);
    }
  }, [align, maxWidth, minWidth, setNodeWidth, setWidth]); // Remove style except for cursor

  const handlePropsLeft = { ...resizable.useResizeHandleProps({
      direction: 'left',
      onResize: handleResize
    }),
    style: {
      cursor: 'ew-resize'
    }
  };
  const handlePropsRight = { ...resizable.useResizeHandleProps({
      direction: 'right',
      onResize: handleResize
    }),
    style: {
      cursor: 'ew-resize'
    }
  };
  const handleLeft = !readOnly && align !== 'left' && (renderHandleLeft === null || renderHandleLeft === void 0 ? void 0 : renderHandleLeft(handlePropsLeft));
  const handleRight = !readOnly && align !== 'right' && (renderHandleRight === null || renderHandleRight === void 0 ? void 0 : renderHandleRight(handlePropsRight));
  return {
    wrapperProps: {
      ref: wrapperRef,
      style: {
        position: 'relative'
      }
    },
    resizableProps: {
      style: {
        width,
        minWidth,
        maxWidth,
        position: 'relative'
      }
    },
    handleLeft,
    handleRight,
    restProps: props
  };
};
const Resizable = plateCommon.createComponentAs(({
  children,
  ...props
}) => {
  const {
    wrapperProps,
    resizableProps,
    handleLeft,
    handleRight,
    restProps
  } = useResizable(props);
  return /*#__PURE__*/React__default["default"].createElement("div", wrapperProps, /*#__PURE__*/React__default["default"].createElement("div", _extends({}, resizableProps, restProps), handleLeft, children, handleRight));
});

const parseMediaUrl = (editor, {
  pluginKey,
  url
}) => {
  if (!url) return;
  const {
    rules
  } = plateCommon.getPluginOptions(editor, pluginKey);
  if (!rules) return;

  for (const {
    parser,
    component
  } of rules) {
    const parsed = parser(url);

    if (parsed) {
      return { ...parsed,
        component
      };
    }
  }
};

const useMedia = ({
  pluginKey = ELEMENT_MEDIA_EMBED,
  ...props
}) => {
  const editor = plateCommon.useEditorRef();
  const element = plateCommon.useElement();
  const setUrlData = useMediaStore().set.urlData();
  const {
    url: elementUrl
  } = element;
  React.useEffect(() => {
    const parsed = parseMediaUrl(editor, {
      pluginKey,
      url: elementUrl
    });

    if (parsed) {
      setUrlData(parsed);
    }
  }, [editor, elementUrl, pluginKey, setUrlData]);
  return plateCommon.useElementProps(props);
};
const MediaRoot = plateCommon.createComponentAs(props => {
  const htmlProps = useMedia(props);
  return plateCommon.createElementAs('div', htmlProps);
});
const Media = {
  Root: MediaRoot,
  Resizable
};

const ELEMENT_MEDIA = 'media';

const floatingMediaStore = plateCommon.createStore('floatingMedia')({
  url: '',
  isEditing: false
}).extendActions(set => ({
  reset: () => {
    set.url('');
    set.isEditing(false);
  }
}));
const floatingMediaActions = floatingMediaStore.set;
const floatingMediaSelectors = floatingMediaStore.get;
const useFloatingMediaSelectors = () => floatingMediaStore.use;

const useFloatingMediaEditButton = props => {
  const element = plateCommon.useElement();
  return {
    onClick: React.useCallback(() => {
      floatingMediaActions.url(element.url);
      floatingMediaActions.isEditing(true);
    }, [element.url]),
    ...props
  };
};
const FloatingMediaEditButton = plateCommon.createComponentAs(props => {
  const htmlProps = useFloatingMediaEditButton(props);
  return plateCommon.createElementAs('button', htmlProps);
});

const submitFloatingMedia = (editor, {
  element,
  pluginKey = ELEMENT_MEDIA
}) => {
  let url = floatingMediaSelectors.url();

  if (url === element.url) {
    floatingMediaActions.reset();
    return true;
  }

  const {
    isUrl: _isUrl = plateCommon.isUrl,
    transformUrl
  } = plateCommon.getPluginOptions(editor, pluginKey);

  const isValid = _isUrl(url);

  if (!isValid) return;

  if (transformUrl) {
    url = transformUrl(url);
  }

  plateCommon.setNodes(editor, {
    url
  });
  floatingMediaActions.reset();
  plateCommon.focusEditor(editor, editor.selection);
  return true;
};

const useFloatingMediaUrlInput = ({
  pluginKey,
  ...props
}) => {
  const editor = plateCommon.useEditorRef();
  const element = plateCommon.useElement();
  React.useEffect(() => {
    return () => {
      floatingMediaActions.isEditing(false);
    };
  }, []);
  plateCommon.useHotkeys('enter', e => {
    if (submitFloatingMedia(editor, {
      element,
      pluginKey
    })) {
      e.preventDefault();
    }
  }, {
    enableOnFormTags: ['INPUT']
  }, []);
  plateCommon.useHotkeys('escape', () => {
    if (floatingMediaSelectors.isEditing()) {
      floatingMediaActions.reset();
      plateCommon.focusEditor(editor, editor.selection);
    }
  }, {
    enableOnFormTags: ['INPUT'],
    enableOnContentEditable: true
  }, []);
  const onChange = React.useCallback(e => {
    floatingMediaActions.url(e.target.value);
  }, []);
  return plateCommon.mergeProps({
    onChange,
    autoFocus: true,
    defaultValue: floatingMediaSelectors.url()
  }, props);
};
const FloatingMediaUrlInput = plateCommon.createComponentAs(props => {
  const htmlProps = useFloatingMediaUrlInput(props);
  return plateCommon.createElementAs('input', htmlProps);
});

const FloatingMedia = {
  EditButton: FloatingMediaEditButton,
  UrlInput: FloatingMediaUrlInput
};

exports.Caption = Caption;
exports.CaptionRoot = CaptionRoot;
exports.CaptionTextarea = CaptionTextarea;
exports.ELEMENT_IMAGE = ELEMENT_IMAGE;
exports.ELEMENT_MEDIA = ELEMENT_MEDIA;
exports.ELEMENT_MEDIA_EMBED = ELEMENT_MEDIA_EMBED;
exports.FloatingMedia = FloatingMedia;
exports.FloatingMediaEditButton = FloatingMediaEditButton;
exports.FloatingMediaUrlInput = FloatingMediaUrlInput;
exports.Image = Image;
exports.Media = Media;
exports.MediaEmbed = MediaEmbed;
exports.MediaEmbedTweet = MediaEmbedTweet;
exports.MediaEmbedVideo = MediaEmbedVideo;
exports.MediaRoot = MediaRoot;
exports.Resizable = Resizable;
exports.TextareaAutosize = TextareaAutosize;
exports.Tweet = Tweet;
exports.captionGlobalStore = captionGlobalStore;
exports.createImagePlugin = createImagePlugin;
exports.createMediaEmbedPlugin = createMediaEmbedPlugin;
exports.floatingMediaActions = floatingMediaActions;
exports.floatingMediaSelectors = floatingMediaSelectors;
exports.floatingMediaStore = floatingMediaStore;
exports.getOnKeyDownCaption = getOnKeyDownCaption;
exports.getWithSelectionCaption = getWithSelectionCaption;
exports.insertImage = insertImage;
exports.insertMediaEmbed = insertMediaEmbed;
exports.isImageUrl = isImageUrl;
exports.mediaStore = mediaStore;
exports.parseIframeUrl = parseIframeUrl;
exports.parseMediaUrl = parseMediaUrl;
exports.parseTwitterUrl = parseTwitterUrl;
exports.parseVideoUrl = parseVideoUrl;
exports.resizableStore = resizableStore;
exports.submitFloatingMedia = submitFloatingMedia;
exports.useCaption = useCaption;
exports.useCaptionState = useCaptionState;
exports.useCaptionString = useCaptionString;
exports.useCaptionTextarea = useCaptionTextarea;
exports.useCaptionTextareaFocus = useCaptionTextareaFocus;
exports.useFloatingMediaEditButton = useFloatingMediaEditButton;
exports.useFloatingMediaSelectors = useFloatingMediaSelectors;
exports.useFloatingMediaUrlInput = useFloatingMediaUrlInput;
exports.useImage = useImage;
exports.useMedia = useMedia;
exports.useMediaEmbedTweet = useMediaEmbedTweet;
exports.useMediaEmbedVideo = useMediaEmbedVideo;
exports.useMediaStore = useMediaStore;
exports.useResizable = useResizable;
exports.useResizableStore = useResizableStore;
exports.withImage = withImage;
exports.withImageEmbed = withImageEmbed;
exports.withImageUpload = withImageUpload;
//# sourceMappingURL=index.js.map
