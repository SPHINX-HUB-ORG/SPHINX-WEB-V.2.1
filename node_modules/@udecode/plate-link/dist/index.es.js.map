{"version":3,"file":"index.es.js","sources":["../src/utils/createLinkNode.ts","../src/utils/getLinkAttributes.ts","../src/components/LaunchIcon.tsx","../src/components/Link.tsx","../src/components/LinkIcon.tsx","../src/components/LinkOffIcon.tsx","../src/components/ShortTextIcon.tsx","../src/components/FloatingLink/floatingLinkStore.ts","../src/utils/triggerFloatingLinkEdit.ts","../src/components/FloatingLink/FloatingLinkEditButton.tsx","../src/components/FloatingLink/FloatingLinkNewTabInput.tsx","../src/components/FloatingLink/FloatingLinkTextInput.tsx","../src/components/FloatingLink/FloatingLinkUrlInput.tsx","../src/components/FloatingLink/OpenLinkButton.tsx","../src/transforms/insertLink.ts","../src/transforms/submitFloatingLink.ts","../src/transforms/unwrapLink.ts","../src/transforms/upsertLinkText.ts","../src/transforms/wrapLink.ts","../src/transforms/upsertLink.ts","../src/components/FloatingLink/UnlinkButton.tsx","../../../../node_modules/rollup-plugin-node-globals/src/global.js","../../../../node_modules/process-es6/browser.js","../../../../node_modules/@floating-ui/react/node_modules/@floating-ui/core/dist/floating-ui.core.esm.js","../../../../node_modules/@floating-ui/react/node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js","../../../../node_modules/@floating-ui/react/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js","../../../../node_modules/@floating-ui/react/dist/floating-ui.react.esm.js","../../../floating/dist/index.es.js","../src/components/FloatingLink/useFloatingLinkEnter.ts","../src/components/FloatingLink/useFloatingLinkEscape.ts","../src/components/FloatingLink/useVirtualFloatingLink.ts","../src/components/FloatingLink/useFloatingLinkEdit.ts","../src/utils/triggerFloatingLinkInsert.ts","../src/components/FloatingLink/useFloatingLinkInsert.ts","../src/components/FloatingLink/FloatingLink.tsx","../src/utils/triggerFloatingLink.ts","../src/utils/validateUrl.ts","../src/withLink.ts","../src/createLinkPlugin.ts"],"sourcesContent":["import {\n  getPluginType,\n  PlateEditor,\n  TText,\n  Value,\n} from '@udecode/plate-common';\nimport { ELEMENT_LINK } from '../createLinkPlugin';\nimport { TLinkElement } from '../types';\n\nexport interface CreateLinkNodeOptions {\n  url: string;\n  text?: string;\n  target?: string;\n  children?: TText[];\n}\n\nexport const createLinkNode = <V extends Value>(\n  editor: PlateEditor<V>,\n  { url, text = '', target, children }: CreateLinkNodeOptions\n): TLinkElement => {\n  const type = getPluginType(editor, ELEMENT_LINK);\n\n  return {\n    type,\n    url,\n    target,\n    children: children ?? [{ text }],\n  };\n};\n","import {\n  getPluginOptions,\n  PlateEditor,\n  sanitizeUrl,\n  Value,\n} from '@udecode/plate-common';\nimport { ELEMENT_LINK, LinkPlugin } from '../createLinkPlugin';\nimport { TLinkElement } from '../types';\n\nexport const getLinkAttributes = <V extends Value>(\n  editor: PlateEditor<V>,\n  link: TLinkElement\n) => {\n  const {\n    allowedSchemes,\n    defaultLinkAttributes,\n    dangerouslySkipSanitization,\n  } = getPluginOptions<LinkPlugin, V>(editor, ELEMENT_LINK);\n\n  const attributes = { ...defaultLinkAttributes };\n\n  const href = dangerouslySkipSanitization\n    ? link.url\n    : sanitizeUrl(link.url, { allowedSchemes }) || undefined;\n\n  // Avoid passing `undefined` for href or target\n  if (href !== undefined) {\n    attributes.href = href;\n  }\n\n  if ('target' in link) {\n    attributes.target = link.target;\n  }\n\n  return attributes;\n};\n","import React, { SVGProps } from 'react';\n\nexport const LaunchIcon = (props: SVGProps<SVGSVGElement>) => (\n  <svg\n    viewBox=\"0 0 24 24\"\n    focusable=\"false\"\n    role=\"img\"\n    fill=\"currentColor\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    {...props}\n  >\n    <path fill=\"none\" d=\"M0 0h24v24H0z\" />\n    <path d=\"M19 19H5V5h7V3H5a2 2 0 00-2 2v14a2 2 0 002 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z\" />\n  </svg>\n);\n","import {\n  createComponentAs,\n  createElementAs,\n  HTMLPropsAs,\n  PlateRenderElementProps,\n  useElementProps,\n  Value,\n} from '@udecode/plate-common';\nimport { TLinkElement } from '../types';\nimport { getLinkAttributes } from '../utils/index';\n\nexport type LinkRootProps = PlateRenderElementProps<Value, TLinkElement> &\n  HTMLPropsAs<'a'>;\n\nexport const useLink = (props: LinkRootProps): HTMLPropsAs<'a'> => {\n  const { editor } = props;\n\n  const _props = useElementProps<TLinkElement, 'a'>({\n    ...props,\n    elementToAttributes: (element) => getLinkAttributes(editor, element),\n  });\n\n  return {\n    ..._props,\n    // quick fix: hovering <a> with href loses the editor focus\n    onMouseOver: (e) => {\n      e.stopPropagation();\n    },\n  };\n};\n\nexport const LinkRoot = createComponentAs<LinkRootProps>((props) => {\n  const htmlProps = useLink(props);\n\n  return createElementAs('a', htmlProps);\n});\n\nexport const Link = {\n  Root: LinkRoot,\n};\n","import React, { SVGProps } from 'react';\n\nexport const LinkIcon = (props: SVGProps<SVGSVGElement>) => (\n  <svg\n    viewBox=\"0 0 24 24\"\n    focusable=\"false\"\n    role=\"img\"\n    fill=\"currentColor\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    {...props}\n  >\n    <path fill=\"none\" d=\"M0 0h24v24H0z\" />\n    <path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z\" />\n  </svg>\n);\n","import React, { SVGProps } from 'react';\n\nexport const LinkOffIcon = (props: SVGProps<SVGSVGElement>) => (\n  <svg\n    viewBox=\"0 0 24 24\"\n    focusable=\"false\"\n    role=\"img\"\n    fill=\"currentColor\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    {...props}\n  >\n    <path fill=\"none\" d=\"M0 0h24v24H0V0z\" />\n    <path d=\"M17 7h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1 0 1.43-.98 2.63-2.31 2.98l1.46 1.46C20.88 15.61 22 13.95 22 12c0-2.76-2.24-5-5-5zm-1 4h-2.19l2 2H16zM2 4.27l3.11 3.11A4.991 4.991 0 002 12c0 2.76 2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1 0-1.59 1.21-2.9 2.76-3.07L8.73 11H8v2h2.73L13 15.27V17h1.73l4.01 4L20 19.74 3.27 3 2 4.27z\" />\n    <path fill=\"none\" d=\"M0 24V0\" />\n  </svg>\n);\n","import React, { SVGProps } from 'react';\n\nexport const ShortTextIcon = (props: SVGProps<SVGSVGElement>) => (\n  <svg\n    viewBox=\"0 0 24 24\"\n    focusable=\"false\"\n    role=\"img\"\n    fill=\"currentColor\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    {...props}\n  >\n    <rect width={24} height={24} fill=\"none\" />\n    <path d=\"M4 9h16v2H4V9zm0 4h10v2H4v-2z\" />\n  </svg>\n);\n","import { createStore } from '@udecode/plate-common';\n\nexport type FloatingLinkMode = '' | 'insert' | 'edit';\n\nexport const floatingLinkStore = createStore('floatingLink')({\n  openEditorId: null as null | string,\n  mouseDown: false,\n  updated: false,\n  url: '',\n  text: '',\n  newTab: false,\n  mode: '' as FloatingLinkMode,\n  isEditing: false,\n})\n  .extendActions((set) => ({\n    reset: () => {\n      set.url('');\n      set.text('');\n      set.newTab(false);\n      set.mode('');\n      set.isEditing(false);\n    },\n  }))\n  .extendActions((set) => ({\n    show: (mode: FloatingLinkMode, editorId: string) => {\n      set.mode(mode);\n      set.isEditing(false);\n      set.openEditorId(editorId);\n    },\n    hide: () => {\n      set.openEditorId(null);\n      set.reset();\n    },\n  }))\n  .extendSelectors((state) => ({\n    isOpen: (editorId: string) => state.openEditorId === editorId,\n  }));\n\nexport const floatingLinkActions = floatingLinkStore.set;\nexport const floatingLinkSelectors = floatingLinkStore.get;\nexport const useFloatingLinkSelectors = () => floatingLinkStore.use;\n","import {\n  findNode,\n  getEditorString,\n  getPluginType,\n  PlateEditor,\n  Value,\n} from '@udecode/plate-common';\nimport { floatingLinkActions } from '../components/FloatingLink/floatingLinkStore';\nimport { ELEMENT_LINK } from '../createLinkPlugin';\nimport { TLinkElement } from '../types';\n\nexport const triggerFloatingLinkEdit = <V extends Value>(\n  editor: PlateEditor<V>\n) => {\n  const entry = findNode<TLinkElement>(editor, {\n    match: { type: getPluginType(editor, ELEMENT_LINK) },\n  });\n  if (!entry) return;\n\n  const [link, path] = entry;\n\n  let text = getEditorString(editor, path);\n\n  floatingLinkActions.url(link.url);\n\n  floatingLinkActions.newTab(link.target === '_blank');\n\n  if (text === link.url) {\n    text = '';\n  }\n\n  floatingLinkActions.text(text);\n\n  floatingLinkActions.isEditing(true);\n\n  return true;\n};\n","import { useCallback } from 'react';\nimport {\n  AsProps,\n  createComponentAs,\n  createElementAs,\n  HTMLPropsAs,\n  useEditorRef,\n} from '@udecode/plate-common';\nimport { triggerFloatingLinkEdit } from '../../utils/triggerFloatingLinkEdit';\n\nexport const useFloatingLinkEditButton = (\n  props: HTMLPropsAs<'button'>\n): HTMLPropsAs<'button'> => {\n  const editor = useEditorRef();\n\n  return {\n    onClick: useCallback(() => {\n      triggerFloatingLinkEdit(editor);\n    }, [editor]),\n    ...props,\n  };\n};\n\nexport const FloatingLinkEditButton = createComponentAs<AsProps<'button'>>(\n  (props) => {\n    const htmlProps = useFloatingLinkEditButton(props);\n\n    return createElementAs('button', htmlProps);\n  }\n);\n","import {\n  ChangeEventHandler,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from 'react';\nimport {\n  AsProps,\n  createComponentAs,\n  createElementAs,\n  HTMLPropsAs,\n  mergeProps,\n  useComposedRef,\n} from '@udecode/plate-common';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n  useFloatingLinkSelectors,\n} from './floatingLinkStore';\n\nexport const useFloatingLinkNewTabInput = (\n  props: HTMLPropsAs<'input'>\n): HTMLPropsAs<'input'> => {\n  const updated = useFloatingLinkSelectors().updated();\n  const ref = useRef<HTMLInputElement>(null);\n  const [checked, setChecked] = useState<boolean>(\n    floatingLinkSelectors.newTab()\n  );\n\n  useEffect(() => {\n    if (ref.current && updated) {\n      setTimeout(() => {\n        ref.current?.focus();\n      }, 0);\n    }\n  }, [updated]);\n\n  const onChange: ChangeEventHandler<HTMLInputElement> = useCallback((e) => {\n    setChecked(e.target.checked);\n    floatingLinkActions.newTab(e.target.checked);\n  }, []);\n\n  return mergeProps(\n    {\n      onChange,\n      checked,\n      type: 'checkbox',\n    },\n    { ...props, ref: useComposedRef<HTMLInputElement>(props.ref, ref) }\n  );\n};\n\nexport const FloatingLinkNewTabInput = createComponentAs<AsProps<'input'>>(\n  (props) => {\n    const htmlProps = useFloatingLinkNewTabInput(props);\n\n    return createElementAs('input', htmlProps);\n  }\n);\n","import { ChangeEventHandler, useCallback } from 'react';\nimport {\n  AsProps,\n  createComponentAs,\n  createElementAs,\n  HTMLPropsAs,\n  mergeProps,\n} from '@udecode/plate-common';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n} from './floatingLinkStore';\n\nexport const useFloatingLinkTextInput = (\n  props: HTMLPropsAs<'input'>\n): HTMLPropsAs<'input'> => {\n  const onChange: ChangeEventHandler<HTMLInputElement> = useCallback((e) => {\n    floatingLinkActions.text(e.target.value);\n  }, []);\n\n  return mergeProps(\n    {\n      onChange,\n      defaultValue: floatingLinkSelectors.text(),\n    },\n    props\n  );\n};\n\nexport const FloatingLinkTextInput = createComponentAs<AsProps<'input'>>(\n  (props) => {\n    const htmlProps = useFloatingLinkTextInput(props);\n\n    return createElementAs('input', htmlProps);\n  }\n);\n","import { ChangeEventHandler, useCallback, useEffect, useRef } from 'react';\nimport {\n  AsProps,\n  createComponentAs,\n  createElementAs,\n  HTMLPropsAs,\n  mergeProps,\n  useComposedRef,\n} from '@udecode/plate-common';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n  useFloatingLinkSelectors,\n} from './floatingLinkStore';\n\nexport const useFloatingLinkUrlInput = (\n  props: HTMLPropsAs<'input'>\n): HTMLPropsAs<'input'> => {\n  const updated = useFloatingLinkSelectors().updated();\n  const ref = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (ref.current && updated) {\n      setTimeout(() => {\n        ref.current?.focus();\n      }, 0);\n    }\n  }, [updated]);\n\n  const onChange: ChangeEventHandler<HTMLInputElement> = useCallback((e) => {\n    floatingLinkActions.url(e.target.value);\n  }, []);\n\n  return mergeProps(\n    {\n      onChange,\n      defaultValue: floatingLinkSelectors.url(),\n    },\n    { ...props, ref: useComposedRef<HTMLInputElement>(props.ref, ref) }\n  );\n};\n\nexport const FloatingLinkUrlInput = createComponentAs<AsProps<'input'>>(\n  (props) => {\n    const htmlProps = useFloatingLinkUrlInput(props);\n\n    return createElementAs('input', htmlProps);\n  }\n);\n","import { useMemo } from 'react';\nimport {\n  AsProps,\n  createComponentAs,\n  createElementAs,\n  findNode,\n  getPluginType,\n  HTMLPropsAs,\n  useEditorRef,\n  usePlateSelection,\n} from '@udecode/plate-common';\nimport { ELEMENT_LINK } from '../../createLinkPlugin';\nimport { TLinkElement } from '../../types';\nimport { getLinkAttributes } from '../../utils/index';\n\nexport const useOpenLinkButton = (\n  props: HTMLPropsAs<'a'>\n): HTMLPropsAs<'a'> => {\n  const editor = useEditorRef();\n  const selection = usePlateSelection();\n\n  const entry = useMemo(\n    () =>\n      findNode<TLinkElement>(editor, {\n        match: { type: getPluginType(editor, ELEMENT_LINK) },\n      }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [editor, selection]\n  );\n\n  if (!entry) {\n    return {};\n  }\n\n  const [element] = entry;\n  const linkAttributes = getLinkAttributes(editor, element);\n\n  return {\n    ...linkAttributes,\n    target: '_blank',\n    'aria-label': 'Open link in a new tab',\n    onMouseOver: (e) => {\n      e.stopPropagation();\n    },\n    ...props,\n  };\n};\n\nexport const OpenLinkButton = createComponentAs<AsProps<'a'>>((props) => {\n  const htmlProps = useOpenLinkButton(props);\n\n  return createElementAs('a', htmlProps);\n});\n","import {\n  insertNodes,\n  InsertNodesOptions,\n  PlateEditor,\n  TText,\n  Value,\n} from '@udecode/plate-common';\nimport { TLinkElement } from '../types';\nimport { createLinkNode, CreateLinkNodeOptions } from '../utils/index';\n\n/**\n * Insert a link node.\n */\nexport const insertLink = <V extends Value>(\n  editor: PlateEditor<V>,\n  createLinkNodeOptions: CreateLinkNodeOptions,\n  options?: InsertNodesOptions<V>\n) => {\n  insertNodes<TLinkElement | TText>(\n    editor,\n    [createLinkNode(editor, createLinkNodeOptions)],\n    options as any\n  );\n};\n","import {\n  focusEditor,\n  getPluginOptions,\n  PlateEditor,\n  Value,\n} from '@udecode/plate-common';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n} from '../components/FloatingLink/floatingLinkStore';\nimport { ELEMENT_LINK, LinkPlugin } from '../createLinkPlugin';\nimport { validateUrl } from '../utils/index';\nimport { upsertLink } from './index';\n\n/**\n * Insert link if url is valid.\n * Text is url if empty.\n * Close floating link.\n * Focus editor.\n */\nexport const submitFloatingLink = <V extends Value>(editor: PlateEditor<V>) => {\n  if (!editor.selection) return;\n\n  const { forceSubmit } = getPluginOptions<LinkPlugin, V>(editor, ELEMENT_LINK);\n\n  const url = floatingLinkSelectors.url();\n  if (!forceSubmit && !validateUrl(editor, url)) return;\n\n  const text = floatingLinkSelectors.text();\n  const target = floatingLinkSelectors.newTab() ? '_blank' : undefined;\n\n  floatingLinkActions.hide();\n\n  upsertLink(editor, {\n    url,\n    text,\n    target,\n    skipValidation: true,\n  });\n\n  setTimeout(() => {\n    focusEditor(editor, editor.selection!);\n  }, 0);\n\n  return true;\n};\n","import {\n  getAboveNode,\n  getPluginType,\n  isElement,\n  PlateEditor,\n  splitNodes,\n  unwrapNodes,\n  UnwrapNodesOptions,\n  Value,\n  withoutNormalizing,\n} from '@udecode/plate-common';\nimport { ELEMENT_LINK } from '../createLinkPlugin';\n\n/**\n * Unwrap link node.\n */\nexport const unwrapLink = <V extends Value>(\n  editor: PlateEditor<V>,\n  options?: UnwrapNodesOptions & {\n    split?: boolean;\n  }\n) => {\n  return withoutNormalizing(editor, () => {\n    if (options?.split) {\n      const linkAboveAnchor = getAboveNode(editor, {\n        at: editor.selection?.anchor,\n        match: { type: getPluginType(editor, ELEMENT_LINK) },\n      });\n\n      // anchor in link\n      if (linkAboveAnchor) {\n        splitNodes(editor, {\n          at: editor.selection?.anchor,\n          match: (n) =>\n            isElement(n) && n.type === getPluginType(editor, ELEMENT_LINK),\n        });\n        unwrapLink(editor, {\n          at: editor.selection?.anchor,\n        });\n        return true;\n      }\n      const linkAboveFocus = getAboveNode(editor, {\n        at: editor.selection?.focus,\n        match: { type: getPluginType(editor, ELEMENT_LINK) },\n      });\n\n      // focus in link\n      if (linkAboveFocus) {\n        splitNodes(editor, {\n          at: editor.selection?.focus,\n          match: (n) =>\n            isElement(n) && n.type === getPluginType(editor, ELEMENT_LINK),\n        });\n        unwrapLink(editor, {\n          at: editor.selection?.focus,\n        });\n        return true;\n      }\n    }\n\n    unwrapNodes(editor, {\n      match: { type: getPluginType(editor, ELEMENT_LINK) },\n      ...options,\n    });\n  });\n};\n","import {\n  getAboveNode,\n  getEditorString,\n  getPluginType,\n  PlateEditor,\n  replaceNodeChildren,\n  TText,\n  Value,\n} from '@udecode/plate-common';\nimport { ELEMENT_LINK } from '../createLinkPlugin';\nimport { TLinkElement } from '../types';\nimport { UpsertLinkOptions } from './upsertLink';\n\n/**\n * If the text is different than the link above text, replace link children by a new text.\n * The new text has the same marks than the first text replaced.\n */\nexport const upsertLinkText = <V extends Value>(\n  editor: PlateEditor<V>,\n  { text }: UpsertLinkOptions<V>\n) => {\n  const newLink = getAboveNode<TLinkElement>(editor, {\n    match: { type: getPluginType(editor, ELEMENT_LINK) },\n  });\n\n  if (newLink) {\n    const [newLinkNode, newLinkPath] = newLink;\n\n    if (text?.length && text !== getEditorString(editor, newLinkPath)) {\n      const firstText = newLinkNode.children[0];\n\n      // remove link children\n      replaceNodeChildren<TText>(editor, {\n        at: newLinkPath,\n        nodes: { ...firstText, text },\n        insertOptions: {\n          select: true,\n        },\n      });\n    }\n  }\n};\n","import {\n  getPluginType,\n  PlateEditor,\n  Value,\n  wrapNodes,\n  WrapNodesOptions,\n} from '@udecode/plate-common';\nimport { ELEMENT_LINK } from '../createLinkPlugin';\nimport { TLinkElement } from '../types';\n\nexport interface WrapLinkOptions<V extends Value = Value>\n  extends WrapNodesOptions<V> {\n  url: string;\n  target?: string;\n}\n\n/**\n * Wrap a link node with split.\n */\nexport const wrapLink = <V extends Value>(\n  editor: PlateEditor<V>,\n  { url, target, ...options }: WrapLinkOptions<V>\n) => {\n  wrapNodes<TLinkElement, Value>(\n    editor,\n    {\n      type: getPluginType(editor, ELEMENT_LINK),\n      url,\n      target,\n      children: [],\n    },\n    { split: true, ...options } as any\n  );\n};\n","import {\n  findNode,\n  getAboveNode,\n  getEditorString,\n  getNodeLeaf,\n  getNodeProps,\n  getPluginType,\n  InsertNodesOptions,\n  isDefined,\n  isExpanded,\n  PlateEditor,\n  removeNodes,\n  setNodes,\n  UnwrapNodesOptions,\n  Value,\n  WrapNodesOptions,\n} from '@udecode/plate-common';\nimport { ELEMENT_LINK } from '../createLinkPlugin';\nimport { TLinkElement } from '../types';\nimport { CreateLinkNodeOptions, validateUrl } from '../utils/index';\nimport { insertLink } from './insertLink';\nimport { unwrapLink } from './unwrapLink';\nimport { upsertLinkText } from './upsertLinkText';\nimport { wrapLink } from './wrapLink';\n\nexport type UpsertLinkOptions<\n  V extends Value = Value\n> = CreateLinkNodeOptions & {\n  /**\n   * If true, insert text when selection is in url.\n   */\n  insertTextInLink?: boolean;\n  insertNodesOptions?: InsertNodesOptions<V>;\n  unwrapNodesOptions?: UnwrapNodesOptions<V>;\n  wrapNodesOptions?: WrapNodesOptions<V>;\n  skipValidation?: boolean;\n};\n\n/**\n * If selection in a link or is not url:\n * - insert text with url, exit\n * If selection is expanded or `update` in a link:\n * - remove link node, get link text\n * Then:\n * - insert link node\n */\nexport const upsertLink = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    url,\n    text,\n    target,\n    insertTextInLink,\n    insertNodesOptions,\n    skipValidation = false,\n  }: UpsertLinkOptions<V>\n) => {\n  const at = editor.selection;\n\n  if (!at) return;\n\n  const linkAbove = getAboveNode<TLinkElement>(editor, {\n    at,\n    match: { type: getPluginType(editor, ELEMENT_LINK) },\n  });\n\n  // anchor and focus in link -> insert text\n  if (insertTextInLink && linkAbove) {\n    // we don't want to insert marks in links\n    editor.insertText(url);\n    return true;\n  }\n\n  if (!skipValidation && !validateUrl(editor, url)) return;\n\n  if (isDefined(text) && !text.length) {\n    text = url;\n  }\n\n  // edit the link url and/or target\n  if (linkAbove) {\n    if (url !== linkAbove[0]?.url || target !== linkAbove[0]?.target) {\n      setNodes<TLinkElement>(\n        editor,\n        { url, target },\n        {\n          at: linkAbove[1],\n        }\n      );\n    }\n\n    upsertLinkText(editor, { url, text, target });\n\n    return true;\n  }\n\n  // selection contains at one edge edge or between the edges\n  const linkEntry = findNode<TLinkElement>(editor, {\n    at,\n    match: { type: getPluginType(editor, ELEMENT_LINK) },\n  });\n\n  const [linkNode, linkPath] = linkEntry ?? [];\n\n  let shouldReplaceText = false;\n\n  if (linkPath && text?.length) {\n    const linkText = getEditorString(editor, linkPath);\n\n    if (text !== linkText) {\n      shouldReplaceText = true;\n    }\n  }\n\n  if (isExpanded(at)) {\n    // anchor and focus in link\n    if (linkAbove) {\n      unwrapLink(editor, {\n        at: linkAbove[1],\n      });\n    } else {\n      unwrapLink(editor, {\n        split: true,\n      });\n    }\n\n    wrapLink(editor, {\n      url,\n      target,\n    });\n\n    upsertLinkText(editor, { url, target, text });\n\n    return true;\n  }\n\n  if (shouldReplaceText) {\n    removeNodes(editor, {\n      at: linkPath,\n    });\n  }\n\n  const props = getNodeProps(linkNode ?? ({} as any));\n\n  const path = editor.selection?.focus.path;\n  if (!path) return;\n\n  // link text should have the focused leaf marks\n  const leaf = getNodeLeaf(editor, path);\n\n  // if text is empty, text is url\n  if (!text?.length) {\n    text = url;\n  }\n\n  insertLink(\n    editor,\n    {\n      ...props,\n      url,\n      target,\n      children: [\n        {\n          ...leaf,\n          text,\n        },\n      ],\n    },\n    insertNodesOptions\n  );\n  return true;\n};\n","import { useCallback } from 'react';\nimport { Button } from '@udecode/plate-button';\nimport {\n  AsProps,\n  createComponentAs,\n  createElementAs,\n  focusEditor,\n  HTMLPropsAs,\n  useEditorRef,\n} from '@udecode/plate-common';\nimport { unwrapLink } from '../../transforms/index';\n\nexport const useUnlinkButton = (\n  props: HTMLPropsAs<'button'>\n): HTMLPropsAs<'button'> => {\n  const editor = useEditorRef();\n\n  return {\n    onClick: useCallback(() => {\n      unwrapLink(editor);\n      focusEditor(editor, editor.selection!);\n    }, [editor]),\n    ...props,\n  };\n};\n\nexport const UnlinkButton = createComponentAs<AsProps<'button'>>((props) => {\n  const htmlProps = useUnlinkButton(props);\n\n  return createElementAs(Button, htmlProps);\n});\n","export default (typeof global !== \"undefined\" ? global :\n            typeof self !== \"undefined\" ? self :\n            typeof window !== \"undefined\" ? window : {});\n","// shim for using process in browser\n// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\nvar cachedSetTimeout = defaultSetTimout;\nvar cachedClearTimeout = defaultClearTimeout;\nif (typeof global.setTimeout === 'function') {\n    cachedSetTimeout = setTimeout;\n}\nif (typeof global.clearTimeout === 'function') {\n    cachedClearTimeout = clearTimeout;\n}\n\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\nexport function nextTick(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n}\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nexport var title = 'browser';\nexport var platform = 'browser';\nexport var browser = true;\nexport var env = {};\nexport var argv = [];\nexport var version = ''; // empty string to avoid regexp issues\nexport var versions = {};\nexport var release = {};\nexport var config = {};\n\nfunction noop() {}\n\nexport var on = noop;\nexport var addListener = noop;\nexport var once = noop;\nexport var off = noop;\nexport var removeListener = noop;\nexport var removeAllListeners = noop;\nexport var emit = noop;\n\nexport function binding(name) {\n    throw new Error('process.binding is not supported');\n}\n\nexport function cwd () { return '/' }\nexport function chdir (dir) {\n    throw new Error('process.chdir is not supported');\n};\nexport function umask() { return 0; }\n\n// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\nvar performance = global.performance || {}\nvar performanceNow =\n  performance.now        ||\n  performance.mozNow     ||\n  performance.msNow      ||\n  performance.oNow       ||\n  performance.webkitNow  ||\n  function(){ return (new Date()).getTime() }\n\n// generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\nexport function hrtime(previousTimestamp){\n  var clocktime = performanceNow.call(performance)*1e-3\n  var seconds = Math.floor(clocktime)\n  var nanoseconds = Math.floor((clocktime%1)*1e9)\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0]\n    nanoseconds = nanoseconds - previousTimestamp[1]\n    if (nanoseconds<0) {\n      seconds--\n      nanoseconds += 1e9\n    }\n  }\n  return [seconds,nanoseconds]\n}\n\nvar startTime = new Date();\nexport function uptime() {\n  var currentTime = new Date();\n  var dif = currentTime - startTime;\n  return dif / 1000;\n}\n\nexport default {\n  nextTick: nextTick,\n  title: title,\n  browser: browser,\n  env: env,\n  argv: argv,\n  version: version,\n  versions: versions,\n  on: on,\n  addListener: addListener,\n  once: once,\n  off: off,\n  removeListener: removeListener,\n  removeAllListeners: removeAllListeners,\n  emit: emit,\n  binding: binding,\n  cwd: cwd,\n  chdir: chdir,\n  umask: umask,\n  hrtime: hrtime,\n  platform: platform,\n  release: release,\n  config: config,\n  uptime: uptime\n};\n","function getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = options || {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements\n    } = state;\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. This stops `shift()` from taking action, but can\n    // be worked around by calling it again after the `arrow()` if desired.\n    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n});\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = alignment !== undefined || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[main], overflow[cross]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = options;\n      const {\n        rects\n      } = state;\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getSideObjectFromPadding(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nasync function convertValueToCoords(state, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(state) : value;\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n  return {\n    name: 'offset',\n    options: value,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset(state) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const axis = getMainAxisFromPlacement(placement);\n      const isXAxis = axis === 'x';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isXAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isXAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction getNodeName(node) {\n  return isNode(node) ? (node.nodeName || '').toLowerCase() : '';\n}\n\nlet uaString;\nfunction getUAString() {\n  if (uaString) {\n    return uaString;\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    uaString = uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n    return uaString;\n  }\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try to use feature detection here instead.\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element);\n  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;\n\n  // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => {\n    // Add type check for old browsers.\n    const contain = css.contain;\n    return contain != null ? contain.includes(value) : false;\n  });\n}\n\n/**\n * Determines whether or not `.getBoundingClientRect()` is affected by visual\n * viewport offsets. In Safari, the `x`/`y` offsets are values relative to the\n * visual viewport, while in other engines, they are values relative to the\n * layout viewport.\n */\nfunction isClientRectVisualViewportBased() {\n  // TODO: Try to use feature detection here instead. Feature detection for\n  // this can fail in various ways, making the userAgent check the most\n  // reliable:\n  // • Always-visible scrollbar or not\n  // • Width of <html>\n\n  // Is Safari.\n  return /^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  let width = parseFloat(css.width);\n  let height = parseFloat(css.height);\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    fallback: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nconst FALLBACK_SCALE = {\n  x: 1,\n  y: 1\n};\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return FALLBACK_SCALE;\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    fallback\n  } = getCssDimensions(domElement);\n  let x = (fallback ? round(rect.width) : rect.width) / width;\n  let y = (fallback ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  var _win$visualViewport, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = FALLBACK_SCALE;\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const win = domElement ? getWindow(domElement) : window;\n  const addVisualOffsets = isClientRectVisualViewportBased() && isFixedStrategy;\n  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;\n  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += iframeRect.x;\n      y += iframeRect.y;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = {\n    x: 1,\n    y: 1\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    // `getParentNode` will never return a `Document` due to the fallback\n    // check, so it's either the <html> or <body> element.\n    return parentNode.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isClientRectVisualViewportBased();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : {\n    x: 1,\n    y: 1\n  };\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const mutableRect = {\n      ...clippingAncestor\n    };\n    if (isClientRectVisualViewportBased()) {\n      var _win$visualViewport, _win$visualViewport2;\n      const win = getWindow(element);\n      mutableRect.x -= ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0;\n      mutableRect.y -= ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0;\n    }\n    rect = mutableRect;\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getScale,\n  async getElementRects(_ref) {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await getDimensionsFn(floating))\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    // ignores Window, checks for [object VisualViewport]\n    const isVisualViewport = !isElement(ancestor) && ancestor.toString().includes('V');\n    if (ancestorScroll && (animationFrame ? isVisualViewport : true)) {\n      ancestor.addEventListener('scroll', update, {\n        passive: true\n      });\n    }\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n  if (elementResize) {\n    observer = new ResizeObserver(() => {\n      update();\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    if (!isElement(reference) && reference.contextElement && !animationFrame) {\n      observer.observe(reference.contextElement);\n    }\n    observer.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _observer;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, getOverflowAncestors, platform };\n","import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect } from 'react';\nimport * as ReactDOM from 'react-dom';\n\n/**\n * A data provider that provides data to position an inner element of the\n * floating element (usually a triangle or caret) so that it is centered to the\n * reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => {\n  const {\n    element,\n    padding\n  } = options;\n  function isRef(value) {\n    return Object.prototype.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(args) {\n      if (isRef(element)) {\n        if (element.current != null) {\n          return arrow$1({\n            element: element.current,\n            padding\n          }).fn(args);\n        }\n        return {};\n      } else if (element) {\n        return arrow$1({\n          element,\n          padding\n        }).fn(args);\n      }\n      return {};\n    }\n  };\n};\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length, i, keys;\n  if (a && b && typeof a == 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\n\nfunction useLatestRef(value) {\n  const ref = React.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/react\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = React.useState({\n    x: null,\n    y: null,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const referenceRef = React.useRef(null);\n  const floatingRef = React.useRef(null);\n  const dataRef = React.useRef(data);\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const [reference, _setReference] = React.useState(null);\n  const [floating, _setFloating] = React.useState(null);\n  const setReference = React.useCallback(node => {\n    if (referenceRef.current !== node) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = React.useCallback(node => {\n    if (floatingRef.current !== node) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const update = React.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    computePosition(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = {\n        ...data,\n        isPositioned: true\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => ({\n        ...data,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = React.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (reference && floating) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(reference, floating, update);\n      } else {\n        update();\n      }\n    }\n  }, [reference, floating, update, whileElementsMountedRef]);\n  const refs = React.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = React.useMemo(() => ({\n    reference,\n    floating\n  }), [reference, floating]);\n  return React.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    reference: setReference,\n    floating: setFloating\n  }), [data, update, refs, elements, setReference, setFloating]);\n}\n\nexport { arrow, useFloating };\n","import { platform, getOverflowAncestors, offset, detectOverflow, useFloating as useFloating$1 } from '@floating-ui/react-dom';\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/react-dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect, useRef } from 'react';\nimport { hideOthers } from 'aria-hidden';\nimport { tabbable } from 'tabbable';\nimport { createPortal, flushSync } from 'react-dom';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = () => \"floating-ui-\" + count++;\nfunction useFloatingId() {\n  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : undefined);\n  index(() => {\n    if (id == null) {\n      setId(genId());\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  React.useEffect(() => {\n    if (!serverHandoffComplete) {\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id;\n}\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useReactId = React[/*#__PURE__*/'useId'.toString()];\n\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/useId\n */\nconst useId = useReactId || useFloatingId;\n\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */\nconst FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(_ref, ref) {\n  var _rest$style;\n  let {\n    context: {\n      placement,\n      elements: {\n        floating\n      },\n      middlewareData: {\n        arrow\n      }\n    },\n    width = 14,\n    height = 7,\n    tipRadius = 0,\n    strokeWidth = 0,\n    staticOffset,\n    stroke,\n    d,\n    ...rest\n  } = _ref;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!ref) {\n      console.warn('Floating UI: The `ref` prop is required for the `FloatingArrow`', 'component.');\n    }\n  }\n\n  // Strokes must be double the border width, this ensures the stroke's width\n  // works as you'd expect.\n  strokeWidth *= 2;\n  const halfStrokeWidth = strokeWidth / 2;\n  const svgX = width / 2 * (tipRadius / -8 + 1);\n  const svgY = height / 2 * tipRadius / 4;\n  const [side, alignment] = placement.split('-');\n  const isRTL = floating ? platform.isRTL(floating) : false;\n  const isCustomShape = !!d;\n  const isVerticalSide = side === 'top' || side === 'bottom';\n  const yOffsetProp = staticOffset && alignment === 'end' ? 'bottom' : 'top';\n  let xOffsetProp = staticOffset && alignment === 'end' ? 'right' : 'left';\n  if (staticOffset && isRTL) {\n    xOffsetProp = alignment === 'end' ? 'left' : 'right';\n  }\n  const arrowOffsetY = isCustomShape ? 0 : halfStrokeWidth;\n  const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : '';\n  const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y + arrowOffsetY : '';\n  const dValue = d || 'M0,0' + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + ' Z';\n  const rotation = {\n    top: isCustomShape ? 'rotate(180deg)' : '',\n    left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',\n    bottom: isCustomShape ? '' : 'rotate(180deg)',\n    right: isCustomShape ? 'rotate(-90deg)' : 'rotate(90deg)'\n  }[side];\n  const clipPathId = useId();\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({}, rest, {\n    // @ts-ignore\n    suppressHydrationWarning: true,\n    \"aria-hidden\": true,\n    ref: ref,\n    width: isCustomShape ? width : width + strokeWidth,\n    height: width,\n    viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n    style: {\n      ...rest.style,\n      position: 'absolute',\n      pointerEvents: 'none',\n      [xOffsetProp]: arrowX,\n      [yOffsetProp]: arrowY,\n      [side]: isVerticalSide || isCustomShape ? '100%' : \"calc(100% - \" + strokeWidth / 2 + \"px)\",\n      transform: \"\" + rotation + ((_rest$style = rest.style) != null && _rest$style.transform ? \" \" + rest.style.transform : '')\n    }\n  }), strokeWidth > 0 && /*#__PURE__*/React.createElement(\"path\", {\n    clipPath: \"url(#\" + clipPathId + \")\",\n    fill: \"none\",\n    stroke: stroke\n    // Account for the stroke on the fill path rendered below.\n    ,\n    strokeWidth: strokeWidth + (d ? 0 : 1),\n    d: dValue\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    stroke: strokeWidth && !d ? rest.fill : 'none',\n    d: dValue\n  }), /*#__PURE__*/React.createElement(\"clipPath\", {\n    id: clipPathId\n  }, /*#__PURE__*/React.createElement(\"rect\", {\n    x: -halfStrokeWidth,\n    y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n    width: width + strokeWidth,\n    height: width\n  })));\n});\n\nfunction createPubSub() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach(handler => handler(data));\n    },\n    on(event, listener) {\n      map.set(event, [...(map.get(event) || []), listener]);\n    },\n    off(event, listener) {\n      var _map$get2;\n      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter(l => l !== listener)) || []);\n    }\n  };\n}\n\nconst FloatingNodeContext = /*#__PURE__*/React.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/React.createContext(null);\nconst useFloatingParentNodeId = () => {\n  var _React$useContext;\n  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\nconst useFloatingTree = () => React.useContext(FloatingTreeContext);\n\n/**\n * Registers a node into the floating tree, returning its id.\n */\nconst useFloatingNodeId = customParentId => {\n  const id = useId();\n  const tree = useFloatingTree();\n  const reactParentId = useFloatingParentNodeId();\n  const parentId = customParentId || reactParentId;\n  index(() => {\n    const node = {\n      id,\n      parentId\n    };\n    tree == null ? void 0 : tree.addNode(node);\n    return () => {\n      tree == null ? void 0 : tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n};\n\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nconst FloatingNode = _ref => {\n  let {\n    children,\n    id\n  } = _ref;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/React.createElement(FloatingNodeContext.Provider, {\n    value: React.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId])\n  }, children);\n};\n\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM (i.e. portalled to a common node, rather than their\n * respective parent).\n * @see https://floating-ui.com/docs/FloatingTree\n */\nconst FloatingTree = _ref2 => {\n  let {\n    children\n  } = _ref2;\n  const nodesRef = React.useRef([]);\n  const addNode = React.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = React.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const events = React.useState(() => createPubSub())[0];\n  return /*#__PURE__*/React.createElement(FloatingTreeContext.Provider, {\n    value: React.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [nodesRef, addNode, removeNode, events])\n  }, children);\n};\n\nfunction getDocument(node) {\n  return (node == null ? void 0 : node.ownerDocument) || document;\n}\n\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.platform) {\n    return uaData.platform;\n  }\n  return navigator.platform;\n}\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(_ref => {\n      let {\n        brand,\n        version\n      } = _ref;\n      return brand + \"/\" + version;\n    }).join(' ');\n  }\n  return navigator.userAgent;\n}\n\nfunction getWindow(value) {\n  return getDocument(value).defaultView || window;\n}\nfunction isElement(value) {\n  return value ? value instanceof getWindow(value).Element : false;\n}\nfunction isHTMLElement(value) {\n  return value ? value instanceof getWindow(value).HTMLElement : false;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n  if (event.mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n  const androidRe = /Android/i;\n  if ((androidRe.test(getPlatform()) || androidRe.test(getUserAgent())) && event.pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n  return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n  return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType !== 'mouse' ||\n  // iOS VoiceOver returns 0.333• for width/height.\n  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;\n}\nfunction isSafari() {\n  // Chrome DevTools does not complain about navigator.vendor\n  return /apple/i.test(navigator.vendor);\n}\nfunction isMac() {\n  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n  // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n  // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n  const values = ['mouse', 'pen'];\n  if (!strict) {\n    values.push('', undefined);\n  }\n  return values.includes(pointerType);\n}\n\nfunction contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode && child.getRootNode();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      // @ts-ignore\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\n\nfunction useLatestRef(value) {\n  const ref = useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\nconst safePolygonIdentifier = 'data-floating-ui-safe-polygon';\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && !isMouseLikePointerType(pointerType)) {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */\nconst useHover = function (context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    elements: {\n      domReference,\n      floating\n    },\n    refs\n  } = context;\n  const {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0,\n    move = true\n  } = props;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const handleCloseRef = useLatestRef(handleClose);\n  const delayRef = useLatestRef(delay);\n  const pointerTypeRef = React.useRef();\n  const timeoutRef = React.useRef();\n  const handlerRef = React.useRef();\n  const restTimeoutRef = React.useRef();\n  const blockMouseMoveRef = React.useRef(true);\n  const performedPointerEventsMutationRef = React.useRef(false);\n  const unbindMouseMoveRef = React.useRef(() => {});\n  const isHoverOpen = React.useCallback(() => {\n    var _dataRef$current$open;\n    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n  }, [dataRef]);\n\n  // When dismissing before opening, clear the delay timeouts to cancel it\n  // from showing.\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onDismiss() {\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      blockMouseMoveRef.current = true;\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n    };\n  }, [enabled, events]);\n  React.useEffect(() => {\n    if (!enabled || !handleCloseRef.current || !open) {\n      return;\n    }\n    function onLeave() {\n      if (isHoverOpen()) {\n        onOpenChange(false);\n      }\n    }\n    const html = getDocument(floating).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [floating, open, onOpenChange, enabled, handleCloseRef, dataRef, isHoverOpen]);\n  const closeWithDelay = React.useCallback(function (runElseBranch) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n    if (closeDelay && !handlerRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => onOpenChange(false), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeout(timeoutRef.current);\n      onOpenChange(false);\n    }\n  }, [delayRef, onOpenChange]);\n  const cleanupMouseMoveHandler = React.useCallback(() => {\n    unbindMouseMoveRef.current();\n    handlerRef.current = undefined;\n  }, []);\n  const clearPointerEvents = React.useCallback(() => {\n    if (performedPointerEventsMutationRef.current) {\n      const body = getDocument(refs.floating.current).body;\n      body.style.pointerEvents = '';\n      body.removeAttribute(safePolygonIdentifier);\n      performedPointerEventsMutationRef.current = false;\n    }\n  }, [refs]);\n\n  // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function isClickLikeOpenEvent() {\n      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n    }\n    function onMouseEnter(event) {\n      clearTimeout(timeoutRef.current);\n      blockMouseMoveRef.current = false;\n      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {\n        return;\n      }\n      dataRef.current.openEvent = event;\n      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n      if (openDelay) {\n        timeoutRef.current = setTimeout(() => {\n          onOpenChange(true);\n        }, openDelay);\n      } else {\n        onOpenChange(true);\n      }\n    }\n    function onMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      unbindMouseMoveRef.current();\n      const doc = getDocument(floating);\n      clearTimeout(restTimeoutRef.current);\n      if (handleCloseRef.current) {\n        // Prevent clearing `onScrollMouseLeave` timeout.\n        if (!open) {\n          clearTimeout(timeoutRef.current);\n        }\n        handlerRef.current = handleCloseRef.current({\n          ...context,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            closeWithDelay();\n          }\n        });\n        const handler = handlerRef.current;\n        doc.addEventListener('mousemove', handler);\n        unbindMouseMoveRef.current = () => {\n          doc.removeEventListener('mousemove', handler);\n        };\n        return;\n      }\n\n      // Allow interactivity without `safePolygon` on touch devices. With a\n      // pointer, a short close delay is an alternative, so it should work\n      // consistently.\n      const shouldClose = pointerTypeRef.current === 'touch' ? !contains(floating, event.relatedTarget) : true;\n      if (shouldClose) {\n        closeWithDelay();\n      }\n    }\n\n    // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n    function onScrollMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      handleCloseRef.current == null ? void 0 : handleCloseRef.current({\n        ...context,\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        onClose() {\n          clearPointerEvents();\n          cleanupMouseMoveHandler();\n          closeWithDelay();\n        }\n      })(event);\n    }\n    if (isElement(domReference)) {\n      const ref = domReference;\n      open && ref.addEventListener('mouseleave', onScrollMouseLeave);\n      floating == null ? void 0 : floating.addEventListener('mouseleave', onScrollMouseLeave);\n      move && ref.addEventListener('mousemove', onMouseEnter, {\n        once: true\n      });\n      ref.addEventListener('mouseenter', onMouseEnter);\n      ref.addEventListener('mouseleave', onMouseLeave);\n      return () => {\n        open && ref.removeEventListener('mouseleave', onScrollMouseLeave);\n        floating == null ? void 0 : floating.removeEventListener('mouseleave', onScrollMouseLeave);\n        move && ref.removeEventListener('mousemove', onMouseEnter);\n        ref.removeEventListener('mouseenter', onMouseEnter);\n        ref.removeEventListener('mouseleave', onMouseLeave);\n      };\n    }\n  }, [domReference, floating, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);\n\n  // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n  index(() => {\n    var _handleCloseRef$curre;\n    if (!enabled) {\n      return;\n    }\n    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n      const body = getDocument(floating).body;\n      body.setAttribute(safePolygonIdentifier, '');\n      body.style.pointerEvents = 'none';\n      performedPointerEventsMutationRef.current = true;\n      if (isElement(domReference) && floating) {\n        var _tree$nodesRef$curren, _tree$nodesRef$curren2;\n        const ref = domReference;\n        const parentFloating = tree == null ? void 0 : (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null ? void 0 : (_tree$nodesRef$curren2 = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren2.elements.floating;\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n        ref.style.pointerEvents = 'auto';\n        floating.style.pointerEvents = 'auto';\n        return () => {\n          ref.style.pointerEvents = '';\n          floating.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, dataRef, isHoverOpen]);\n  index(() => {\n    if (!open) {\n      pointerTypeRef.current = undefined;\n      cleanupMouseMoveHandler();\n      clearPointerEvents();\n    }\n  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n  React.useEffect(() => {\n    return () => {\n      cleanupMouseMoveHandler();\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      clearPointerEvents();\n    };\n  }, [enabled, cleanupMouseMoveHandler, clearPointerEvents]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setPointerRef(event) {\n      pointerTypeRef.current = event.pointerType;\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerRef,\n        onPointerEnter: setPointerRef,\n        onMouseMove() {\n          if (open || restMs === 0) {\n            return;\n          }\n          clearTimeout(restTimeoutRef.current);\n          restTimeoutRef.current = setTimeout(() => {\n            if (!blockMouseMoveRef.current) {\n              onOpenChange(true);\n            }\n          }, restMs);\n        }\n      },\n      floating: {\n        onMouseEnter() {\n          clearTimeout(timeoutRef.current);\n        },\n        onMouseLeave() {\n          events.emit('dismiss', {\n            type: 'mouseLeave',\n            data: {\n              returnFocus: false\n            }\n          });\n          closeWithDelay(false);\n        }\n      }\n    };\n  }, [events, enabled, restMs, open, onOpenChange, closeWithDelay]);\n};\n\nconst FloatingDelayGroupContext = /*#__PURE__*/React.createContext({\n  delay: 0,\n  initialDelay: 0,\n  timeoutMs: 0,\n  currentId: null,\n  setCurrentId: () => {},\n  setState: () => {},\n  isInstantPhase: false\n});\nconst useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);\n\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nconst FloatingDelayGroup = _ref => {\n  let {\n    children,\n    delay,\n    timeoutMs = 0\n  } = _ref;\n  const [state, setState] = React.useReducer((prev, next) => ({\n    ...prev,\n    ...next\n  }), {\n    delay,\n    timeoutMs,\n    initialDelay: delay,\n    currentId: null,\n    isInstantPhase: false\n  });\n  const initialCurrentIdRef = React.useRef(null);\n  const setCurrentId = React.useCallback(currentId => {\n    setState({\n      currentId\n    });\n  }, []);\n  index(() => {\n    if (state.currentId) {\n      if (initialCurrentIdRef.current === null) {\n        initialCurrentIdRef.current = state.currentId;\n      } else {\n        setState({\n          isInstantPhase: true\n        });\n      }\n    } else {\n      setState({\n        isInstantPhase: false\n      });\n      initialCurrentIdRef.current = null;\n    }\n  }, [state.currentId]);\n  return /*#__PURE__*/React.createElement(FloatingDelayGroupContext.Provider, {\n    value: React.useMemo(() => ({\n      ...state,\n      setState,\n      setCurrentId\n    }), [state, setState, setCurrentId])\n  }, children);\n};\nconst useDelayGroup = (_ref2, _ref3) => {\n  let {\n    open,\n    onOpenChange\n  } = _ref2;\n  let {\n    id\n  } = _ref3;\n  const {\n    currentId,\n    setCurrentId,\n    initialDelay,\n    setState,\n    timeoutMs\n  } = useDelayGroupContext();\n  React.useEffect(() => {\n    if (currentId) {\n      setState({\n        delay: {\n          open: 1,\n          close: getDelay(initialDelay, 'close')\n        }\n      });\n      if (currentId !== id) {\n        onOpenChange(false);\n      }\n    }\n  }, [id, onOpenChange, setState, currentId, initialDelay]);\n  React.useEffect(() => {\n    function unset() {\n      onOpenChange(false);\n      setState({\n        delay: initialDelay,\n        currentId: null\n      });\n    }\n    if (!open && currentId === id) {\n      if (timeoutMs) {\n        const timeout = window.setTimeout(unset, timeoutMs);\n        return () => {\n          clearTimeout(timeout);\n        };\n      } else {\n        unset();\n      }\n    }\n  }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);\n  React.useEffect(() => {\n    if (open) {\n      setCurrentId(id);\n    }\n  }, [open, setCurrentId, id]);\n};\n\n/**\n * Find the real active element. Traverses into shadowRoots.\n */\nfunction activeElement(doc) {\n  let activeElement = doc.activeElement;\n  while (((_activeElement = activeElement) == null ? void 0 : (_activeElement$shadow = _activeElement.shadowRoot) == null ? void 0 : _activeElement$shadow.activeElement) != null) {\n    var _activeElement, _activeElement$shadow;\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\n\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    preventScroll = false,\n    cancelPrevious = true,\n    sync = false\n  } = options;\n  cancelPrevious && cancelAnimationFrame(rafId);\n  const exec = () => el == null ? void 0 : el.focus({\n    preventScroll\n  });\n  if (sync) {\n    exec();\n  } else {\n    rafId = requestAnimationFrame(exec);\n  }\n}\n\nfunction getAncestors(nodes, id) {\n  var _nodes$find;\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n  return allAncestors;\n}\n\nfunction getChildren(nodes, id) {\n  let allChildren = nodes.filter(node => {\n    var _node$context;\n    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n  });\n  let currentChildren = allChildren;\n  while (currentChildren.length) {\n    currentChildren = nodes.filter(node => {\n      var _currentChildren;\n      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n        var _node$context2;\n        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n      });\n    });\n    allChildren = allChildren.concat(currentChildren);\n  }\n  return allChildren;\n}\n\nfunction getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\n\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\n\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\n\nconst getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck:\n  // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, direction) {\n  const allTabbable = tabbable(container, getTabbableOptions());\n  if (direction === 'prev') {\n    allTabbable.reverse();\n  }\n  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));\n  const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n  return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n  return getTabbableIn(document.body, 'next');\n}\nfunction getPreviousTabbable() {\n  return getTabbableIn(document.body, 'prev');\n}\nfunction isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !contains(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n  const tabbableElements = tabbable(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    element.dataset.tabindex = element.getAttribute('tabindex') || '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nfunction enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    delete element.dataset.tabindex;\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}\n\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\nconst HIDDEN_STYLES = {\n  border: 0,\n  clip: 'rect(0 0 0 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: 0,\n  position: 'fixed',\n  whiteSpace: 'nowrap',\n  width: '1px',\n  top: 0,\n  left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n  if (event.key === 'Tab') {\n    event.target;\n    clearTimeout(timeoutId);\n  }\n}\nconst FocusGuard = /*#__PURE__*/React.forwardRef(function FocusGuard(props, ref) {\n  const [role, setRole] = React.useState();\n  index(() => {\n    if (isSafari()) {\n      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n      // on VoiceOver does trigger the onFocus event, so we can use the focus\n      // trap element. On Safari, only buttons trigger the onFocus event.\n      // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n      // button role.\n      setRole('button');\n    }\n    document.addEventListener('keydown', setActiveElementOnTab);\n    return () => {\n      document.removeEventListener('keydown', setActiveElementOnTab);\n    };\n  }, []);\n  return /*#__PURE__*/React.createElement(\"span\", _extends({}, props, {\n    ref: ref,\n    tabIndex: 0\n    // Role is only for VoiceOver\n    ,\n    role: role,\n    \"aria-hidden\": role ? undefined : true,\n    \"data-floating-ui-focus-guard\": \"\",\n    style: HIDDEN_STYLES\n  }));\n});\n\nconst PortalContext = /*#__PURE__*/React.createContext(null);\nconst useFloatingPortalNode = function (_temp) {\n  let {\n    id,\n    root\n  } = _temp === void 0 ? {} : _temp;\n  const [portalNode, setPortalNode] = React.useState(null);\n  const uniqueId = useId();\n  const portalContext = usePortalContext();\n  index(() => {\n    const existingIdRoot = id ? document.getElementById(id) : null;\n    const attr = 'data-floating-ui-portal';\n    if (existingIdRoot) {\n      const subRoot = document.createElement('div');\n      subRoot.id = uniqueId;\n      subRoot.setAttribute(attr, '');\n      existingIdRoot.appendChild(subRoot);\n      setPortalNode(subRoot);\n      return () => {\n        subRoot.remove();\n      };\n    } else {\n      let container = (portalContext == null ? void 0 : portalContext.portalNode) || root || document.body;\n      let idWrapper = null;\n      if (id) {\n        idWrapper = document.createElement('div');\n        idWrapper.id = id;\n        container.appendChild(idWrapper);\n      }\n      const subRoot = document.createElement('div');\n      subRoot.id = uniqueId;\n      subRoot.setAttribute(attr, '');\n      setPortalNode(subRoot);\n      container = idWrapper || container;\n      container.appendChild(subRoot);\n      return () => {\n        var _idWrapper;\n        subRoot.remove();\n        (_idWrapper = idWrapper) == null ? void 0 : _idWrapper.remove();\n      };\n    }\n  }, [id, root, portalContext, uniqueId]);\n  return portalNode;\n};\n\n/**\n * Portals the floating element into a given container element — by default,\n * outside of the app root and into the body.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\nconst FloatingPortal = _ref => {\n  let {\n    children,\n    id,\n    root = null,\n    preserveTabOrder = true\n  } = _ref;\n  const portalNode = useFloatingPortalNode({\n    id,\n    root\n  });\n  const [focusManagerState, setFocusManagerState] = React.useState(null);\n  const beforeOutsideRef = React.useRef(null);\n  const afterOutsideRef = React.useRef(null);\n  const beforeInsideRef = React.useRef(null);\n  const afterInsideRef = React.useRef(null);\n  const shouldRenderGuards =\n  // The FocusManager and therefore floating element are currently open/\n  // rendered.\n  !!focusManagerState &&\n  // Guards are only for non-modal focus management.\n  !focusManagerState.modal && !!(root || portalNode) && preserveTabOrder;\n\n  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n  React.useEffect(() => {\n    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n      return;\n    }\n\n    // Make sure elements inside the portal element are tabbable only when the\n    // portal has already been focused, either by tabbing into a focus trap\n    // element outside or using the mouse.\n    function onFocus(event) {\n      if (portalNode && isOutsideEvent(event)) {\n        const focusing = event.type === 'focusin';\n        const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n        manageFocus(portalNode);\n      }\n    }\n    // Listen to the event on the capture phase so they run before the focus\n    // trap elements onFocus prop is called.\n    portalNode.addEventListener('focusin', onFocus, true);\n    portalNode.addEventListener('focusout', onFocus, true);\n    return () => {\n      portalNode.removeEventListener('focusin', onFocus, true);\n      portalNode.removeEventListener('focusout', onFocus, true);\n    };\n  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);\n  return /*#__PURE__*/React.createElement(PortalContext.Provider, {\n    value: React.useMemo(() => ({\n      preserveTabOrder,\n      beforeOutsideRef,\n      afterOutsideRef,\n      beforeInsideRef,\n      afterInsideRef,\n      portalNode,\n      setFocusManagerState\n    }), [preserveTabOrder, portalNode])\n  }, shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: beforeOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _beforeInsideRef$curr;\n        (_beforeInsideRef$curr = beforeInsideRef.current) == null ? void 0 : _beforeInsideRef$curr.focus();\n      } else {\n        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        prevTabbable == null ? void 0 : prevTabbable.focus();\n      }\n    }\n  }), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-owns\": portalNode.id,\n    style: HIDDEN_STYLES\n  }), portalNode && /*#__PURE__*/createPortal(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: afterOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _afterInsideRef$curre;\n        (_afterInsideRef$curre = afterInsideRef.current) == null ? void 0 : _afterInsideRef$curre.focus();\n      } else {\n        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        nextTabbable == null ? void 0 : nextTabbable.focus();\n        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false));\n      }\n    }\n  }));\n};\nconst usePortalContext = () => React.useContext(PortalContext);\n\nconst VisuallyHiddenDismiss = /*#__PURE__*/React.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n  return /*#__PURE__*/React.createElement(\"button\", _extends({}, props, {\n    type: \"button\",\n    ref: ref,\n    tabIndex: -1,\n    style: HIDDEN_STYLES\n  }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(_ref) {\n  let {\n    context,\n    children,\n    order = ['content'],\n    guards = true,\n    initialFocus = 0,\n    returnFocus = true,\n    modal = true,\n    visuallyHiddenDismiss = false,\n    closeOnFocusOut = true\n  } = _ref;\n  const {\n    open,\n    refs,\n    nodeId,\n    onOpenChange,\n    events,\n    dataRef,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const orderRef = useLatestRef(order);\n  const initialFocusRef = useLatestRef(initialFocus);\n  const returnFocusRef = useLatestRef(returnFocus);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n  const [tabbableContentLength, setTabbableContentLength] = React.useState(null);\n\n  // Controlled by `useListNavigation`.\n  const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;\n  const startDismissButtonRef = React.useRef(null);\n  const endDismissButtonRef = React.useRef(null);\n  const preventReturnFocusRef = React.useRef(false);\n  const previouslyFocusedElementRef = React.useRef(null);\n  const isPointerDownRef = React.useRef(false);\n  const isInsidePortal = portalContext != null;\n\n  // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n  const isTypeableCombobox = domReference && domReference.getAttribute('role') === 'combobox' && isTypeableElement(domReference);\n  const getTabbableContent = React.useCallback(function (container) {\n    if (container === void 0) {\n      container = floating;\n    }\n    return container ? tabbable(container, getTabbableOptions()) : [];\n  }, [floating]);\n  const getTabbableElements = React.useCallback(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(type => {\n      if (domReference && type === 'reference') {\n        return domReference;\n      }\n      if (floating && type === 'floating') {\n        return floating;\n      }\n      return content;\n    }).filter(Boolean).flat();\n  }, [domReference, floating, orderRef, getTabbableContent]);\n  React.useEffect(() => {\n    if (!modal) {\n      return;\n    }\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if (getTabbableContent().length === 0 && !isTypeableCombobox) {\n          stopEvent(event);\n        }\n        const els = getTabbableElements();\n        const target = getTarget(event);\n        if (orderRef.current[0] === 'reference' && target === domReference) {\n          stopEvent(event);\n          if (event.shiftKey) {\n            enqueueFocus(els[els.length - 1]);\n          } else {\n            enqueueFocus(els[1]);\n          }\n        }\n        if (orderRef.current[1] === 'floating' && target === floating && event.shiftKey) {\n          stopEvent(event);\n          enqueueFocus(els[0]);\n        }\n      }\n    }\n    const doc = getDocument(floating);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [domReference, floating, modal, orderRef, refs, isTypeableCombobox, getTabbableContent, getTabbableElements]);\n  React.useEffect(() => {\n    if (!closeOnFocusOut) {\n      return;\n    }\n\n    // In Safari, buttons lose focus when pressing them.\n    function handlePointerDown() {\n      isPointerDownRef.current = true;\n      setTimeout(() => {\n        isPointerDownRef.current = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      queueMicrotask(() => {\n        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute('data-floating-ui-focus-guard') || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context, _node$context2;\n          return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n        }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context3, _node$context4;\n          return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n        })));\n\n        // Focus did not move inside the floating tree, and there are no tabbable\n        // portal guards to handle closing.\n        if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&\n        // Fix React 18 Strict Mode returnFocus due to double rendering.\n        relatedTarget !== previouslyFocusedElementRef.current) {\n          preventReturnFocusRef.current = true;\n          onOpenChange(false);\n        }\n      });\n    }\n    if (floating && isHTMLElement(domReference)) {\n      domReference.addEventListener('focusout', handleFocusOutside);\n      domReference.addEventListener('pointerdown', handlePointerDown);\n      !modal && floating.addEventListener('focusout', handleFocusOutside);\n      return () => {\n        domReference.removeEventListener('focusout', handleFocusOutside);\n        domReference.removeEventListener('pointerdown', handlePointerDown);\n        !modal && floating.removeEventListener('focusout', handleFocusOutside);\n      };\n    }\n  }, [domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);\n  React.useEffect(() => {\n    var _portalContext$portal;\n    // Don't hide portals nested within the parent portal.\n    const portalNodes = Array.from((portalContext == null ? void 0 : (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll('[data-floating-ui-portal]')) || []);\n    function getDismissButtons() {\n      return [startDismissButtonRef.current, endDismissButtonRef.current].filter(Boolean);\n    }\n    if (floating && modal) {\n      const insideNodes = [floating, ...portalNodes, ...getDismissButtons()];\n      const cleanup = hideOthers(orderRef.current.includes('reference') || isTypeableCombobox ? insideNodes.concat(domReference || []) : insideNodes);\n      return () => {\n        cleanup();\n      };\n    }\n  }, [domReference, floating, modal, orderRef, portalContext, isTypeableCombobox]);\n  React.useEffect(() => {\n    if (modal && !guards && floating) {\n      const tabIndexValues = [];\n      const options = getTabbableOptions();\n      const allTabbable = tabbable(getDocument(floating).body, options);\n      const floatingTabbable = getTabbableElements();\n\n      // Exclude all tabbable elements that are part of the order\n      const elements = allTabbable.filter(el => !floatingTabbable.includes(el));\n      elements.forEach((el, i) => {\n        tabIndexValues[i] = el.getAttribute('tabindex');\n        el.setAttribute('tabindex', '-1');\n      });\n      return () => {\n        elements.forEach((el, i) => {\n          const value = tabIndexValues[i];\n          if (value == null) {\n            el.removeAttribute('tabindex');\n          } else {\n            el.setAttribute('tabindex', value);\n          }\n        });\n      };\n    }\n  }, [floating, modal, guards, getTabbableElements]);\n  index(() => {\n    if (!floating) return;\n    let preventReturnFocusScroll = false;\n    const doc = getDocument(floating);\n    const previouslyFocusedElement = activeElement(doc);\n    const contextData = dataRef.current;\n    previouslyFocusedElementRef.current = previouslyFocusedElement;\n\n    // Wait for any layout effect state setters to execute to set `tabIndex`.\n    queueMicrotask(() => {\n      const focusableElements = getTabbableElements(floating);\n      const initialFocusValue = initialFocusRef.current;\n      const elToFocus = (typeof initialFocusValue === 'number' ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;\n      const focusAlreadyInsideFloatingEl = contains(floating, previouslyFocusedElement);\n      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n        enqueueFocus(elToFocus, {\n          preventScroll: elToFocus === floating\n        });\n      }\n    });\n\n    // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n    function onDismiss(payload) {\n      if (payload.type === 'escapeKey' && refs.domReference.current) {\n        previouslyFocusedElementRef.current = refs.domReference.current;\n      }\n      if (['referencePress', 'escapeKey'].includes(payload.type)) {\n        return;\n      }\n      const returnFocus = payload.data.returnFocus;\n      if (typeof returnFocus === 'object') {\n        preventReturnFocusRef.current = false;\n        preventReturnFocusScroll = returnFocus.preventScroll;\n      } else {\n        preventReturnFocusRef.current = !returnFocus;\n      }\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n      const activeEl = activeElement(doc);\n      const shouldFocusReference = contains(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context5;\n        return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n      }) || contextData.openEvent && ['click', 'mousedown'].includes(contextData.openEvent.type);\n      if (shouldFocusReference && refs.domReference.current) {\n        previouslyFocusedElementRef.current = refs.domReference.current;\n      }\n      if (\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      returnFocusRef.current && isHTMLElement(previouslyFocusedElementRef.current) && !preventReturnFocusRef.current) {\n        // `isPointerDownRef.current` to avoid the focus ring from appearing on\n        // the reference element when click-toggling it.\n        enqueueFocus(previouslyFocusedElementRef.current, {\n          // When dismissing nested floating elements, by the time the rAF has\n          // executed, the menus will all have been unmounted. When they try\n          // to get focused, the calls get ignored — leaving the root\n          // reference focused as desired.\n          cancelPrevious: false,\n          preventScroll: preventReturnFocusScroll\n        });\n      }\n    };\n  }, [open, floating, getTabbableElements, returnFocusRef, initialFocusRef, dataRef, refs, events, ignoreInitialFocus, tree, nodeId]);\n\n  // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n  index(() => {\n    if (!portalContext) return;\n    portalContext.setFocusManagerState({\n      ...context,\n      modal,\n      closeOnFocusOut\n      // Not concerned about the <RT> generic type.\n    });\n\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [portalContext, modal, closeOnFocusOut, context]);\n  index(() => {\n    if (ignoreInitialFocus || !floating) return;\n    function setState() {\n      if (activeElement(getDocument(floating)) !== refs.domReference.current) {\n        setTabbableContentLength(getTabbableContent().length);\n      }\n    }\n    setState();\n    if (typeof MutationObserver === 'function') {\n      const observer = new MutationObserver(setState);\n      observer.observe(floating, {\n        childList: true,\n        subtree: true\n      });\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [floating, getTabbableContent, ignoreInitialFocus, refs]);\n  const shouldRenderGuards = guards && (isInsidePortal || modal) && !isTypeableCombobox;\n  function renderDismissButton(location) {\n    return visuallyHiddenDismiss && modal ? /*#__PURE__*/React.createElement(VisuallyHiddenDismiss, {\n      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n      onClick: () => onOpenChange(false)\n    }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss') : null;\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n    onFocus: event => {\n      if (modal) {\n        const els = getTabbableElements();\n        enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = false;\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const nextTabbable = getNextTabbable() || domReference;\n          nextTabbable == null ? void 0 : nextTabbable.focus();\n        } else {\n          var _portalContext$before;\n          (_portalContext$before = portalContext.beforeOutsideRef.current) == null ? void 0 : _portalContext$before.focus();\n        }\n      }\n    }\n  }), isTypeableCombobox ? null : renderDismissButton('start'), /*#__PURE__*/React.cloneElement(children, tabbableContentLength === 0 || order.includes('floating') ? {\n    tabIndex: 0\n  } : {}), renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n    onFocus: event => {\n      if (modal) {\n        enqueueFocus(getTabbableElements()[0]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        if (closeOnFocusOut) {\n          preventReturnFocusRef.current = true;\n        }\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const prevTabbable = getPreviousTabbable() || domReference;\n          prevTabbable == null ? void 0 : prevTabbable.focus();\n        } else {\n          var _portalContext$afterO;\n          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null ? void 0 : _portalContext$afterO.focus();\n        }\n      }\n    }\n  }));\n}\n\nconst identifier = 'data-floating-ui-scroll-lock';\n\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\nconst FloatingOverlay = /*#__PURE__*/React.forwardRef(function FloatingOverlay(_ref, ref) {\n  let {\n    lockScroll = false,\n    ...rest\n  } = _ref;\n  index(() => {\n    var _window$visualViewpor, _window$visualViewpor2;\n    if (!lockScroll) {\n      return;\n    }\n    const alreadyLocked = document.body.hasAttribute(identifier);\n    if (alreadyLocked) {\n      return;\n    }\n    document.body.setAttribute(identifier, '');\n\n    // RTL <body> scrollbar\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n\n    // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n    if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {\n      Object.assign(document.body.style, {\n        overflow: 'hidden',\n        [paddingProp]: scrollbarWidth + \"px\"\n      });\n      return () => {\n        document.body.removeAttribute(identifier);\n        Object.assign(document.body.style, {\n          overflow: '',\n          [paddingProp]: ''\n        });\n      };\n    }\n\n    // iOS 12 does not support `visualViewport`.\n    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n    const scrollX = window.pageXOffset;\n    const scrollY = window.pageYOffset;\n    Object.assign(document.body.style, {\n      position: 'fixed',\n      overflow: 'hidden',\n      top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n      left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n      right: '0',\n      [paddingProp]: scrollbarWidth + \"px\"\n    });\n    return () => {\n      Object.assign(document.body.style, {\n        position: '',\n        overflow: '',\n        top: '',\n        left: '',\n        right: '',\n        [paddingProp]: ''\n      });\n      document.body.removeAttribute(identifier);\n      window.scrollTo(scrollX, scrollY);\n    };\n  }, [lockScroll]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    style: {\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...rest.style\n    }\n  }));\n});\n\nfunction isButtonTarget(event) {\n  return isHTMLElement(event.target) && event.target.tagName === 'BUTTON';\n}\nfunction isSpaceIgnored(element) {\n  return isTypeableElement(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */\nconst useClick = function (context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    event: eventOption = 'click',\n    toggle = true,\n    ignoreMouse = false,\n    keyboardHandlers = true\n  } = props;\n  const pointerTypeRef = React.useRef();\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onPointerDown(event) {\n          pointerTypeRef.current = event.pointerType;\n        },\n        onMouseDown(event) {\n          // Ignore all buttons except for the \"main\" button.\n          // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n          if (event.button !== 0) {\n            return;\n          }\n          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (eventOption === 'click') {\n            return;\n          }\n          if (open) {\n            if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n              onOpenChange(false);\n            }\n          } else {\n            // Prevent stealing focus from the floating element\n            event.preventDefault();\n            onOpenChange(true);\n          }\n          dataRef.current.openEvent = event.nativeEvent;\n        },\n        onClick(event) {\n          if (eventOption === 'mousedown' && pointerTypeRef.current) {\n            pointerTypeRef.current = undefined;\n            return;\n          }\n          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (open) {\n            if (toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {\n              onOpenChange(false);\n            }\n          } else {\n            onOpenChange(true);\n          }\n          dataRef.current.openEvent = event.nativeEvent;\n        },\n        onKeyDown(event) {\n          pointerTypeRef.current = undefined;\n          if (!keyboardHandlers) {\n            return;\n          }\n          if (isButtonTarget(event)) {\n            return;\n          }\n          if (event.key === ' ' && !isSpaceIgnored(domReference)) {\n            // Prevent scrolling\n            event.preventDefault();\n          }\n          if (event.key === 'Enter') {\n            if (open) {\n              if (toggle) {\n                onOpenChange(false);\n              }\n            } else {\n              onOpenChange(true);\n            }\n          }\n        },\n        onKeyUp(event) {\n          if (!keyboardHandlers) {\n            return;\n          }\n          if (isButtonTarget(event) || isSpaceIgnored(domReference)) {\n            return;\n          }\n          if (event.key === ' ') {\n            if (open) {\n              if (toggle) {\n                onOpenChange(false);\n              }\n            } else {\n              onOpenChange(true);\n            }\n          }\n        }\n      }\n    };\n  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);\n};\n\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = React[/*#__PURE__*/'useInsertionEffect'.toString()];\nconst useSafeInsertionEffect = useInsertionEffect || (fn => fn());\nfunction useEvent(callback) {\n  const ref = React.useRef(() => {\n    if (process.env.NODE_ENV !== \"production\") {\n      throw new Error('Cannot call an event handler while rendering.');\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\n\nfunction createVirtualElement(domRef, data) {\n  let offsetX = null;\n  let offsetY = null;\n  let isAutoUpdateEvent = false;\n  return {\n    contextElement: domRef.current || undefined,\n    getBoundingClientRect() {\n      var _domRef$current, _data$dataRef$current;\n      const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      const isXAxis = data.axis === 'x' || data.axis === 'both';\n      const isYAxis = data.axis === 'y' || data.axis === 'both';\n      const canTrackCursorOnAutoUpdate = ['mouseenter', 'mousemove'].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || '') && data.pointerType !== 'touch';\n      let width = domRect.width;\n      let height = domRect.height;\n      let x = domRect.x;\n      let y = domRect.y;\n      if (offsetX == null && data.x && isXAxis) {\n        offsetX = domRect.x - data.x;\n      }\n      if (offsetY == null && data.y && isYAxis) {\n        offsetY = domRect.y - data.y;\n      }\n      x -= offsetX || 0;\n      y -= offsetY || 0;\n      width = 0;\n      height = 0;\n      if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n        width = data.axis === 'y' ? domRect.width : 0;\n        height = data.axis === 'x' ? domRect.height : 0;\n        x = isXAxis && data.x != null ? data.x : x;\n        y = isYAxis && data.y != null ? data.y : y;\n      } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n        height = data.axis === 'x' ? domRect.height : height;\n        width = data.axis === 'y' ? domRect.width : width;\n      }\n      isAutoUpdateEvent = true;\n      return {\n        width,\n        height,\n        x,\n        y,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x\n      };\n    }\n  };\n}\nfunction isMouseBasedEvent(event) {\n  return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */\nconst useClientPoint = function (_ref, _temp) {\n  let {\n    open,\n    refs,\n    dataRef,\n    elements: {\n      floating\n    }\n  } = _ref;\n  let {\n    enabled = true,\n    axis = 'both',\n    x = null,\n    y = null\n  } = _temp === void 0 ? {} : _temp;\n  const initialRef = React.useRef(false);\n  const cleanupListenerRef = React.useRef(null);\n  const [pointerType, setPointerType] = React.useState();\n  const [reactive, setReactive] = React.useState([]);\n  const setReference = useEvent((x, y) => {\n    if (initialRef.current) return;\n\n    // Prevent setting if the open event was not a mouse-like one\n    // (e.g. focus to open, then hover over the reference element).\n    // Only apply if the event exists.\n    if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n      return;\n    }\n    refs.setPositionReference(createVirtualElement(refs.domReference, {\n      x,\n      y,\n      axis,\n      dataRef,\n      pointerType\n    }));\n  });\n  const handleReferenceEnterOrMove = useEvent(event => {\n    if (x != null || y != null) return;\n    if (!open) {\n      setReference(event.clientX, event.clientY);\n    } else if (!cleanupListenerRef.current) {\n      // If there's no cleanup, there's no listener, but we want to ensure\n      // we add the listener if the cursor landed on the floating element and\n      // then back on the reference (i.e. it's interactive).\n      setReactive([]);\n    }\n  });\n\n  // If the pointer is a mouse-like pointer, we want to continue following the\n  // mouse even if the floating element is transitioning out. On touch\n  // devices, this is undesirable because the floating element will move to\n  // the dismissal touch point.\n  const openCheck = isMouseLikePointerType(pointerType) ? floating : open;\n  const addListener = React.useCallback(() => {\n    // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n    if (!openCheck || !enabled || x != null || y != null) return;\n    const win = getWindow(refs.floating.current);\n    function handleMouseMove(event) {\n      const target = getTarget(event);\n      if (!contains(refs.floating.current, target)) {\n        setReference(event.clientX, event.clientY);\n      } else {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      }\n    }\n    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n      win.addEventListener('mousemove', handleMouseMove);\n      const cleanup = () => {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      };\n      cleanupListenerRef.current = cleanup;\n      return cleanup;\n    }\n    refs.setPositionReference(refs.domReference.current);\n  }, [dataRef, enabled, openCheck, refs, setReference, x, y]);\n  React.useEffect(() => {\n    return addListener();\n  }, [addListener, reactive]);\n  React.useEffect(() => {\n    if (enabled && !floating) {\n      initialRef.current = false;\n    }\n  }, [enabled, floating]);\n  React.useEffect(() => {\n    if (!enabled && open) {\n      initialRef.current = true;\n    }\n  }, [enabled, open]);\n  index(() => {\n    if (enabled && (x != null || y != null)) {\n      initialRef.current = false;\n      setReference(x, y);\n    }\n  }, [enabled, x, y, setReference]);\n  return React.useMemo(() => {\n    if (!enabled) return {};\n    function setPointerTypeRef(_ref2) {\n      let {\n        pointerType\n      } = _ref2;\n      setPointerType(pointerType);\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerTypeRef,\n        onPointerEnter: setPointerTypeRef,\n        onMouseMove: handleReferenceEnterOrMove,\n        onMouseEnter: handleReferenceEnterOrMove\n      }\n    };\n  }, [enabled, handleReferenceEnterOrMove]);\n};\n\n/**\n * Check whether the event.target is within the provided node. Uses event.composedPath if available for custom element support.\n *\n * @param event The event whose target/composedPath to check\n * @param node The node to check against\n * @returns Whether the event.target/composedPath is within the node.\n */\nfunction isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const e = event;\n  return e.target != null && node.contains(e.target);\n}\n\nconst bubbleHandlerKeys = {\n  pointerdown: 'onPointerDown',\n  mousedown: 'onMouseDown',\n  click: 'onClick'\n};\nconst captureHandlerKeys = {\n  pointerdown: 'onPointerDownCapture',\n  mousedown: 'onMouseDownCapture',\n  click: 'onClickCapture'\n};\nconst normalizeBubblesProp = bubbles => {\n  var _bubbles$escapeKey, _bubbles$outsidePress;\n  return {\n    escapeKeyBubbles: typeof bubbles === 'boolean' ? bubbles : (_bubbles$escapeKey = bubbles == null ? void 0 : bubbles.escapeKey) != null ? _bubbles$escapeKey : false,\n    outsidePressBubbles: typeof bubbles === 'boolean' ? bubbles : (_bubbles$outsidePress = bubbles == null ? void 0 : bubbles.outsidePress) != null ? _bubbles$outsidePress : true\n  };\n};\n/**\n * Closes the floating element when a dismissal is requested — by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nconst useDismiss = function (context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    events,\n    nodeId,\n    elements: {\n      reference,\n      domReference,\n      floating\n    },\n    dataRef\n  } = context;\n  const {\n    enabled = true,\n    escapeKey = true,\n    outsidePress: unstable_outsidePress = true,\n    outsidePressEvent = 'pointerdown',\n    referencePress = false,\n    referencePressEvent = 'pointerdown',\n    ancestorScroll = false,\n    bubbles\n  } = props;\n  const tree = useFloatingTree();\n  const nested = useFloatingParentNodeId() != null;\n  const outsidePressFn = useEvent(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);\n  const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;\n  const insideReactTreeRef = React.useRef(false);\n  const {\n    escapeKeyBubbles,\n    outsidePressBubbles\n  } = normalizeBubblesProp(bubbles);\n  const closeOnEscapeKeyDown = useEvent(event => {\n    if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (!escapeKeyBubbles) {\n      event.stopPropagation();\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          var _child$context;\n          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n            shouldDismiss = false;\n            return;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n    }\n    events.emit('dismiss', {\n      type: 'escapeKey',\n      data: {\n        returnFocus: {\n          preventScroll: false\n        }\n      }\n    });\n    onOpenChange(false);\n  });\n  const closeOnPressOutside = useEvent(event => {\n    // Given developers can stop the propagation of the synthetic event,\n    // we can only be confident with a positive value.\n    const insideReactTree = insideReactTreeRef.current;\n    insideReactTreeRef.current = false;\n    if (insideReactTree) {\n      return;\n    }\n    if (typeof outsidePress === 'function' && !outsidePress(event)) {\n      return;\n    }\n    const target = getTarget(event);\n\n    // Check if the click occurred on the scrollbar\n    if (isHTMLElement(target) && floating) {\n      // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n      // elements.\n      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n      let xCond = canScrollY && event.offsetX > target.clientWidth;\n\n      // In some browsers it is possible to change the <body> (or window)\n      // scrollbar to the left side, but is very rare and is difficult to\n      // check for. Plus, for modal dialogs with backdrops, it is more\n      // important that the backdrop is checked but not so much the window.\n      if (canScrollY) {\n        const isRTL = getWindow(floating).getComputedStyle(target).direction === 'rtl';\n        if (isRTL) {\n          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n        }\n      }\n      if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n        return;\n      }\n    }\n    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n      var _node$context;\n      return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n    });\n    if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (children.length > 0) {\n      let shouldDismiss = true;\n      children.forEach(child => {\n        var _child$context2;\n        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n          shouldDismiss = false;\n          return;\n        }\n      });\n      if (!shouldDismiss) {\n        return;\n      }\n    }\n    events.emit('dismiss', {\n      type: 'outsidePress',\n      data: {\n        returnFocus: nested ? {\n          preventScroll: true\n        } : isVirtualClick(event) || isVirtualPointerEvent(event)\n      }\n    });\n    onOpenChange(false);\n  });\n  React.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n    dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n    function onScroll() {\n      onOpenChange(false);\n    }\n    const doc = getDocument(floating);\n    escapeKey && doc.addEventListener('keydown', closeOnEscapeKeyDown);\n    outsidePress && doc.addEventListener(outsidePressEvent, closeOnPressOutside);\n    let ancestors = [];\n    if (ancestorScroll) {\n      if (isElement(domReference)) {\n        ancestors = getOverflowAncestors(domReference);\n      }\n      if (isElement(floating)) {\n        ancestors = ancestors.concat(getOverflowAncestors(floating));\n      }\n      if (!isElement(reference) && reference && reference.contextElement) {\n        ancestors = ancestors.concat(getOverflowAncestors(reference.contextElement));\n      }\n    }\n\n    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n    ancestors = ancestors.filter(ancestor => {\n      var _doc$defaultView;\n      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n    });\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      escapeKey && doc.removeEventListener('keydown', closeOnEscapeKeyDown);\n      outsidePress && doc.removeEventListener(outsidePressEvent, closeOnPressOutside);\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n    };\n  }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, closeOnPressOutside]);\n  React.useEffect(() => {\n    insideReactTreeRef.current = false;\n  }, [outsidePress, outsidePressEvent]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onKeyDown: closeOnEscapeKeyDown,\n        [bubbleHandlerKeys[referencePressEvent]]: () => {\n          if (referencePress) {\n            events.emit('dismiss', {\n              type: 'referencePress',\n              data: {\n                returnFocus: false\n              }\n            });\n            onOpenChange(false);\n          }\n        }\n      },\n      floating: {\n        onKeyDown: closeOnEscapeKeyDown,\n        [captureHandlerKeys[outsidePressEvent]]: () => {\n          insideReactTreeRef.current = true;\n        }\n      }\n    };\n  }, [enabled, events, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);\n};\n\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */\nconst useFocus = function (context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    refs,\n    elements: {\n      floating,\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    keyboardOnly = true\n  } = props;\n  const pointerTypeRef = React.useRef('');\n  const blockFocusRef = React.useRef(false);\n  const timeoutRef = React.useRef();\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    const doc = getDocument(floating);\n    const win = doc.defaultView || window;\n\n    // If the reference was focused and the user left the tab/window, and the\n    // floating element was not open, the focus should be blocked when they\n    // return to the tab/window.\n    function onBlur() {\n      if (!open && isHTMLElement(domReference) && domReference === activeElement(getDocument(domReference))) {\n        blockFocusRef.current = true;\n      }\n    }\n    win.addEventListener('blur', onBlur);\n    return () => {\n      win.removeEventListener('blur', onBlur);\n    };\n  }, [floating, domReference, open, enabled]);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onDismiss(payload) {\n      if (payload.type === 'referencePress' || payload.type === 'escapeKey') {\n        blockFocusRef.current = true;\n      }\n    }\n    events.on('dismiss', onDismiss);\n    return () => {\n      events.off('dismiss', onDismiss);\n    };\n  }, [events, enabled]);\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(timeoutRef.current);\n    };\n  }, []);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onPointerDown(_ref) {\n          let {\n            pointerType\n          } = _ref;\n          pointerTypeRef.current = pointerType;\n          blockFocusRef.current = !!(pointerType && keyboardOnly);\n        },\n        onMouseLeave() {\n          blockFocusRef.current = false;\n        },\n        onFocus(event) {\n          var _dataRef$current$open;\n          if (blockFocusRef.current) {\n            return;\n          }\n\n          // Dismiss with click should ignore the subsequent `focus` trigger,\n          // but only if the click originated inside the reference element.\n          if (event.type === 'focus' && ((_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type) === 'mousedown' && dataRef.current.openEvent && isEventTargetWithin(dataRef.current.openEvent, domReference)) {\n            return;\n          }\n          dataRef.current.openEvent = event.nativeEvent;\n          onOpenChange(true);\n        },\n        onBlur(event) {\n          blockFocusRef.current = false;\n          const relatedTarget = event.relatedTarget;\n\n          // Hit the non-modal focus management portal guard. Focus will be\n          // moved into the floating element immediately after.\n          const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute('data-floating-ui-focus-guard') && relatedTarget.getAttribute('data-type') === 'outside';\n\n          // Wait for the window blur listener to fire.\n          timeoutRef.current = setTimeout(() => {\n            // When focusing the reference element (e.g. regular click), then\n            // clicking into the floating element, prevent it from hiding.\n            // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n            if (contains(refs.floating.current, relatedTarget) || contains(domReference, relatedTarget) || movedToFocusGuard) {\n              return;\n            }\n            onOpenChange(false);\n          });\n        }\n      }\n    };\n  }, [enabled, keyboardOnly, domReference, refs, dataRef, onOpenChange]);\n};\n\nlet isPreventScrollSupported = false;\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\nfunction isDifferentRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices,\n    amount = 1\n  } = _temp === void 0 ? {} : _temp;\n  const list = listRef.current;\n  let index = startingIndex;\n  do {\n    var _list$index, _list$index2;\n    index = index + (decrement ? -amount : amount);\n  } while (index >= 0 && index <= list.length - 1 && (disabledIndices ? disabledIndices.includes(index) : list[index] == null || ((_list$index = list[index]) == null ? void 0 : _list$index.hasAttribute('disabled')) || ((_list$index2 = list[index]) == null ? void 0 : _list$index2.getAttribute('aria-disabled')) === 'true'));\n  return index;\n}\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key == ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction getMinIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    disabledIndices\n  });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nconst useListNavigation = (context, props) => {\n  const {\n    open,\n    onOpenChange,\n    refs,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onNavigate: unstable_onNavigate = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    cols = 1,\n    scrollItemIntoView = true\n  } = props;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (allowEscape) {\n      if (!loop) {\n        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));\n      }\n      if (!virtual) {\n        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either \"horizontal\" or \"both\".'].join(' '));\n    }\n  }\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  const onNavigate = useEvent(unstable_onNavigate);\n  const focusItemOnOpenRef = React.useRef(focusItemOnOpen);\n  const indexRef = React.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = React.useRef(null);\n  const isPointerModalityRef = React.useRef(true);\n  const previousOnNavigateRef = React.useRef(onNavigate);\n  const previousMountedRef = React.useRef(!!floating);\n  const forceSyncFocus = React.useRef(false);\n  const forceScrollIntoViewRef = React.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n  const [activeId, setActiveId] = React.useState();\n  const focusItem = useEvent(function (listRef, indexRef, forceScrollIntoView) {\n    if (forceScrollIntoView === void 0) {\n      forceScrollIntoView = false;\n    }\n    const item = listRef.current[indexRef.current];\n    if (!item) return;\n    if (virtual) {\n      setActiveId(item == null ? void 0 : item.id);\n    } else {\n      enqueueFocus(item, {\n        preventScroll: true,\n        // Mac Safari does not move the virtual cursor unless the focus call\n        // is sync. However, for the very first focus call, we need to wait\n        // for the position to be ready in order to prevent unwanted\n        // scrolling. This means the virtual cursor will not move to the first\n        // item when first opening the floating element, but will on\n        // subsequent calls. `preventScroll` is supported in modern Safari,\n        // so we can use that instead.\n        // iOS Safari must be async or the first item will not be focused.\n        sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false\n      });\n    }\n    requestAnimationFrame(() => {\n      const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n      if (shouldScrollIntoView) {\n        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n        // by all browsers.\n        item.scrollIntoView == null ? void 0 : item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {\n          block: 'nearest',\n          inline: 'nearest'\n        } : scrollIntoViewOptions);\n      }\n    });\n  });\n  index(() => {\n    document.createElement('div').focus({\n      get preventScroll() {\n        isPreventScrollSupported = true;\n        return false;\n      }\n    });\n  }, []);\n\n  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        // Regardless of the pointer modality, we want to ensure the selected\n        // item comes into view when the floating element is opened.\n        forceScrollIntoViewRef.current = true;\n        onNavigate(selectedIndex);\n      }\n    } else if (previousMountedRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function.\n      indexRef.current = -1;\n      previousOnNavigateRef.current(null);\n    }\n  }, [enabled, open, floating, selectedIndex, onNavigate]);\n\n  // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (activeIndex == null) {\n        forceSyncFocus.current = false;\n        if (selectedIndex != null) {\n          return;\n        }\n\n        // Reset while the floating element was open (e.g. the list changed).\n        if (previousMountedRef.current) {\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n        }\n\n        // Initial sync.\n        if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n          let runs = 0;\n          const waitForListPopulated = () => {\n            if (listRef.current[0] == null) {\n              // Avoid letting the browser paint if possible on the first try,\n              // otherwise use rAF. Don't try more than twice, since something\n              // is wrong otherwise.\n              if (runs < 2) {\n                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                scheduler(waitForListPopulated);\n              }\n              runs++;\n            } else {\n              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n              keyRef.current = null;\n              onNavigate(indexRef.current);\n            }\n          };\n          waitForListPopulated();\n        }\n      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n        indexRef.current = activeIndex;\n        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n        forceScrollIntoViewRef.current = false;\n      }\n    }\n  }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n  // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (previousMountedRef.current && !floating && tree) {\n      var _nodes$find, _nodes$find$context;\n      const nodes = tree.nodesRef.current;\n      const parent = (_nodes$find = nodes.find(node => node.id === parentId)) == null ? void 0 : (_nodes$find$context = _nodes$find.context) == null ? void 0 : _nodes$find$context.elements.floating;\n      const activeEl = activeElement(getDocument(floating));\n      const treeContainsActiveEl = nodes.some(node => node.context && contains(node.context.elements.floating, activeEl));\n      if (parent && !treeContainsActiveEl) {\n        parent.focus({\n          preventScroll: true\n        });\n      }\n    }\n  }, [enabled, floating, tree, parentId]);\n  index(() => {\n    previousOnNavigateRef.current = onNavigate;\n    previousMountedRef.current = !!floating;\n  });\n  index(() => {\n    if (!open) {\n      keyRef.current = null;\n    }\n  }, [open]);\n  const hasActiveIndex = activeIndex != null;\n  const item = React.useMemo(() => {\n    function syncCurrentTarget(currentTarget) {\n      if (!open) return;\n      const index = listRef.current.indexOf(currentTarget);\n      if (index !== -1) {\n        onNavigate(index);\n      }\n    }\n    const props = {\n      onFocus(_ref) {\n        let {\n          currentTarget\n        } = _ref;\n        syncCurrentTarget(currentTarget);\n      },\n      onClick: _ref2 => {\n        let {\n          currentTarget\n        } = _ref2;\n        return currentTarget.focus({\n          preventScroll: true\n        });\n      },\n      // Safari\n      ...(focusItemOnHover && {\n        onMouseMove(_ref3) {\n          let {\n            currentTarget\n          } = _ref3;\n          syncCurrentTarget(currentTarget);\n        },\n        onPointerLeave(_ref4) {\n          let {\n            pointerType\n          } = _ref4;\n          if (!isPointerModalityRef.current || pointerType === 'touch') {\n            return;\n          }\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n          onNavigate(null);\n          if (!virtual) {\n            enqueueFocus(refs.floating.current, {\n              preventScroll: true\n            });\n          }\n        }\n      })\n    };\n    return props;\n  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    const disabledIndices = disabledIndicesRef.current;\n    function onKeyDown(event) {\n      isPointerModalityRef.current = false;\n      forceSyncFocus.current = true;\n\n      // If the floating element is animating out, ignore navigation. Otherwise,\n      // the `activeIndex` gets set to 0 despite not being open so the next time\n      // the user ArrowDowns, the first item won't be focused.\n      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n        return;\n      }\n      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n        stopEvent(event);\n        onOpenChange(false);\n        if (isHTMLElement(domReference)) {\n          domReference.focus();\n        }\n        return;\n      }\n      const currentIndex = indexRef.current;\n      const minIndex = getMinIndex(listRef, disabledIndices);\n      const maxIndex = getMaxIndex(listRef, disabledIndices);\n      if (event.key === 'Home') {\n        stopEvent(event);\n        indexRef.current = minIndex;\n        onNavigate(indexRef.current);\n      }\n      if (event.key === 'End') {\n        stopEvent(event);\n        indexRef.current = maxIndex;\n        onNavigate(indexRef.current);\n      }\n\n      // Grid navigation.\n      if (cols > 1) {\n        const prevIndex = indexRef.current;\n        if (event.key === ARROW_UP) {\n          stopEvent(event);\n          if (prevIndex === -1) {\n            indexRef.current = maxIndex;\n          } else {\n            indexRef.current = findNonDisabledIndex(listRef, {\n              startingIndex: prevIndex,\n              amount: cols,\n              decrement: true,\n              disabledIndices\n            });\n            if (loop && (prevIndex - cols < minIndex || indexRef.current < 0)) {\n              const col = prevIndex % cols;\n              const maxCol = maxIndex % cols;\n              const offset = maxIndex - (maxCol - col);\n              if (maxCol === col) {\n                indexRef.current = maxIndex;\n              } else {\n                indexRef.current = maxCol > col ? offset : offset - cols;\n              }\n            }\n          }\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            indexRef.current = prevIndex;\n          }\n          onNavigate(indexRef.current);\n        }\n        if (event.key === ARROW_DOWN) {\n          stopEvent(event);\n          if (prevIndex === -1) {\n            indexRef.current = minIndex;\n          } else {\n            indexRef.current = findNonDisabledIndex(listRef, {\n              startingIndex: prevIndex,\n              amount: cols,\n              disabledIndices\n            });\n            if (loop && prevIndex + cols > maxIndex) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex % cols - cols,\n                amount: cols,\n                disabledIndices\n              });\n            }\n          }\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            indexRef.current = prevIndex;\n          }\n          onNavigate(indexRef.current);\n        }\n\n        // Remains on the same row/column.\n        if (orientation === 'both') {\n          const prevRow = Math.floor(prevIndex / cols);\n          if (event.key === ARROW_RIGHT) {\n            stopEvent(event);\n            if (prevIndex % cols !== cols - 1) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex,\n                disabledIndices\n              });\n              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex - prevIndex % cols - 1,\n                  disabledIndices\n                });\n              }\n            } else if (loop) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex - prevIndex % cols - 1,\n                disabledIndices\n              });\n            }\n            if (isDifferentRow(indexRef.current, cols, prevRow)) {\n              indexRef.current = prevIndex;\n            }\n          }\n          if (event.key === ARROW_LEFT) {\n            stopEvent(event);\n            if (prevIndex % cols !== 0) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex,\n                disabledIndices,\n                decrement: true\n              });\n              if (loop && isDifferentRow(indexRef.current, cols, prevRow)) {\n                indexRef.current = findNonDisabledIndex(listRef, {\n                  startingIndex: prevIndex + (cols - prevIndex % cols),\n                  decrement: true,\n                  disabledIndices\n                });\n              }\n            } else if (loop) {\n              indexRef.current = findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex + (cols - prevIndex % cols),\n                decrement: true,\n                disabledIndices\n              });\n            }\n            if (isDifferentRow(indexRef.current, cols, prevRow)) {\n              indexRef.current = prevIndex;\n            }\n          }\n          const lastRow = Math.floor(maxIndex / cols) === prevRow;\n          if (isIndexOutOfBounds(listRef, indexRef.current)) {\n            if (loop && lastRow) {\n              indexRef.current = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(listRef, {\n                startingIndex: prevIndex - prevIndex % cols - 1,\n                disabledIndices\n              });\n            } else {\n              indexRef.current = prevIndex;\n            }\n          }\n          onNavigate(indexRef.current);\n          return;\n        }\n      }\n      if (isMainOrientationKey(event.key, orientation)) {\n        stopEvent(event);\n\n        // Reset the index if no item is focused.\n        if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {\n          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n          onNavigate(indexRef.current);\n          return;\n        }\n        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n          if (loop) {\n            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            }));\n          }\n        } else {\n          if (loop) {\n            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            }));\n          }\n        }\n        if (isIndexOutOfBounds(listRef, indexRef.current)) {\n          onNavigate(null);\n        } else {\n          onNavigate(indexRef.current);\n        }\n      }\n    }\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && isVirtualClick(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && isVirtualPointerEvent(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n      'aria-activedescendant': activeId\n    };\n    return {\n      reference: {\n        ...ariaActiveDescendantProp,\n        onKeyDown(event) {\n          isPointerModalityRef.current = false;\n          const isArrowKey = event.key.indexOf('Arrow') === 0;\n          if (virtual && open) {\n            return onKeyDown(event);\n          }\n\n          // If a floating element should not open on arrow key down, avoid\n          // setting `activeIndex` while it's closed.\n          if (!open && !openOnArrowKeyDown && isArrowKey) {\n            return;\n          }\n          const isNavigationKey = isArrowKey || event.key === 'Enter' || event.key.trim() === '';\n          const isMainKey = isMainOrientationKey(event.key, orientation);\n          const isCrossKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n          if (isNavigationKey) {\n            keyRef.current = nested && isMainKey ? null : event.key;\n          }\n          if (nested) {\n            if (isCrossKey) {\n              stopEvent(event);\n              if (open) {\n                indexRef.current = getMinIndex(listRef, disabledIndices);\n                onNavigate(indexRef.current);\n              } else {\n                onOpenChange(true);\n              }\n            }\n            return;\n          }\n          if (isMainKey) {\n            if (selectedIndex != null) {\n              indexRef.current = selectedIndex;\n            }\n            stopEvent(event);\n            if (!open && openOnArrowKeyDown) {\n              onOpenChange(true);\n            } else {\n              onKeyDown(event);\n            }\n            if (open) {\n              onNavigate(indexRef.current);\n            }\n          }\n        },\n        onFocus() {\n          if (open) {\n            onNavigate(null);\n          }\n        },\n        onPointerDown: checkVirtualPointer,\n        onMouseDown: checkVirtualMouse,\n        onClick: checkVirtualMouse\n      },\n      floating: {\n        'aria-orientation': orientation === 'both' ? undefined : orientation,\n        ...ariaActiveDescendantProp,\n        onKeyDown,\n        onPointerMove() {\n          isPointerModalityRef.current = true;\n        }\n      },\n      item\n    };\n  }, [domReference, refs, activeId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item]);\n};\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/useMergeRefs\n */\nfunction useMergeRefs(refs) {\n  return React.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return value => {\n      refs.forEach(ref => {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref != null) {\n          ref.current = value;\n        }\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nconst useRole = function (context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    floatingId\n  } = context;\n  const {\n    enabled = true,\n    role = 'dialog'\n  } = props;\n  const referenceId = useId();\n  return React.useMemo(() => {\n    const floatingProps = {\n      id: floatingId,\n      role\n    };\n    if (!enabled) {\n      return {};\n    }\n    if (role === 'tooltip') {\n      return {\n        reference: {\n          'aria-describedby': open ? floatingId : undefined\n        },\n        floating: floatingProps\n      };\n    }\n    return {\n      reference: {\n        'aria-expanded': open ? 'true' : 'false',\n        'aria-haspopup': role === 'alertdialog' ? 'dialog' : role,\n        'aria-controls': open ? floatingId : undefined,\n        ...(role === 'listbox' && {\n          role: 'combobox'\n        }),\n        ...(role === 'menu' && {\n          id: referenceId\n        })\n      },\n      floating: {\n        ...floatingProps,\n        ...(role === 'menu' && {\n          'aria-labelledby': referenceId\n        })\n      }\n    };\n  }, [enabled, role, open, floatingId, referenceId]);\n};\n\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n  return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n  const [isMounted, setIsMounted] = React.useState(open);\n  if (open && !isMounted) {\n    setIsMounted(true);\n  }\n  React.useEffect(() => {\n    if (!open) {\n      const timeout = setTimeout(() => setIsMounted(false), durationMs);\n      return () => clearTimeout(timeout);\n    }\n  }, [open, durationMs]);\n  return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */\nfunction useTransitionStatus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    duration = 250\n  } = props;\n  const isNumberDuration = typeof duration === 'number';\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [initiated, setInitiated] = React.useState(false);\n  const [status, setStatus] = React.useState('unmounted');\n  const isMounted = useDelayUnmount(open, closeDuration);\n\n  // `initiated` check prevents this `setState` call from breaking\n  // <FloatingPortal />. This call is necessary to ensure subsequent opens\n  // after the initial one allows the correct side animation to play when the\n  // placement has changed.\n  index(() => {\n    if (initiated && !isMounted) {\n      setStatus('unmounted');\n    }\n  }, [initiated, isMounted]);\n  index(() => {\n    if (!floating) return;\n    if (open) {\n      setStatus('initial');\n      const frame = requestAnimationFrame(() => {\n        setStatus('open');\n      });\n      return () => {\n        cancelAnimationFrame(frame);\n      };\n    } else {\n      setInitiated(true);\n      setStatus('close');\n    }\n  }, [open, floating]);\n  return {\n    isMounted,\n    status\n  };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */\nfunction useTransitionStyles(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    initial: unstable_initial = {\n      opacity: 0\n    },\n    open: unstable_open,\n    close: unstable_close,\n    common: unstable_common,\n    duration = 250\n  } = props;\n  const placement = context.placement;\n  const side = placement.split('-')[0];\n  const fnArgs = React.useMemo(() => ({\n    side,\n    placement\n  }), [side, placement]);\n  const isNumberDuration = typeof duration === 'number';\n  const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [styles, setStyles] = React.useState(() => ({\n    ...execWithArgsOrReturn(unstable_common, fnArgs),\n    ...execWithArgsOrReturn(unstable_initial, fnArgs)\n  }));\n  const {\n    isMounted,\n    status\n  } = useTransitionStatus(context, {\n    duration\n  });\n  const initialRef = useLatestRef(unstable_initial);\n  const openRef = useLatestRef(unstable_open);\n  const closeRef = useLatestRef(unstable_close);\n  const commonRef = useLatestRef(unstable_common);\n  index(() => {\n    const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n    const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n    const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n    const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {\n      acc[key] = '';\n      return acc;\n    }, {});\n    if (status === 'initial') {\n      setStyles(styles => ({\n        transitionProperty: styles.transitionProperty,\n        ...commonStyles,\n        ...initialStyles\n      }));\n    }\n    if (status === 'open') {\n      setStyles({\n        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: openDuration + \"ms\",\n        ...commonStyles,\n        ...openStyles\n      });\n    }\n    if (status === 'close') {\n      const styles = closeStyles || initialStyles;\n      setStyles({\n        transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: closeDuration + \"ms\",\n        ...commonStyles,\n        ...styles\n      });\n    }\n  }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);\n  return {\n    isMounted,\n    styles\n  };\n}\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nconst useTypeahead = (context, props) => {\n  var _ref;\n  const {\n    open,\n    dataRef\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onMatch: unstable_onMatch,\n    onTypingChange: unstable_onTypingChange,\n    enabled = true,\n    findMatch = null,\n    resetMs = 750,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = props;\n  const timeoutIdRef = React.useRef();\n  const stringRef = React.useRef('');\n  const prevIndexRef = React.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n  const matchIndexRef = React.useRef(null);\n  const onMatch = useEvent(unstable_onMatch);\n  const onTypingChange = useEvent(unstable_onTypingChange);\n  const findMatchRef = useLatestRef(findMatch);\n  const ignoreKeysRef = useLatestRef(ignoreKeys);\n  index(() => {\n    if (open) {\n      clearTimeout(timeoutIdRef.current);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  index(() => {\n    // Sync arrow key navigation but not typeahead navigation.\n    if (open && stringRef.current === '') {\n      var _ref2;\n      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setTypingChange(value) {\n      if (value) {\n        if (!dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      } else {\n        if (dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      }\n    }\n    function getMatchingIndex(list, orderedList, string) {\n      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n      return str ? list.indexOf(str) : -1;\n    }\n    function onKeyDown(event) {\n      const listContent = listRef.current;\n      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n        if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n          setTypingChange(false);\n        } else if (event.key === ' ') {\n          stopEvent(event);\n        }\n      }\n      if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n      // Character key.\n      event.key.length !== 1 ||\n      // Modifier key.\n      event.ctrlKey || event.metaKey || event.altKey) {\n        return;\n      }\n      if (open && event.key !== ' ') {\n        stopEvent(event);\n        setTypingChange(true);\n      }\n\n      // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n      // allow it in this case, too.\n      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n        var _text$, _text$2;\n        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n      });\n\n      // Allows the user to cycle through items that start with the same letter\n      // in rapid succession.\n      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n      }\n      stringRef.current += event.key;\n      clearTimeout(timeoutIdRef.current);\n      timeoutIdRef.current = setTimeout(() => {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n        setTypingChange(false);\n      }, resetMs);\n      const prevIndex = prevIndexRef.current;\n      const index = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);\n      if (index !== -1) {\n        onMatch(index);\n        matchIndexRef.current = index;\n      } else {\n        stringRef.current = '';\n        setTypingChange(false);\n      }\n    }\n    return {\n      reference: {\n        onKeyDown\n      },\n      floating: {\n        onKeyDown\n      }\n    };\n  }, [enabled, open, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch, onTypingChange]);\n};\n\nfunction getArgsWithCustomFloatingHeight(state, height) {\n  return {\n    ...state,\n    rects: {\n      ...state.rects,\n      floating: {\n        ...state.rects.floating,\n        height\n      }\n    }\n  };\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */\nconst inner = props => ({\n  name: 'inner',\n  options: props,\n  async fn(state) {\n    const {\n      listRef,\n      overflowRef,\n      onFallbackChange,\n      offset: innerOffset = 0,\n      index = 0,\n      minItemsVisible = 4,\n      referenceOverflowThreshold = 0,\n      scrollRef,\n      ...detectOverflowOptions\n    } = props;\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = state;\n    const item = listRef.current[index];\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!state.placement.startsWith('bottom')) {\n        console.warn(['Floating UI: `placement` side must be \"bottom\" when using the', '`inner` middleware.'].join(' '));\n      }\n    }\n    if (!item) {\n      return {};\n    }\n    const nextArgs = {\n      ...state,\n      ...(await offset(-item.offsetTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state))\n    };\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n    const refOverflow = await detectOverflow(nextArgs, {\n      ...detectOverflowOptions,\n      elementContext: 'reference'\n    });\n    const diffY = Math.max(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n    el.style.maxHeight = maxHeight + \"px\";\n    el.scrollTop = diffY;\n\n    // There is not enough space, fallback to standard anchored positioning\n    if (onFallbackChange) {\n      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n        flushSync(() => onFallbackChange(true));\n      } else {\n        flushSync(() => onFallbackChange(false));\n      }\n    }\n    if (overflowRef) {\n      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({\n        ...nextArgs,\n        y: nextY\n      }, el.offsetHeight), detectOverflowOptions);\n    }\n    return {\n      y: nextY\n    };\n  }\n});\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */\nconst useInnerOffset = (_ref, _ref2) => {\n  let {\n    open,\n    elements\n  } = _ref;\n  let {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = _ref2;\n  const onChange = useEvent(unstable_onChange);\n  const controlledScrollingRef = React.useRef(false);\n  const prevScrollTopRef = React.useRef(null);\n  const initialOverflowRef = React.useRef(null);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? 'max' : 'min';\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        flushSync(() => {\n          onChange(d => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test(getUserAgent())) {\n        // Needed to propagate scrolling during momentum scrolling phase once\n        // it gets limited by the boundary. UX improvement, not critical.\n        el.scrollTop += dY;\n      }\n    }\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n    if (open && el) {\n      el.addEventListener('wheel', onWheel);\n\n      // Wait for the position to be ready.\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = {\n            ...overflowRef.current\n          };\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      floating: {\n        onKeyDown() {\n          controlledScrollingRef.current = true;\n        },\n        onWheel() {\n          controlledScrollingRef.current = false;\n        },\n        onPointerMove() {\n          controlledScrollingRef.current = false;\n        },\n        onScroll() {\n          const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n          if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n            return;\n          }\n          if (prevScrollTopRef.current !== null) {\n            const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n              flushSync(() => onChange(d => d + scrollDiff));\n            }\n          }\n\n          // [Firefox] Wait for the height change to have been applied.\n          requestAnimationFrame(() => {\n            prevScrollTopRef.current = el.scrollTop;\n          });\n        }\n      }\n    };\n  }, [enabled, overflowRef, elements.floating, scrollRef, onChange]);\n};\n\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n  return isInside;\n}\nfunction isInside(point, rect) {\n  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\nfunction safePolygon(_temp) {\n  let {\n    restMs = 0,\n    buffer = 0.5,\n    blockPointerEvents = false\n  } = _temp === void 0 ? {} : _temp;\n  let timeoutId;\n  let isInsideRect = false;\n  let hasLanded = false;\n  const fn = _ref => {\n    let {\n      x,\n      y,\n      placement,\n      elements,\n      onClose,\n      nodeId,\n      tree\n    } = _ref;\n    return function onMouseMove(event) {\n      function close() {\n        clearTimeout(timeoutId);\n        onClose();\n      }\n      clearTimeout(timeoutId);\n      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n        return;\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const clientPoint = [clientX, clientY];\n      const target = getTarget(event);\n      const isLeave = event.type === 'mouseleave';\n      const isOverFloatingEl = contains(elements.floating, target);\n      const isOverReferenceEl = contains(elements.domReference, target);\n      const refRect = elements.domReference.getBoundingClientRect();\n      const rect = elements.floating.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n      const isOverReferenceRect = isInside(clientPoint, refRect);\n      if (isOverFloatingEl) {\n        hasLanded = true;\n        if (!isLeave) {\n          return;\n        }\n      }\n      if (isOverReferenceEl) {\n        hasLanded = false;\n      }\n      if (isOverReferenceEl && !isLeave) {\n        hasLanded = true;\n        return;\n      }\n\n      // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n      if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n        return;\n      }\n\n      // If any nested child is open, abort.\n      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n        let {\n          context\n        } = _ref2;\n        return context == null ? void 0 : context.open;\n      })) {\n        return;\n      }\n\n      // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      }\n\n      // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n      let rectPoly = [];\n      switch (side) {\n        case 'top':\n          rectPoly = [[rect.left, refRect.top + 1], [rect.left, rect.bottom - 1], [rect.right, rect.bottom - 1], [rect.right, refRect.top + 1]];\n          isInsideRect = clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= refRect.top + 1;\n          break;\n        case 'bottom':\n          rectPoly = [[rect.left, rect.top + 1], [rect.left, refRect.bottom - 1], [rect.right, refRect.bottom - 1], [rect.right, rect.top + 1]];\n          isInsideRect = clientX >= rect.left && clientX <= rect.right && clientY >= refRect.bottom - 1 && clientY <= rect.bottom;\n          break;\n        case 'left':\n          rectPoly = [[rect.right - 1, rect.bottom], [rect.right - 1, rect.top], [refRect.left + 1, rect.top], [refRect.left + 1, rect.bottom]];\n          isInsideRect = clientX >= rect.left && clientX <= refRect.left + 1 && clientY >= rect.top && clientY <= rect.bottom;\n          break;\n        case 'right':\n          rectPoly = [[refRect.right - 1, rect.bottom], [refRect.right - 1, rect.top], [rect.left + 1, rect.top], [rect.left + 1, rect.bottom]];\n          isInsideRect = clientX >= refRect.right - 1 && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n          break;\n      }\n      function getPolygon(_ref3) {\n        let [x, y] = _ref3;\n        const isFloatingWider = rect.width > refRect.width;\n        const isFloatingTaller = rect.height > refRect.height;\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n      const poly = isInsideRect ? rectPoly : getPolygon([x, y]);\n      if (isInsideRect) {\n        return;\n      } else if (hasLanded && !isOverReferenceRect) {\n        return close();\n      }\n      if (!isPointInPolygon([clientX, clientY], poly)) {\n        close();\n      } else if (restMs && !hasLanded) {\n        timeoutId = setTimeout(close, restMs);\n      }\n    };\n  };\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}\n\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/react\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open = false,\n    onOpenChange: unstable_onOpenChange,\n    nodeId\n  } = options;\n  const position = useFloating$1(options);\n  const tree = useFloatingTree();\n  const domReferenceRef = React.useRef(null);\n  const dataRef = React.useRef({});\n  const events = React.useState(() => createPubSub())[0];\n  const floatingId = useId();\n  const [domReference, setDomReference] = React.useState(null);\n  const setPositionReference = React.useCallback(node => {\n    const positionReference = isElement(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      contextElement: node\n    } : node;\n    position.refs.setReference(positionReference);\n  }, [position.refs]);\n  const setReference = React.useCallback(node => {\n    if (isElement(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n\n    // Backwards-compatibility for passing a virtual element to `reference`\n    // after it has set the DOM reference.\n    if (isElement(position.refs.reference.current) || position.refs.reference.current === null ||\n    // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !isElement(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = React.useMemo(() => ({\n    ...position.refs,\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = React.useMemo(() => ({\n    ...position.elements,\n    domReference: domReference\n  }), [position.elements, domReference]);\n  const onOpenChange = useEvent(unstable_onOpenChange);\n  const context = React.useMemo(() => ({\n    ...position,\n    refs,\n    elements,\n    dataRef,\n    nodeId,\n    floatingId,\n    events,\n    open,\n    onOpenChange\n  }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);\n  index(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return React.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    elements,\n    reference: setReference,\n    positionReference: setPositionReference\n  }), [position, refs, elements, context, setReference, setPositionReference]);\n}\n\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  return {\n    ...(elementKey === 'floating' && {\n      tabIndex: -1\n    }),\n    ...userProps,\n    ...propsList.map(value => value ? value[elementKey] : null).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n      Object.entries(props).forEach(_ref => {\n        let [key, value] = _ref;\n        if (key.indexOf('on') === 0) {\n          if (!map.has(key)) {\n            map.set(key, []);\n          }\n          if (typeof value === 'function') {\n            var _map$get;\n            (_map$get = map.get(key)) == null ? void 0 : _map$get.push(value);\n            acc[key] = function () {\n              var _map$get2;\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map(fn => fn(...args)).find(val => val !== undefined);\n            };\n          }\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\nconst useInteractions = function (propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n  // The dependencies are a dynamic array, so we can't use the linter's\n  // suggestion to add it to the deps array.\n  const deps = propsList;\n  const getReferenceProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getFloatingProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  deps);\n  const getItemProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n  // Granularly check for `item` changes, because the `getItemProps` getter\n  // should be as referentially stable as possible since it may be passed as\n  // a prop to many components. All `item` key values must therefore be\n  // memoized.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  propsList.map(key => key == null ? void 0 : key.item));\n  return React.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n};\n\nexport { FloatingArrow, FloatingDelayGroup, FloatingFocusManager, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, inner, safePolygon, useClick, useClientPoint, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInnerOffset, useInteractions, useListNavigation, useMergeRefs, useRole, useTransitionStatus, useTransitionStyles, useTypeahead };\n","import React, { cloneElement, useRef, useState, useLayoutEffect } from 'react';\nimport { createElementAs, usePlateEditorState, isCollapsed, toDOMRange } from '@udecode/plate-common';\nimport { useReadOnly, useSelected } from 'slate-react';\nimport { useFloating, offset, flip, shift, autoUpdate, useInteractions } from '@floating-ui/react';\nexport { FloatingDelayGroup, FloatingFocusManager, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, safePolygon, shift, size, useClick, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInteractions, useListNavigation, useRole, useTypeahead } from '@floating-ui/react';\nimport * as reactDropdownMenu from '@radix-ui/react-dropdown-menu';\nexport { reactDropdownMenu as DropdownMenu };\n\nconst getDefaultBoundingClientRect = () => ({\n  width: 0,\n  height: 0,\n  x: 0,\n  y: 0,\n  top: -9999,\n  left: -9999,\n  right: 9999,\n  bottom: 9999\n});\nconst createVirtualElement = () => ({\n  getBoundingClientRect: getDefaultBoundingClientRect\n});\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\n * Popover displayed over children, rendering `content`\n */\nconst Popover = ({\n  floatingOptions,\n  children,\n  content,\n  ...props\n}) => {\n  const {\n    x,\n    y,\n    refs,\n    strategy\n  } = useFloating({\n    middleware: [offset(12), flip({\n      padding: 96\n    }), shift()],\n    whileElementsMounted: autoUpdate,\n    ...floatingOptions\n  });\n  const {\n    getReferenceProps\n  } = useInteractions();\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/cloneElement(children, getReferenceProps({\n    ref: refs.setReference,\n    ...children.props\n  })), (floatingOptions === null || floatingOptions === void 0 ? void 0 : floatingOptions.open) && createElementAs('div', {\n    ref: refs.setFloating,\n    style: {\n      position: strategy,\n      top: y !== null && y !== void 0 ? y : 0,\n      left: x !== null && x !== void 0 ? x : 0,\n      zIndex: 1\n    },\n    contentEditable: false,\n    children: content,\n    ...props\n  }));\n};\n\n/**\n * Popover displayed over an element if:\n * - not disabled\n * - not read-only\n * - element selected\n */\n\nconst ElementPopover = ({\n  floatingOptions = {},\n  ...props\n}) => {\n  const {\n    disabled\n  } = props;\n  const readOnly = useReadOnly();\n  const selected = useSelected();\n  const editor = usePlateEditorState();\n  return /*#__PURE__*/React.createElement(Popover, _extends({\n    floatingOptions: {\n      open: !disabled && !readOnly && selected && isCollapsed(editor.selection),\n      ...floatingOptions\n    }\n  }, props));\n};\n\n/**\n * Get bounding client rect by slate range\n */\n\nconst getRangeBoundingClientRect = (editor, at) => {\n  if (!at) return getDefaultBoundingClientRect();\n  const domRange = toDOMRange(editor, at);\n  if (!domRange) return getDefaultBoundingClientRect();\n  return domRange.getBoundingClientRect();\n};\n\n/**\n * Get bounding client rect of the window selection\n */\n\nconst getSelectionBoundingClientRect = () => {\n  const domSelection = window.getSelection();\n\n  if (!domSelection || domSelection.rangeCount < 1) {\n    return getDefaultBoundingClientRect();\n  }\n\n  const domRange = domSelection.getRangeAt(0);\n  return domRange.getBoundingClientRect();\n};\n\n/**\n * `useFloating` with a controlled virtual element. Used to follow cursor position.\n *\n * Default options:\n * - `whileElementsMounted: autoUpdate`\n *\n * Additional options:\n * - `getBoundingClientRect` to get the bounding client rect.\n * - `hidden` to hide the floating element\n *\n * Additional returns:\n * - `style` to apply to the floating element\n * - `virtualElementRef`\n *\n * @see useFloating\n * @see https://floating-ui.com/docs/react-dom#virtual-element\n */\nconst useVirtualFloating = ({\n  getBoundingClientRect = getSelectionBoundingClientRect,\n  ...floatingOptions\n}) => {\n  const virtualElementRef = useRef(createVirtualElement());\n  const [visible, setVisible] = useState(true);\n  const floatingResult = useFloating({\n    // update on scroll and resize\n    whileElementsMounted: autoUpdate,\n    ...floatingOptions\n  });\n  const {\n    refs,\n    middlewareData,\n    strategy,\n    x,\n    y,\n    update\n  } = floatingResult;\n  useLayoutEffect(() => {\n    virtualElementRef.current.getBoundingClientRect = getBoundingClientRect;\n  }, [getBoundingClientRect, update]);\n  useLayoutEffect(() => {\n    refs.setReference(virtualElementRef.current);\n  }, [refs]);\n  useLayoutEffect(() => {\n    if (!(middlewareData !== null && middlewareData !== void 0 && middlewareData.hide)) return;\n    const {\n      referenceHidden\n    } = middlewareData.hide;\n    setVisible(!referenceHidden);\n  }, [middlewareData.hide]);\n  return { ...floatingResult,\n    virtualElementRef,\n    style: {\n      position: strategy,\n      top: y !== null && y !== void 0 ? y : 0,\n      left: x !== null && x !== void 0 ? x : 0,\n      display: floatingOptions.open === false ? 'none' : undefined,\n      visibility: !visible ? 'hidden' : undefined\n    }\n  };\n};\n\nexport { ElementPopover, Popover, createVirtualElement, getDefaultBoundingClientRect, getRangeBoundingClientRect, getSelectionBoundingClientRect, useVirtualFloating };\n//# sourceMappingURL=index.es.js.map\n","import { useEditorRef, useHotkeys } from '@udecode/plate-common';\nimport { submitFloatingLink } from '../../transforms/submitFloatingLink';\nimport { useFloatingLinkSelectors } from './floatingLinkStore';\n\nexport const useFloatingLinkEnter = () => {\n  const editor = useEditorRef();\n\n  const open = useFloatingLinkSelectors().isOpen(editor.id);\n\n  useHotkeys(\n    '*',\n    (e) => {\n      if (e.key !== 'Enter') return;\n\n      if (submitFloatingLink(editor)) {\n        e.preventDefault();\n      }\n    },\n    {\n      enabled: open,\n      enableOnFormTags: ['INPUT'],\n    },\n    []\n  );\n};\n","import { focusEditor, useEditorRef, useHotkeys } from '@udecode/plate-common';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n  useFloatingLinkSelectors,\n} from './floatingLinkStore';\n\nexport const useFloatingLinkEscape = () => {\n  const editor = useEditorRef();\n\n  const open = useFloatingLinkSelectors().isOpen(editor.id);\n\n  useHotkeys(\n    'escape',\n    (e) => {\n      if (!floatingLinkSelectors.mode()) return;\n\n      e.preventDefault();\n\n      if (\n        floatingLinkSelectors.mode() === 'edit' &&\n        floatingLinkSelectors.isEditing()\n      ) {\n        floatingLinkActions.show('edit', editor.id);\n        focusEditor(editor, editor.selection!);\n        return;\n      }\n\n      if (floatingLinkSelectors.mode() === 'insert') {\n        focusEditor(editor, editor.selection!);\n      }\n\n      floatingLinkActions.hide();\n    },\n    {\n      enabled: open,\n      enableOnFormTags: ['INPUT'],\n      enableOnContentEditable: true,\n    },\n    []\n  );\n};\n","import {\n  flip,\n  offset,\n  useVirtualFloating,\n  UseVirtualFloatingOptions,\n} from '@udecode/plate-floating';\nimport { floatingLinkActions } from './floatingLinkStore';\n\nexport const useVirtualFloatingLink = ({\n  editorId,\n  ...floatingOptions\n}: { editorId: string } & UseVirtualFloatingOptions) => {\n  return useVirtualFloating({\n    placement: 'bottom-start',\n    onOpenChange: (open) =>\n      floatingLinkActions.openEditorId(open ? editorId : null),\n    middleware: [\n      offset(12),\n      flip({\n        padding: 96,\n      }),\n    ],\n    ...floatingOptions,\n  });\n};\n","import { useCallback, useEffect } from 'react';\nimport {\n  getAboveNode,\n  getEndPoint,\n  getPluginOptions,\n  getPluginType,\n  getStartPoint,\n  HTMLPropsAs,\n  someNode,\n  useComposedRef,\n  useEditorRef,\n  useHotkeys,\n  usePlateSelectors,\n} from '@udecode/plate-common';\nimport {\n  getDefaultBoundingClientRect,\n  getRangeBoundingClientRect,\n} from '@udecode/plate-floating';\nimport { ELEMENT_LINK, LinkPlugin } from '../../createLinkPlugin';\nimport { triggerFloatingLinkEdit } from '../../utils/triggerFloatingLinkEdit';\nimport { FloatingLinkProps } from './FloatingLink';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n  useFloatingLinkSelectors,\n} from './floatingLinkStore';\nimport { useFloatingLinkEnter } from './useFloatingLinkEnter';\nimport { useFloatingLinkEscape } from './useFloatingLinkEscape';\nimport { useVirtualFloatingLink } from './useVirtualFloatingLink';\n\nexport const useFloatingLinkEdit = ({\n  floatingOptions,\n  ...props\n}: FloatingLinkProps): HTMLPropsAs<'div'> => {\n  const editor = useEditorRef();\n  const keyEditor = usePlateSelectors().keyEditor();\n  const mode = useFloatingLinkSelectors().mode();\n  const open = useFloatingLinkSelectors().isOpen(editor.id);\n\n  const { triggerFloatingLinkHotkeys } = getPluginOptions<LinkPlugin>(\n    editor,\n    ELEMENT_LINK\n  );\n\n  const getBoundingClientRect = useCallback(() => {\n    const entry = getAboveNode(editor, {\n      match: { type: getPluginType(editor, ELEMENT_LINK) },\n    });\n\n    if (entry) {\n      const [, path] = entry;\n      return getRangeBoundingClientRect(editor, {\n        anchor: getStartPoint(editor, path),\n        focus: getEndPoint(editor, path),\n      });\n    }\n\n    return getDefaultBoundingClientRect();\n  }, [editor]);\n\n  const isOpen = open && mode === 'edit';\n\n  const { update, style, refs } = useVirtualFloatingLink({\n    editorId: editor.id,\n    open: isOpen,\n    getBoundingClientRect,\n    ...floatingOptions,\n  });\n\n  useEffect(() => {\n    if (\n      editor.selection &&\n      someNode(editor, {\n        match: { type: getPluginType(editor, ELEMENT_LINK) },\n      })\n    ) {\n      floatingLinkActions.show('edit', editor.id);\n      update();\n      return;\n    }\n\n    if (floatingLinkSelectors.mode() === 'edit') {\n      floatingLinkActions.hide();\n    }\n  }, [editor, keyEditor, update]);\n\n  useHotkeys(\n    triggerFloatingLinkHotkeys!,\n    (e) => {\n      if (\n        floatingLinkSelectors.mode() === 'edit' &&\n        triggerFloatingLinkEdit(editor)\n      ) {\n        e.preventDefault();\n      }\n    },\n    {\n      enableOnContentEditable: true,\n    },\n    []\n  );\n\n  useFloatingLinkEnter();\n\n  useFloatingLinkEscape();\n\n  return {\n    style: {\n      ...style,\n      zIndex: 1,\n    },\n    ...props,\n    ref: useComposedRef<HTMLElement | null>(props.ref, refs.setFloating),\n  };\n};\n","import {\n  getEditorString,\n  getPluginType,\n  isRangeAcrossBlocks,\n  PlateEditor,\n  someNode,\n  Value,\n} from '@udecode/plate-common';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n} from '../components/FloatingLink/floatingLinkStore';\nimport { ELEMENT_LINK } from '../createLinkPlugin';\n\n/**\n * Trigger floating link.\n *\n * Do not trigger when:\n * - selection is across blocks\n * - selection has more than one leaf node\n * - lowest selection is not text\n * - selection has a link node\n */\nexport const triggerFloatingLinkInsert = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    focused,\n  }: {\n    focused?: boolean;\n  } = {}\n) => {\n  if (floatingLinkSelectors.mode()) return;\n\n  if (!focused) return;\n\n  if (isRangeAcrossBlocks(editor, { at: editor.selection })) return;\n\n  const hasLink = someNode(editor, {\n    match: { type: getPluginType(editor, ELEMENT_LINK) },\n  });\n  if (hasLink) return;\n\n  floatingLinkActions.text(getEditorString(editor, editor.selection));\n  floatingLinkActions.show('insert', editor.id);\n\n  return true;\n};\n","import { useEffect } from 'react';\nimport {\n  focusEditor,\n  getPluginOptions,\n  HTMLPropsAs,\n  useComposedRef,\n  useEditorRef,\n  useHotkeys,\n  useOnClickOutside,\n} from '@udecode/plate-common';\nimport { getSelectionBoundingClientRect } from '@udecode/plate-floating';\nimport { useFocused } from 'slate-react';\nimport { ELEMENT_LINK, LinkPlugin } from '../../createLinkPlugin';\nimport { triggerFloatingLinkInsert } from '../../utils/triggerFloatingLinkInsert';\nimport { FloatingLinkProps } from './FloatingLink';\nimport {\n  floatingLinkActions,\n  floatingLinkSelectors,\n  useFloatingLinkSelectors,\n} from './floatingLinkStore';\nimport { useFloatingLinkEscape } from './useFloatingLinkEscape';\nimport { useVirtualFloatingLink } from './useVirtualFloatingLink';\n\nexport const useFloatingLinkInsert = ({\n  floatingOptions,\n  ...props\n}: FloatingLinkProps): HTMLPropsAs<'div'> => {\n  const editor = useEditorRef();\n  const focused = useFocused();\n  const mode = useFloatingLinkSelectors().mode();\n  const open = useFloatingLinkSelectors().isOpen(editor.id);\n\n  const { triggerFloatingLinkHotkeys } = getPluginOptions<LinkPlugin>(\n    editor,\n    ELEMENT_LINK\n  );\n\n  useHotkeys(\n    triggerFloatingLinkHotkeys!,\n    (e) => {\n      if (triggerFloatingLinkInsert(editor, { focused })) {\n        e.preventDefault();\n      }\n    },\n    {\n      enableOnContentEditable: true,\n    },\n    [focused]\n  );\n\n  const ref = useOnClickOutside(\n    () => {\n      if (floatingLinkSelectors.mode() === 'insert') {\n        floatingLinkActions.hide();\n        focusEditor(editor, editor.selection!);\n      }\n    },\n    {\n      disabled: !open,\n    }\n  );\n\n  const { update, style, refs } = useVirtualFloatingLink({\n    editorId: editor.id,\n    open: open && mode === 'insert',\n    getBoundingClientRect: getSelectionBoundingClientRect,\n    whileElementsMounted: () => {},\n    ...floatingOptions,\n  });\n\n  // wait for update before focusing input\n  useEffect(() => {\n    if (open) {\n      update();\n      floatingLinkActions.updated(true);\n    } else {\n      floatingLinkActions.updated(false);\n    }\n  }, [open, update]);\n\n  useFloatingLinkEscape();\n\n  return {\n    style: {\n      ...style,\n      zIndex: 1,\n    },\n    ...props,\n    ref: useComposedRef<HTMLElement | null>(props.ref, refs.setFloating, ref),\n  };\n};\n","import {\n  createComponentAs,\n  createElementAs,\n  HTMLPropsAs,\n} from '@udecode/plate-common';\nimport { UseVirtualFloatingOptions } from '@udecode/plate-floating';\nimport { FloatingLinkEditButton } from './FloatingLinkEditButton';\nimport { FloatingLinkNewTabInput } from './FloatingLinkNewTabInput';\nimport { FloatingLinkTextInput } from './FloatingLinkTextInput';\nimport { FloatingLinkUrlInput } from './FloatingLinkUrlInput';\nimport { OpenLinkButton } from './OpenLinkButton';\nimport { UnlinkButton } from './UnlinkButton';\nimport { useFloatingLinkEdit } from './useFloatingLinkEdit';\nimport { useFloatingLinkInsert } from './useFloatingLinkInsert';\n\nexport type FloatingLinkProps = HTMLPropsAs<'div'> & {\n  floatingOptions?: UseVirtualFloatingOptions;\n};\n\nexport const FloatingLinkEditRoot = createComponentAs<FloatingLinkProps>(\n  (props) => {\n    const htmlProps = useFloatingLinkEdit(props);\n\n    if (htmlProps.style?.display === 'none') {\n      return null;\n    }\n\n    return createElementAs('div', htmlProps);\n  }\n);\n\nexport const FloatingLinkInsertRoot = createComponentAs<FloatingLinkProps>(\n  (props) => {\n    const htmlProps = useFloatingLinkInsert(props);\n\n    if (htmlProps.style?.display === 'none') {\n      return null;\n    }\n\n    return createElementAs('div', htmlProps);\n  }\n);\n\nexport const FloatingLink = {\n  EditRoot: FloatingLinkEditRoot,\n  InsertRoot: FloatingLinkInsertRoot,\n  UrlInput: FloatingLinkUrlInput,\n  TextInput: FloatingLinkTextInput,\n  NewTabInput: FloatingLinkNewTabInput,\n  EditButton: FloatingLinkEditButton,\n  UnlinkButton,\n  OpenLinkButton,\n};\n","import { PlateEditor, Value } from '@udecode/plate-common';\nimport { floatingLinkSelectors } from '../components/index';\nimport { triggerFloatingLinkEdit } from './triggerFloatingLinkEdit';\nimport { triggerFloatingLinkInsert } from './triggerFloatingLinkInsert';\n\nexport const triggerFloatingLink = <V extends Value>(\n  editor: PlateEditor<V>,\n  {\n    focused,\n  }: {\n    focused?: boolean;\n  } = {}\n) => {\n  if (floatingLinkSelectors.mode() === 'edit') {\n    triggerFloatingLinkEdit(editor);\n    return;\n  }\n\n  triggerFloatingLinkInsert(editor, {\n    focused,\n  });\n};\n","import {\n  getPluginOptions,\n  PlateEditor,\n  sanitizeUrl,\n  Value,\n} from '@udecode/plate-common';\nimport { ELEMENT_LINK, LinkPlugin } from '../createLinkPlugin';\n\nexport const validateUrl = <V extends Value>(\n  editor: PlateEditor<V>,\n  url: string\n): boolean => {\n  const {\n    allowedSchemes,\n    isUrl,\n    dangerouslySkipSanitization,\n  } = getPluginOptions<LinkPlugin, V>(editor, ELEMENT_LINK);\n\n  if (isUrl && !isUrl(url)) return false;\n\n  if (\n    !dangerouslySkipSanitization &&\n    !sanitizeUrl(url, {\n      allowedSchemes,\n      permitInvalid: true,\n    })\n  )\n    return false;\n\n  return true;\n};\n","import {\n  collapseSelection,\n  getAboveNode,\n  getEditorString,\n  getNextNodeStartPoint,\n  getPluginType,\n  getPreviousNodeEndPoint,\n  getRangeBefore,\n  getRangeFromBlockStart,\n  insertNodes,\n  isCollapsed,\n  isEndPoint,\n  isStartPoint,\n  mockPlugin,\n  PlateEditor,\n  select,\n  someNode,\n  Value,\n  withoutNormalizing,\n  WithPlatePlugin,\n} from '@udecode/plate-common';\nimport { withRemoveEmptyNodes } from '@udecode/plate-normalizers';\nimport { Path, Point, Range } from 'slate';\nimport { upsertLink } from './transforms/index';\nimport { ELEMENT_LINK, LinkPlugin } from './createLinkPlugin';\n\n/**\n * Insert space after a url to wrap a link.\n * Lookup from the block start to the cursor to check if there is an url.\n * If not found, lookup before the cursor for a space character to check the url.\n *\n * On insert data:\n * Paste a string inside a link element will edit its children text but not its url.\n *\n */\n\nexport const withLink = <\n  V extends Value = Value,\n  E extends PlateEditor<V> = PlateEditor<V>\n>(\n  editor: E,\n  {\n    type,\n    options: { isUrl, getUrlHref, rangeBeforeOptions, keepSelectedTextOnPaste },\n  }: WithPlatePlugin<LinkPlugin, V, E>\n) => {\n  const { insertData, insertText, apply, normalizeNode, insertBreak } = editor;\n\n  const wrapLink = () => {\n    withoutNormalizing(editor, () => {\n      const selection = editor.selection!;\n\n      // get the range from first space before the cursor\n      let beforeWordRange = getRangeBefore(\n        editor,\n        selection,\n        rangeBeforeOptions\n      );\n\n      // if no space found before, get the range from block start\n      if (!beforeWordRange) {\n        beforeWordRange = getRangeFromBlockStart(editor);\n      }\n\n      // if no word found before the cursor, exit\n      if (!beforeWordRange) return;\n\n      const hasLink = someNode(editor, {\n        at: beforeWordRange,\n        match: { type: getPluginType(editor, ELEMENT_LINK) },\n      });\n\n      // if word before the cursor has a link, exit\n      if (hasLink) return;\n\n      let beforeWordText = getEditorString(editor, beforeWordRange);\n      beforeWordText = getUrlHref?.(beforeWordText) ?? beforeWordText;\n\n      // if word before is not an url, exit\n      if (!isUrl!(beforeWordText)) return;\n\n      // select the word to wrap link\n      select(editor, beforeWordRange);\n\n      // wrap link\n      upsertLink(editor, {\n        url: beforeWordText,\n      });\n\n      // collapse selection\n      collapseSelection(editor, { edge: 'end' });\n    });\n  };\n\n  editor.insertBreak = () => {\n    if (!isCollapsed(editor.selection)) return insertBreak();\n    wrapLink();\n    insertBreak();\n  };\n\n  editor.insertText = (text) => {\n    if (text === ' ' && isCollapsed(editor.selection)) {\n      wrapLink();\n    }\n\n    insertText(text);\n  };\n\n  editor.insertData = (data: DataTransfer) => {\n    const text = data.getData('text/plain');\n    const textHref = getUrlHref?.(text);\n\n    if (text) {\n      const value = textHref || text;\n      const inserted = upsertLink(editor, {\n        text: keepSelectedTextOnPaste ? undefined : value,\n        url: value,\n        insertTextInLink: true,\n      });\n      if (inserted) return;\n    }\n\n    insertData(data);\n  };\n\n  // TODO: plugin\n  editor.apply = (operation) => {\n    if (operation.type === 'set_selection') {\n      const range = operation.newProperties as Range | null;\n\n      if (range && range.focus && range.anchor && isCollapsed(range)) {\n        const entry = getAboveNode(editor, {\n          at: range,\n          match: { type: getPluginType(editor, ELEMENT_LINK) },\n        });\n\n        if (entry) {\n          const [, path] = entry;\n\n          let newPoint: Point | undefined;\n\n          if (isStartPoint(editor, range.focus, path)) {\n            newPoint = getPreviousNodeEndPoint(editor, path);\n          }\n\n          if (isEndPoint(editor, range.focus, path)) {\n            newPoint = getNextNodeStartPoint(editor, path);\n          }\n\n          if (newPoint) {\n            operation.newProperties = {\n              anchor: newPoint,\n              focus: newPoint,\n            };\n          }\n        }\n      }\n    }\n\n    apply(operation);\n  };\n\n  // TODO: plugin\n  editor.normalizeNode = ([node, path]) => {\n    if (node.type === getPluginType(editor, ELEMENT_LINK)) {\n      const range = editor.selection as Range | null;\n\n      if (range && isCollapsed(range)) {\n        if (isEndPoint(editor, range.focus, path)) {\n          const nextPoint = getNextNodeStartPoint(editor, path);\n\n          // select next text node if any\n          if (nextPoint) {\n            select(editor, nextPoint);\n          } else {\n            // insert text node then select\n            const nextPath = Path.next(path);\n            insertNodes(editor, { text: '' } as any, { at: nextPath });\n            select(editor, nextPath);\n          }\n        }\n      }\n    }\n\n    normalizeNode([node, path]);\n  };\n\n  editor = withRemoveEmptyNodes<V, E>(\n    editor,\n    mockPlugin<{}, V, E>({\n      options: { types: type },\n    })\n  );\n\n  return editor;\n};\n","import { AnchorHTMLAttributes } from 'react';\nimport {\n  createPluginFactory,\n  isUrl,\n  RangeBeforeOptions,\n} from '@udecode/plate-common';\nimport { getLinkAttributes, validateUrl } from './utils/index';\nimport { TLinkElement } from './types';\nimport { withLink } from './withLink';\n\nexport const ELEMENT_LINK = 'a';\n\nexport interface LinkPlugin {\n  forceSubmit?: boolean;\n\n  /**\n   * Allow custom config for rangeBeforeOptions.\n   * @example default\n   * {\n   *   matchString: ' ',\n   *   skipInvalid: true,\n   *   afterMatch: true,\n   * }\n   */\n  rangeBeforeOptions?: RangeBeforeOptions;\n\n  /**\n   * Hotkeys to trigger floating link.\n   * @default 'meta+k, ctrl+k'\n   */\n  triggerFloatingLinkHotkeys?: string | string[];\n\n  /**\n   * List of allowed URL schemes.\n   * @default ['http', 'https', 'mailto', 'tel']\n   */\n  allowedSchemes?: string[];\n\n  /**\n   * Skips sanitation of links.\n   * @default false\n   */\n  dangerouslySkipSanitization?: boolean;\n\n  /**\n   * Default HTML attributes for link elements.\n   * @default {}\n   */\n  defaultLinkAttributes?: AnchorHTMLAttributes<HTMLAnchorElement>;\n\n  /**\n   * Keeps selected text on pasting links by default.\n   * @default true\n   */\n  keepSelectedTextOnPaste?: boolean;\n\n  /**\n   * Callback to validate an url.\n   * @default isUrl\n   */\n  isUrl?: (text: string) => boolean;\n\n  /**\n   * Callback to optionally get the href for a url\n   * @returns href: an optional link to be used that is different from the text content (example https://google.com for google.com)\n   */\n  getUrlHref?: (url: string) => string | undefined;\n\n  /**\n   * On keyboard shortcut or toolbar mousedown, get the link url by calling this promise. The\n   * default behavior is to use the browser's native `prompt`.\n   */\n  getLinkUrl?: (prevUrl: string | null) => Promise<string | null>;\n}\n\n/**\n * Enables support for hyperlinks.\n */\nexport const createLinkPlugin = createPluginFactory<LinkPlugin>({\n  key: ELEMENT_LINK,\n  isElement: true,\n  isInline: true,\n  withOverrides: withLink,\n  options: {\n    allowedSchemes: ['http', 'https', 'mailto', 'tel'],\n    dangerouslySkipSanitization: false,\n    defaultLinkAttributes: {},\n    isUrl,\n    rangeBeforeOptions: {\n      matchString: ' ',\n      skipInvalid: true,\n      afterMatch: true,\n    },\n    triggerFloatingLinkHotkeys: 'meta+k, ctrl+k',\n    keepSelectedTextOnPaste: true,\n  },\n  then: (editor, { type }) => ({\n    props: ({ element }) => ({\n      nodeProps: getLinkAttributes(editor, element as TLinkElement),\n    }),\n    deserializeHtml: {\n      rules: [\n        {\n          validNodeName: 'A',\n        },\n      ],\n      getNode: (el) => {\n        const url = el.getAttribute('href');\n\n        if (url && validateUrl(editor, url)) {\n          return {\n            type,\n            url,\n            target: el.getAttribute('target') || '_blank',\n          };\n        }\n\n        return undefined;\n      },\n    },\n  }),\n});\n"],"names":["createLinkNode","editor","url","text","target","children","type","getPluginType","ELEMENT_LINK","getLinkAttributes","link","allowedSchemes","defaultLinkAttributes","dangerouslySkipSanitization","getPluginOptions","attributes","href","sanitizeUrl","undefined","LaunchIcon","props","React","useLink","_props","useElementProps","elementToAttributes","element","onMouseOver","e","stopPropagation","LinkRoot","createComponentAs","htmlProps","createElementAs","Link","Root","LinkIcon","LinkOffIcon","ShortTextIcon","floatingLinkStore","createStore","openEditorId","mouseDown","updated","newTab","mode","isEditing","extendActions","set","reset","show","editorId","hide","extendSelectors","state","isOpen","floatingLinkActions","floatingLinkSelectors","get","useFloatingLinkSelectors","use","triggerFloatingLinkEdit","entry","findNode","match","path","getEditorString","useFloatingLinkEditButton","useEditorRef","onClick","useCallback","FloatingLinkEditButton","useFloatingLinkNewTabInput","ref","useRef","checked","setChecked","useState","useEffect","current","setTimeout","focus","onChange","mergeProps","useComposedRef","FloatingLinkNewTabInput","useFloatingLinkTextInput","value","defaultValue","FloatingLinkTextInput","useFloatingLinkUrlInput","FloatingLinkUrlInput","useOpenLinkButton","selection","usePlateSelection","useMemo","linkAttributes","OpenLinkButton","insertLink","createLinkNodeOptions","options","insertNodes","submitFloatingLink","forceSubmit","validateUrl","upsertLink","skipValidation","focusEditor","unwrapLink","withoutNormalizing","split","linkAboveAnchor","getAboveNode","at","anchor","splitNodes","n","isElement","linkAboveFocus","unwrapNodes","upsertLinkText","newLink","newLinkNode","newLinkPath","length","firstText","replaceNodeChildren","nodes","insertOptions","select","wrapLink","wrapNodes","insertTextInLink","insertNodesOptions","linkAbove","insertText","isDefined","setNodes","linkEntry","linkNode","linkPath","shouldReplaceText","linkText","isExpanded","removeNodes","getNodeProps","leaf","getNodeLeaf","useUnlinkButton","UnlinkButton","Button","global","platform","computePosition","getWindow","index","useFloating","getDefaultBoundingClientRect","width","height","x","y","top","left","right","bottom","createVirtualElement","getBoundingClientRect","useFloatingLinkEnter","open","id","useHotkeys","key","preventDefault","enabled","enableOnFormTags","useFloatingLinkEscape","enableOnContentEditable","useVirtualFloatingLink","floatingOptions","useVirtualFloating","placement","onOpenChange","middleware","offset","flip","padding","useFloatingLinkEdit","keyEditor","usePlateSelectors","triggerFloatingLinkHotkeys","getRangeBoundingClientRect","getStartPoint","getEndPoint","update","style","refs","someNode","zIndex","setFloating","triggerFloatingLinkInsert","focused","isRangeAcrossBlocks","hasLink","useFloatingLinkInsert","useFocused","useOnClickOutside","disabled","getSelectionBoundingClientRect","whileElementsMounted","FloatingLinkEditRoot","display","FloatingLinkInsertRoot","FloatingLink","EditRoot","InsertRoot","UrlInput","TextInput","NewTabInput","EditButton","triggerFloatingLink","isUrl","permitInvalid","withLink","getUrlHref","rangeBeforeOptions","keepSelectedTextOnPaste","insertData","apply","normalizeNode","insertBreak","beforeWordRange","getRangeBefore","getRangeFromBlockStart","beforeWordText","collapseSelection","edge","isCollapsed","data","getData","textHref","inserted","operation","range","newProperties","newPoint","isStartPoint","getPreviousNodeEndPoint","isEndPoint","getNextNodeStartPoint","node","nextPoint","nextPath","Path","next","withRemoveEmptyNodes","mockPlugin","types","createLinkPlugin","createPluginFactory","isInline","withOverrides","matchString","skipInvalid","afterMatch","then","nodeProps","deserializeHtml","rules","validNodeName","getNode","el","getAttribute"],"mappings":"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"}