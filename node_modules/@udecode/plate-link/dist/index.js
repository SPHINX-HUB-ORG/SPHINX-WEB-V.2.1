'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var plateCommon = require('@udecode/plate-common');
var React = require('react');
var plateButton = require('@udecode/plate-button');
var slateReact = require('slate-react');
var ReactDOM = require('react-dom');
var plateNormalizers = require('@udecode/plate-normalizers');
var slate = require('slate');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var React__namespace = /*#__PURE__*/_interopNamespace(React);
var ReactDOM__namespace = /*#__PURE__*/_interopNamespace(ReactDOM);

const createLinkNode = (editor, {
  url,
  text = '',
  target,
  children
}) => {
  const type = plateCommon.getPluginType(editor, ELEMENT_LINK);
  return {
    type,
    url,
    target,
    children: children !== null && children !== void 0 ? children : [{
      text
    }]
  };
};

const getLinkAttributes = (editor, link) => {
  const {
    allowedSchemes,
    defaultLinkAttributes,
    dangerouslySkipSanitization
  } = plateCommon.getPluginOptions(editor, ELEMENT_LINK);
  const attributes = { ...defaultLinkAttributes
  };
  const href = dangerouslySkipSanitization ? link.url : plateCommon.sanitizeUrl(link.url, {
    allowedSchemes
  }) || undefined; // Avoid passing `undefined` for href or target

  if (href !== undefined) {
    attributes.href = href;
  }

  if ('target' in link) {
    attributes.target = link.target;
  }

  return attributes;
};

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

const LaunchIcon = props => /*#__PURE__*/React__default["default"].createElement("svg", _extends({
  viewBox: "0 0 24 24",
  focusable: "false",
  role: "img",
  fill: "currentColor",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React__default["default"].createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
}), /*#__PURE__*/React__default["default"].createElement("path", {
  d: "M19 19H5V5h7V3H5a2 2 0 00-2 2v14a2 2 0 002 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"
}));

const useLink = props => {
  const {
    editor
  } = props;

  const _props = plateCommon.useElementProps({ ...props,
    elementToAttributes: element => getLinkAttributes(editor, element)
  });

  return { ..._props,
    // quick fix: hovering <a> with href loses the editor focus
    onMouseOver: e => {
      e.stopPropagation();
    }
  };
};
const LinkRoot = plateCommon.createComponentAs(props => {
  const htmlProps = useLink(props);
  return plateCommon.createElementAs('a', htmlProps);
});
const Link = {
  Root: LinkRoot
};

const LinkIcon = props => /*#__PURE__*/React__default["default"].createElement("svg", _extends({
  viewBox: "0 0 24 24",
  focusable: "false",
  role: "img",
  fill: "currentColor",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React__default["default"].createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0z"
}), /*#__PURE__*/React__default["default"].createElement("path", {
  d: "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"
}));

const LinkOffIcon = props => /*#__PURE__*/React__default["default"].createElement("svg", _extends({
  viewBox: "0 0 24 24",
  focusable: "false",
  role: "img",
  fill: "currentColor",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React__default["default"].createElement("path", {
  fill: "none",
  d: "M0 0h24v24H0V0z"
}), /*#__PURE__*/React__default["default"].createElement("path", {
  d: "M17 7h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1 0 1.43-.98 2.63-2.31 2.98l1.46 1.46C20.88 15.61 22 13.95 22 12c0-2.76-2.24-5-5-5zm-1 4h-2.19l2 2H16zM2 4.27l3.11 3.11A4.991 4.991 0 002 12c0 2.76 2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1 0-1.59 1.21-2.9 2.76-3.07L8.73 11H8v2h2.73L13 15.27V17h1.73l4.01 4L20 19.74 3.27 3 2 4.27z"
}), /*#__PURE__*/React__default["default"].createElement("path", {
  fill: "none",
  d: "M0 24V0"
}));

const ShortTextIcon = props => /*#__PURE__*/React__default["default"].createElement("svg", _extends({
  viewBox: "0 0 24 24",
  focusable: "false",
  role: "img",
  fill: "currentColor",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /*#__PURE__*/React__default["default"].createElement("rect", {
  width: 24,
  height: 24,
  fill: "none"
}), /*#__PURE__*/React__default["default"].createElement("path", {
  d: "M4 9h16v2H4V9zm0 4h10v2H4v-2z"
}));

const floatingLinkStore = plateCommon.createStore('floatingLink')({
  openEditorId: null,
  mouseDown: false,
  updated: false,
  url: '',
  text: '',
  newTab: false,
  mode: '',
  isEditing: false
}).extendActions(set => ({
  reset: () => {
    set.url('');
    set.text('');
    set.newTab(false);
    set.mode('');
    set.isEditing(false);
  }
})).extendActions(set => ({
  show: (mode, editorId) => {
    set.mode(mode);
    set.isEditing(false);
    set.openEditorId(editorId);
  },
  hide: () => {
    set.openEditorId(null);
    set.reset();
  }
})).extendSelectors(state => ({
  isOpen: editorId => state.openEditorId === editorId
}));
const floatingLinkActions = floatingLinkStore.set;
const floatingLinkSelectors = floatingLinkStore.get;
const useFloatingLinkSelectors = () => floatingLinkStore.use;

const triggerFloatingLinkEdit = editor => {
  const entry = plateCommon.findNode(editor, {
    match: {
      type: plateCommon.getPluginType(editor, ELEMENT_LINK)
    }
  });
  if (!entry) return;
  const [link, path] = entry;
  let text = plateCommon.getEditorString(editor, path);
  floatingLinkActions.url(link.url);
  floatingLinkActions.newTab(link.target === '_blank');

  if (text === link.url) {
    text = '';
  }

  floatingLinkActions.text(text);
  floatingLinkActions.isEditing(true);
  return true;
};

const useFloatingLinkEditButton = props => {
  const editor = plateCommon.useEditorRef();
  return {
    onClick: React.useCallback(() => {
      triggerFloatingLinkEdit(editor);
    }, [editor]),
    ...props
  };
};
const FloatingLinkEditButton = plateCommon.createComponentAs(props => {
  const htmlProps = useFloatingLinkEditButton(props);
  return plateCommon.createElementAs('button', htmlProps);
});

const useFloatingLinkNewTabInput = props => {
  const updated = useFloatingLinkSelectors().updated();
  const ref = React.useRef(null);
  const [checked, setChecked] = React.useState(floatingLinkSelectors.newTab());
  React.useEffect(() => {
    if (ref.current && updated) {
      setTimeout(() => {
        var _ref$current;

        (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();
      }, 0);
    }
  }, [updated]);
  const onChange = React.useCallback(e => {
    setChecked(e.target.checked);
    floatingLinkActions.newTab(e.target.checked);
  }, []);
  return plateCommon.mergeProps({
    onChange,
    checked,
    type: 'checkbox'
  }, { ...props,
    ref: plateCommon.useComposedRef(props.ref, ref)
  });
};
const FloatingLinkNewTabInput = plateCommon.createComponentAs(props => {
  const htmlProps = useFloatingLinkNewTabInput(props);
  return plateCommon.createElementAs('input', htmlProps);
});

const useFloatingLinkTextInput = props => {
  const onChange = React.useCallback(e => {
    floatingLinkActions.text(e.target.value);
  }, []);
  return plateCommon.mergeProps({
    onChange,
    defaultValue: floatingLinkSelectors.text()
  }, props);
};
const FloatingLinkTextInput = plateCommon.createComponentAs(props => {
  const htmlProps = useFloatingLinkTextInput(props);
  return plateCommon.createElementAs('input', htmlProps);
});

const useFloatingLinkUrlInput = props => {
  const updated = useFloatingLinkSelectors().updated();
  const ref = React.useRef(null);
  React.useEffect(() => {
    if (ref.current && updated) {
      setTimeout(() => {
        var _ref$current;

        (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();
      }, 0);
    }
  }, [updated]);
  const onChange = React.useCallback(e => {
    floatingLinkActions.url(e.target.value);
  }, []);
  return plateCommon.mergeProps({
    onChange,
    defaultValue: floatingLinkSelectors.url()
  }, { ...props,
    ref: plateCommon.useComposedRef(props.ref, ref)
  });
};
const FloatingLinkUrlInput = plateCommon.createComponentAs(props => {
  const htmlProps = useFloatingLinkUrlInput(props);
  return plateCommon.createElementAs('input', htmlProps);
});

const useOpenLinkButton = props => {
  const editor = plateCommon.useEditorRef();
  const selection = plateCommon.usePlateSelection();
  const entry = React.useMemo(() => plateCommon.findNode(editor, {
    match: {
      type: plateCommon.getPluginType(editor, ELEMENT_LINK)
    }
  }), // eslint-disable-next-line react-hooks/exhaustive-deps
  [editor, selection]);

  if (!entry) {
    return {};
  }

  const [element] = entry;
  const linkAttributes = getLinkAttributes(editor, element);
  return { ...linkAttributes,
    target: '_blank',
    'aria-label': 'Open link in a new tab',
    onMouseOver: e => {
      e.stopPropagation();
    },
    ...props
  };
};
const OpenLinkButton = plateCommon.createComponentAs(props => {
  const htmlProps = useOpenLinkButton(props);
  return plateCommon.createElementAs('a', htmlProps);
});

/**
 * Insert a link node.
 */

const insertLink = (editor, createLinkNodeOptions, options) => {
  plateCommon.insertNodes(editor, [createLinkNode(editor, createLinkNodeOptions)], options);
};

/**
 * Insert link if url is valid.
 * Text is url if empty.
 * Close floating link.
 * Focus editor.
 */

const submitFloatingLink = editor => {
  if (!editor.selection) return;
  const {
    forceSubmit
  } = plateCommon.getPluginOptions(editor, ELEMENT_LINK);
  const url = floatingLinkSelectors.url();
  if (!forceSubmit && !validateUrl(editor, url)) return;
  const text = floatingLinkSelectors.text();
  const target = floatingLinkSelectors.newTab() ? '_blank' : undefined;
  floatingLinkActions.hide();
  upsertLink(editor, {
    url,
    text,
    target,
    skipValidation: true
  });
  setTimeout(() => {
    plateCommon.focusEditor(editor, editor.selection);
  }, 0);
  return true;
};

/**
 * Unwrap link node.
 */

const unwrapLink = (editor, options) => {
  return plateCommon.withoutNormalizing(editor, () => {
    if (options !== null && options !== void 0 && options.split) {
      var _editor$selection, _editor$selection4;

      const linkAboveAnchor = plateCommon.getAboveNode(editor, {
        at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor,
        match: {
          type: plateCommon.getPluginType(editor, ELEMENT_LINK)
        }
      }); // anchor in link

      if (linkAboveAnchor) {
        var _editor$selection2, _editor$selection3;

        plateCommon.splitNodes(editor, {
          at: (_editor$selection2 = editor.selection) === null || _editor$selection2 === void 0 ? void 0 : _editor$selection2.anchor,
          match: n => plateCommon.isElement(n) && n.type === plateCommon.getPluginType(editor, ELEMENT_LINK)
        });
        unwrapLink(editor, {
          at: (_editor$selection3 = editor.selection) === null || _editor$selection3 === void 0 ? void 0 : _editor$selection3.anchor
        });
        return true;
      }

      const linkAboveFocus = plateCommon.getAboveNode(editor, {
        at: (_editor$selection4 = editor.selection) === null || _editor$selection4 === void 0 ? void 0 : _editor$selection4.focus,
        match: {
          type: plateCommon.getPluginType(editor, ELEMENT_LINK)
        }
      }); // focus in link

      if (linkAboveFocus) {
        var _editor$selection5, _editor$selection6;

        plateCommon.splitNodes(editor, {
          at: (_editor$selection5 = editor.selection) === null || _editor$selection5 === void 0 ? void 0 : _editor$selection5.focus,
          match: n => plateCommon.isElement(n) && n.type === plateCommon.getPluginType(editor, ELEMENT_LINK)
        });
        unwrapLink(editor, {
          at: (_editor$selection6 = editor.selection) === null || _editor$selection6 === void 0 ? void 0 : _editor$selection6.focus
        });
        return true;
      }
    }

    plateCommon.unwrapNodes(editor, {
      match: {
        type: plateCommon.getPluginType(editor, ELEMENT_LINK)
      },
      ...options
    });
  });
};

/**
 * If the text is different than the link above text, replace link children by a new text.
 * The new text has the same marks than the first text replaced.
 */
const upsertLinkText = (editor, {
  text
}) => {
  const newLink = plateCommon.getAboveNode(editor, {
    match: {
      type: plateCommon.getPluginType(editor, ELEMENT_LINK)
    }
  });

  if (newLink) {
    const [newLinkNode, newLinkPath] = newLink;

    if (text !== null && text !== void 0 && text.length && text !== plateCommon.getEditorString(editor, newLinkPath)) {
      const firstText = newLinkNode.children[0]; // remove link children

      plateCommon.replaceNodeChildren(editor, {
        at: newLinkPath,
        nodes: { ...firstText,
          text
        },
        insertOptions: {
          select: true
        }
      });
    }
  }
};

/**
 * Wrap a link node with split.
 */
const wrapLink = (editor, {
  url,
  target,
  ...options
}) => {
  plateCommon.wrapNodes(editor, {
    type: plateCommon.getPluginType(editor, ELEMENT_LINK),
    url,
    target,
    children: []
  }, {
    split: true,
    ...options
  });
};

/**
 * If selection in a link or is not url:
 * - insert text with url, exit
 * If selection is expanded or `update` in a link:
 * - remove link node, get link text
 * Then:
 * - insert link node
 */
const upsertLink = (editor, {
  url,
  text,
  target,
  insertTextInLink,
  insertNodesOptions,
  skipValidation = false
}) => {
  var _text, _editor$selection, _text2;

  const at = editor.selection;
  if (!at) return;
  const linkAbove = plateCommon.getAboveNode(editor, {
    at,
    match: {
      type: plateCommon.getPluginType(editor, ELEMENT_LINK)
    }
  }); // anchor and focus in link -> insert text

  if (insertTextInLink && linkAbove) {
    // we don't want to insert marks in links
    editor.insertText(url);
    return true;
  }

  if (!skipValidation && !validateUrl(editor, url)) return;

  if (plateCommon.isDefined(text) && !text.length) {
    text = url;
  } // edit the link url and/or target


  if (linkAbove) {
    var _linkAbove$, _linkAbove$2;

    if (url !== ((_linkAbove$ = linkAbove[0]) === null || _linkAbove$ === void 0 ? void 0 : _linkAbove$.url) || target !== ((_linkAbove$2 = linkAbove[0]) === null || _linkAbove$2 === void 0 ? void 0 : _linkAbove$2.target)) {
      plateCommon.setNodes(editor, {
        url,
        target
      }, {
        at: linkAbove[1]
      });
    }

    upsertLinkText(editor, {
      url,
      text,
      target
    });
    return true;
  } // selection contains at one edge edge or between the edges


  const linkEntry = plateCommon.findNode(editor, {
    at,
    match: {
      type: plateCommon.getPluginType(editor, ELEMENT_LINK)
    }
  });
  const [linkNode, linkPath] = linkEntry !== null && linkEntry !== void 0 ? linkEntry : [];
  let shouldReplaceText = false;

  if (linkPath && (_text = text) !== null && _text !== void 0 && _text.length) {
    const linkText = plateCommon.getEditorString(editor, linkPath);

    if (text !== linkText) {
      shouldReplaceText = true;
    }
  }

  if (plateCommon.isExpanded(at)) {
    // anchor and focus in link
    if (linkAbove) {
      unwrapLink(editor, {
        at: linkAbove[1]
      });
    } else {
      unwrapLink(editor, {
        split: true
      });
    }

    wrapLink(editor, {
      url,
      target
    });
    upsertLinkText(editor, {
      url,
      target,
      text
    });
    return true;
  }

  if (shouldReplaceText) {
    plateCommon.removeNodes(editor, {
      at: linkPath
    });
  }

  const props = plateCommon.getNodeProps(linkNode !== null && linkNode !== void 0 ? linkNode : {});
  const path = (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus.path;
  if (!path) return; // link text should have the focused leaf marks

  const leaf = plateCommon.getNodeLeaf(editor, path); // if text is empty, text is url

  if (!((_text2 = text) !== null && _text2 !== void 0 && _text2.length)) {
    text = url;
  }

  insertLink(editor, { ...props,
    url,
    target,
    children: [{ ...leaf,
      text
    }]
  }, insertNodesOptions);
  return true;
};

const useUnlinkButton = props => {
  const editor = plateCommon.useEditorRef();
  return {
    onClick: React.useCallback(() => {
      unwrapLink(editor);
      plateCommon.focusEditor(editor, editor.selection);
    }, [editor]),
    ...props
  };
};
const UnlinkButton = plateCommon.createComponentAs(props => {
  const htmlProps = useUnlinkButton(props);
  return plateCommon.createElementAs(plateButton.Button, htmlProps);
});

var global$1 = (typeof global !== "undefined" ? global :
            typeof self !== "undefined" ? self :
            typeof window !== "undefined" ? window : {});

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform$1 = 'browser';
var browser = true;
var env = {};
var argv = [];
var version = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};

function noop() {}

var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var process = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform$1,
  release: release,
  config: config,
  uptime: uptime
};

function getAlignment(placement) {
  return placement.split('-')[1];
}

function getLengthFromAxis(axis) {
  return axis === 'y' ? 'height' : 'width';
}

function getSide(placement) {
  return placement.split('-')[0];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === 'x';
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case 'start':
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain positioning strategy.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}

function getSideObjectFromPadding(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}

function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}

function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}

const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}

function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}

function getSideList(side, isStart, rtl) {
  const lr = ['left', 'right'];
  const rl = ['right', 'left'];
  const tb = ['top', 'bottom'];
  const bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          // Try next placement and re-run the lifecycle.
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        // First, find the candidates that fit on the mainAxis side of overflow,
        // then find the placement that fits the best on the main crossAxis side.
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

        // Otherwise fallback.
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$map$so;
                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

async function convertValueToCoords(state, value) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === 'x';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === 'function' ? value(state) : value;

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = function (value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: 'offset',
    options: value,
    async fn(state) {
      const {
        x,
        y
      } = state;
      const diffCoords = await convertValueToCoords(state, value);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};

function getWindow$1(node) {
  var _node$ownerDocument;
  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}

function getComputedStyle$1(element) {
  return getWindow$1(element).getComputedStyle(element);
}

function isNode(value) {
  return value instanceof getWindow$1(value).Node;
}
function getNodeName(node) {
  return isNode(node) ? (node.nodeName || '').toLowerCase() : '';
}

let uaString;
function getUAString() {
  if (uaString) {
    return uaString;
  }
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    uaString = uaData.brands.map(item => item.brand + "/" + item.version).join(' ');
    return uaString;
  }
  return navigator.userAgent;
}

function isHTMLElement(value) {
  return value instanceof getWindow$1(value).HTMLElement;
}
function isElement$1(value) {
  return value instanceof getWindow$1(value).Element;
}
function isShadowRoot(node) {
  // Browsers without `ShadowRoot` support.
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  const OwnElement = getWindow$1(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isContainingBlock(element) {
  // TODO: Try to use feature detection here instead.
  const isFirefox = /firefox/i.test(getUAString());
  const css = getComputedStyle$1(element);
  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;

  // This is non-exhaustive but covers the most common CSS properties that
  // create a containing block.
  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => {
    // Add type check for old browsers.
    const contain = css.contain;
    return contain != null ? contain.includes(value) : false;
  });
}

/**
 * Determines whether or not `.getBoundingClientRect()` is affected by visual
 * viewport offsets. In Safari, the `x`/`y` offsets are values relative to the
 * visual viewport, while in other engines, they are values relative to the
 * layout viewport.
 */
function isClientRectVisualViewportBased() {
  // TODO: Try to use feature detection here instead. Feature detection for
  // this can fail in various ways, making the userAgent check the most
  // reliable:
  // • Always-visible scrollbar or not
  // • Width of <html>

  // Is Safari.
  return /^((?!chrome|android).)*safari/i.test(getUAString());
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}

const min = Math.min;
const max = Math.max;
const round = Math.round;

function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width);
  let height = parseFloat(css.height);
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    fallback: shouldFallback
  };
}

function unwrapElement(element) {
  return !isElement$1(element) ? element.contextElement : element;
}

const FALLBACK_SCALE = {
  x: 1,
  y: 1
};
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return FALLBACK_SCALE;
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    fallback
  } = getCssDimensions(domElement);
  let x = (fallback ? round(rect.width) : rect.width) / width;
  let y = (fallback ? round(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}

function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  var _win$visualViewport, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = FALLBACK_SCALE;
  if (includeScale) {
    if (offsetParent) {
      if (isElement$1(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const win = domElement ? getWindow$1(domElement) : window;
  const addVisualOffsets = isClientRectVisualViewportBased() && isFixedStrategy;
  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;
  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow$1(domElement);
    const offsetWin = offsetParent && isElement$1(offsetParent) ? getWindow$1(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += iframeRect.x;
      y += iframeRect.y;
      currentIFrame = getWindow$1(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}

function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}

function getNodeScroll(element) {
  if (isElement$1(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = {
    x: 1,
    y: 1
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === 'rtl') {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node.
  node.assignedSlot ||
  // DOM Element detected.
  node.parentNode ||
  // ShadowRoot detected.
  isShadowRoot(node) && node.host ||
  // Fallback.
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}

function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    // `getParentNode` will never return a `Document` due to the fallback
    // check, so it's either the <html> or <body> element.
    return parentNode.ownerDocument.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}

function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow$1(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
}

function getViewportRect(element, strategy) {
  const win = getWindow$1(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isClientRectVisualViewportBased();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}

// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : {
    x: 1,
    y: 1
  };
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement$1(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const mutableRect = {
      ...clippingAncestor
    };
    if (isClientRectVisualViewportBased()) {
      var _win$visualViewport, _win$visualViewport2;
      const win = getWindow$1(element);
      mutableRect.x -= ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0;
      mutableRect.y -= ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0;
    }
    rect = mutableRect;
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement$1(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element).filter(el => isElement$1(el) && getNodeName(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';
  let currentNode = elementIsFixed ? getParentNode(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while (isElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks.
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      // Record last containing block for next iteration.
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

function getDimensions(element) {
  return getCssDimensions(element);
}

function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
  const window = getWindow$1(element);
  if (!isHTMLElement(element)) {
    return window;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

const platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement: isElement$1,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getScale,
  async getElementRects(_ref) {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
      floating: {
        x: 0,
        y: 0,
        ...(await getDimensionsFn(floating))
      }
    };
  },
  getClientRects: element => Array.from(element.getClientRects()),
  isRTL: element => getComputedStyle$1(element).direction === 'rtl'
};

/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = true,
    animationFrame = false
  } = options;
  const ancestors = ancestorScroll || ancestorResize ? [...(isElement$1(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    // ignores Window, checks for [object VisualViewport]
    const isVisualViewport = !isElement$1(ancestor) && ancestor.toString().includes('V');
    if (ancestorScroll && (animationFrame ? isVisualViewport : true)) {
      ancestor.addEventListener('scroll', update, {
        passive: true
      });
    }
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  let observer = null;
  if (elementResize) {
    observer = new ResizeObserver(() => {
      update();
    });
    isElement$1(reference) && !animationFrame && observer.observe(reference);
    if (!isElement$1(reference) && reference.contextElement && !animationFrame) {
      observer.observe(reference.contextElement);
    }
    observer.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _observer;
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain CSS positioning
 * strategy.
 */
const computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

var index$1 = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect;

// Fork of `fast-deep-equal` that only does the comparisons we need and compares
// functions
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === 'function' && a.toString() === b.toString()) {
    return true;
  }
  let length, i, keys;
  if (a && b && typeof a == 'object') {
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0;) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0;) {
      const key = keys[i];
      if (key === '_owner' && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}

function useLatestRef(value) {
  const ref = React__namespace.useRef(value);
  index$1(() => {
    ref.current = value;
  });
  return ref;
}

/**
 * Provides data to position a floating element.
 * @see https://floating-ui.com/docs/react
 */
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React__namespace.useState({
    x: null,
    y: null,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React__namespace.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const referenceRef = React__namespace.useRef(null);
  const floatingRef = React__namespace.useRef(null);
  const dataRef = React__namespace.useRef(data);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform);
  const [reference, _setReference] = React__namespace.useState(null);
  const [floating, _setFloating] = React__namespace.useState(null);
  const setReference = React__namespace.useCallback(node => {
    if (referenceRef.current !== node) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React__namespace.useCallback(node => {
    if (floatingRef.current !== node) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const update = React__namespace.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then(data => {
      const fullData = {
        ...data,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM__namespace.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index$1(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData(data => ({
        ...data,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React__namespace.useRef(false);
  index$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$1(() => {
    if (reference && floating) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(reference, floating, update);
      } else {
        update();
      }
    }
  }, [reference, floating, update, whileElementsMountedRef]);
  const refs = React__namespace.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React__namespace.useMemo(() => ({
    reference,
    floating
  }), [reference, floating]);
  return React__namespace.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    reference: setReference,
    floating: setFloating
  }), [data, update, refs, elements, setReference, setFloating]);
}

var index = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect;

let serverHandoffComplete = false;
let count = 0;
const genId = () => "floating-ui-" + count++;
function useFloatingId() {
  const [id, setId] = React__namespace.useState(() => serverHandoffComplete ? genId() : undefined);
  index(() => {
    if (id == null) {
      setId(genId());
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  React__namespace.useEffect(() => {
    if (!serverHandoffComplete) {
      serverHandoffComplete = true;
    }
  }, []);
  return id;
}

// `toString()` prevents bundlers from trying to `import { useId } from 'react'`
const useReactId = React__namespace[/*#__PURE__*/'useId'.toString()];

/**
 * Uses React 18's built-in `useId()` when available, or falls back to a
 * slightly less performant (requiring a double render) implementation for
 * earlier React versions.
 * @see https://floating-ui.com/docs/useId
 */
const useId = useReactId || useFloatingId;

function createPubSub() {
  const map = new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach(handler => handler(data));
    },
    on(event, listener) {
      map.set(event, [...(map.get(event) || []), listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter(l => l !== listener)) || []);
    }
  };
}
const FloatingTreeContext = /*#__PURE__*/React__namespace.createContext(null);
const useFloatingTree = () => React__namespace.useContext(FloatingTreeContext);

function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}

function getWindow(value) {
  return getDocument(value).defaultView || window;
}
function isElement(value) {
  return value ? value instanceof getWindow(value).Element : false;
}

// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`
const useInsertionEffect = React__namespace[/*#__PURE__*/'useInsertionEffect'.toString()];
const useSafeInsertionEffect = useInsertionEffect || (fn => fn());
function useEvent(callback) {
  const ref = React__namespace.useRef(() => {
    if (process.env.NODE_ENV !== "production") {
      throw new Error('Cannot call an event handler while rendering.');
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React__namespace.useCallback(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}

/**
 * Provides data to position a floating element and context to add interactions.
 * @see https://floating-ui.com/docs/react
 */
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    open = false,
    onOpenChange: unstable_onOpenChange,
    nodeId
  } = options;
  const position = useFloating$1(options);
  const tree = useFloatingTree();
  const domReferenceRef = React__namespace.useRef(null);
  const dataRef = React__namespace.useRef({});
  const events = React__namespace.useState(() => createPubSub())[0];
  const floatingId = useId();
  const [domReference, setDomReference] = React__namespace.useState(null);
  const setPositionReference = React__namespace.useCallback(node => {
    const positionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    position.refs.setReference(positionReference);
  }, [position.refs]);
  const setReference = React__namespace.useCallback(node => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }

    // Backwards-compatibility for passing a virtual element to `reference`
    // after it has set the DOM reference.
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null ||
    // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = React__namespace.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = React__namespace.useMemo(() => ({
    ...position.elements,
    domReference: domReference
  }), [position.elements, domReference]);
  const onOpenChange = useEvent(unstable_onOpenChange);
  const context = React__namespace.useMemo(() => ({
    ...position,
    refs,
    elements,
    dataRef,
    nodeId,
    floatingId,
    events,
    open,
    onOpenChange
  }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);
  index(() => {
    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return React__namespace.useMemo(() => ({
    ...position,
    context,
    refs,
    elements,
    reference: setReference,
    positionReference: setPositionReference
  }), [position, refs, elements, context, setReference, setPositionReference]);
}

const getDefaultBoundingClientRect = () => ({
  width: 0,
  height: 0,
  x: 0,
  y: 0,
  top: -9999,
  left: -9999,
  right: 9999,
  bottom: 9999
});

const createVirtualElement = () => ({
  getBoundingClientRect: getDefaultBoundingClientRect
});
/**
 * Get bounding client rect by slate range
 */


const getRangeBoundingClientRect = (editor, at) => {
  if (!at) return getDefaultBoundingClientRect();
  const domRange = plateCommon.toDOMRange(editor, at);
  if (!domRange) return getDefaultBoundingClientRect();
  return domRange.getBoundingClientRect();
};
/**
 * Get bounding client rect of the window selection
 */


const getSelectionBoundingClientRect = () => {
  const domSelection = window.getSelection();

  if (!domSelection || domSelection.rangeCount < 1) {
    return getDefaultBoundingClientRect();
  }

  const domRange = domSelection.getRangeAt(0);
  return domRange.getBoundingClientRect();
};
/**
 * `useFloating` with a controlled virtual element. Used to follow cursor position.
 *
 * Default options:
 * - `whileElementsMounted: autoUpdate`
 *
 * Additional options:
 * - `getBoundingClientRect` to get the bounding client rect.
 * - `hidden` to hide the floating element
 *
 * Additional returns:
 * - `style` to apply to the floating element
 * - `virtualElementRef`
 *
 * @see useFloating
 * @see https://floating-ui.com/docs/react-dom#virtual-element
 */


const useVirtualFloating = ({
  getBoundingClientRect = getSelectionBoundingClientRect,
  ...floatingOptions
}) => {
  const virtualElementRef = React.useRef(createVirtualElement());
  const [visible, setVisible] = React.useState(true);
  const floatingResult = useFloating({
    // update on scroll and resize
    whileElementsMounted: autoUpdate,
    ...floatingOptions
  });
  const {
    refs,
    middlewareData,
    strategy,
    x,
    y,
    update
  } = floatingResult;
  React.useLayoutEffect(() => {
    virtualElementRef.current.getBoundingClientRect = getBoundingClientRect;
  }, [getBoundingClientRect, update]);
  React.useLayoutEffect(() => {
    refs.setReference(virtualElementRef.current);
  }, [refs]);
  React.useLayoutEffect(() => {
    if (!(middlewareData !== null && middlewareData !== void 0 && middlewareData.hide)) return;
    const {
      referenceHidden
    } = middlewareData.hide;
    setVisible(!referenceHidden);
  }, [middlewareData.hide]);
  return { ...floatingResult,
    virtualElementRef,
    style: {
      position: strategy,
      top: y !== null && y !== void 0 ? y : 0,
      left: x !== null && x !== void 0 ? x : 0,
      display: floatingOptions.open === false ? 'none' : undefined,
      visibility: !visible ? 'hidden' : undefined
    }
  };
};

const useFloatingLinkEnter = () => {
  const editor = plateCommon.useEditorRef();
  const open = useFloatingLinkSelectors().isOpen(editor.id);
  plateCommon.useHotkeys('*', e => {
    if (e.key !== 'Enter') return;

    if (submitFloatingLink(editor)) {
      e.preventDefault();
    }
  }, {
    enabled: open,
    enableOnFormTags: ['INPUT']
  }, []);
};

const useFloatingLinkEscape = () => {
  const editor = plateCommon.useEditorRef();
  const open = useFloatingLinkSelectors().isOpen(editor.id);
  plateCommon.useHotkeys('escape', e => {
    if (!floatingLinkSelectors.mode()) return;
    e.preventDefault();

    if (floatingLinkSelectors.mode() === 'edit' && floatingLinkSelectors.isEditing()) {
      floatingLinkActions.show('edit', editor.id);
      plateCommon.focusEditor(editor, editor.selection);
      return;
    }

    if (floatingLinkSelectors.mode() === 'insert') {
      plateCommon.focusEditor(editor, editor.selection);
    }

    floatingLinkActions.hide();
  }, {
    enabled: open,
    enableOnFormTags: ['INPUT'],
    enableOnContentEditable: true
  }, []);
};

const useVirtualFloatingLink = ({
  editorId,
  ...floatingOptions
}) => {
  return useVirtualFloating({
    placement: 'bottom-start',
    onOpenChange: open => floatingLinkActions.openEditorId(open ? editorId : null),
    middleware: [offset(12), flip({
      padding: 96
    })],
    ...floatingOptions
  });
};

const useFloatingLinkEdit = ({
  floatingOptions,
  ...props
}) => {
  const editor = plateCommon.useEditorRef();
  const keyEditor = plateCommon.usePlateSelectors().keyEditor();
  const mode = useFloatingLinkSelectors().mode();
  const open = useFloatingLinkSelectors().isOpen(editor.id);
  const {
    triggerFloatingLinkHotkeys
  } = plateCommon.getPluginOptions(editor, ELEMENT_LINK);
  const getBoundingClientRect = React.useCallback(() => {
    const entry = plateCommon.getAboveNode(editor, {
      match: {
        type: plateCommon.getPluginType(editor, ELEMENT_LINK)
      }
    });

    if (entry) {
      const [, path] = entry;
      return getRangeBoundingClientRect(editor, {
        anchor: plateCommon.getStartPoint(editor, path),
        focus: plateCommon.getEndPoint(editor, path)
      });
    }

    return getDefaultBoundingClientRect();
  }, [editor]);
  const isOpen = open && mode === 'edit';
  const {
    update,
    style,
    refs
  } = useVirtualFloatingLink({
    editorId: editor.id,
    open: isOpen,
    getBoundingClientRect,
    ...floatingOptions
  });
  React.useEffect(() => {
    if (editor.selection && plateCommon.someNode(editor, {
      match: {
        type: plateCommon.getPluginType(editor, ELEMENT_LINK)
      }
    })) {
      floatingLinkActions.show('edit', editor.id);
      update();
      return;
    }

    if (floatingLinkSelectors.mode() === 'edit') {
      floatingLinkActions.hide();
    }
  }, [editor, keyEditor, update]);
  plateCommon.useHotkeys(triggerFloatingLinkHotkeys, e => {
    if (floatingLinkSelectors.mode() === 'edit' && triggerFloatingLinkEdit(editor)) {
      e.preventDefault();
    }
  }, {
    enableOnContentEditable: true
  }, []);
  useFloatingLinkEnter();
  useFloatingLinkEscape();
  return {
    style: { ...style,
      zIndex: 1
    },
    ...props,
    ref: plateCommon.useComposedRef(props.ref, refs.setFloating)
  };
};

/**
 * Trigger floating link.
 *
 * Do not trigger when:
 * - selection is across blocks
 * - selection has more than one leaf node
 * - lowest selection is not text
 * - selection has a link node
 */

const triggerFloatingLinkInsert = (editor, {
  focused
} = {}) => {
  if (floatingLinkSelectors.mode()) return;
  if (!focused) return;
  if (plateCommon.isRangeAcrossBlocks(editor, {
    at: editor.selection
  })) return;
  const hasLink = plateCommon.someNode(editor, {
    match: {
      type: plateCommon.getPluginType(editor, ELEMENT_LINK)
    }
  });
  if (hasLink) return;
  floatingLinkActions.text(plateCommon.getEditorString(editor, editor.selection));
  floatingLinkActions.show('insert', editor.id);
  return true;
};

const useFloatingLinkInsert = ({
  floatingOptions,
  ...props
}) => {
  const editor = plateCommon.useEditorRef();
  const focused = slateReact.useFocused();
  const mode = useFloatingLinkSelectors().mode();
  const open = useFloatingLinkSelectors().isOpen(editor.id);
  const {
    triggerFloatingLinkHotkeys
  } = plateCommon.getPluginOptions(editor, ELEMENT_LINK);
  plateCommon.useHotkeys(triggerFloatingLinkHotkeys, e => {
    if (triggerFloatingLinkInsert(editor, {
      focused
    })) {
      e.preventDefault();
    }
  }, {
    enableOnContentEditable: true
  }, [focused]);
  const ref = plateCommon.useOnClickOutside(() => {
    if (floatingLinkSelectors.mode() === 'insert') {
      floatingLinkActions.hide();
      plateCommon.focusEditor(editor, editor.selection);
    }
  }, {
    disabled: !open
  });
  const {
    update,
    style,
    refs
  } = useVirtualFloatingLink({
    editorId: editor.id,
    open: open && mode === 'insert',
    getBoundingClientRect: getSelectionBoundingClientRect,
    whileElementsMounted: () => {},
    ...floatingOptions
  }); // wait for update before focusing input

  React.useEffect(() => {
    if (open) {
      update();
      floatingLinkActions.updated(true);
    } else {
      floatingLinkActions.updated(false);
    }
  }, [open, update]);
  useFloatingLinkEscape();
  return {
    style: { ...style,
      zIndex: 1
    },
    ...props,
    ref: plateCommon.useComposedRef(props.ref, refs.setFloating, ref)
  };
};

const FloatingLinkEditRoot = plateCommon.createComponentAs(props => {
  var _htmlProps$style;

  const htmlProps = useFloatingLinkEdit(props);

  if (((_htmlProps$style = htmlProps.style) === null || _htmlProps$style === void 0 ? void 0 : _htmlProps$style.display) === 'none') {
    return null;
  }

  return plateCommon.createElementAs('div', htmlProps);
});
const FloatingLinkInsertRoot = plateCommon.createComponentAs(props => {
  var _htmlProps$style2;

  const htmlProps = useFloatingLinkInsert(props);

  if (((_htmlProps$style2 = htmlProps.style) === null || _htmlProps$style2 === void 0 ? void 0 : _htmlProps$style2.display) === 'none') {
    return null;
  }

  return plateCommon.createElementAs('div', htmlProps);
});
const FloatingLink = {
  EditRoot: FloatingLinkEditRoot,
  InsertRoot: FloatingLinkInsertRoot,
  UrlInput: FloatingLinkUrlInput,
  TextInput: FloatingLinkTextInput,
  NewTabInput: FloatingLinkNewTabInput,
  EditButton: FloatingLinkEditButton,
  UnlinkButton,
  OpenLinkButton
};

const triggerFloatingLink = (editor, {
  focused
} = {}) => {
  if (floatingLinkSelectors.mode() === 'edit') {
    triggerFloatingLinkEdit(editor);
    return;
  }

  triggerFloatingLinkInsert(editor, {
    focused
  });
};

const validateUrl = (editor, url) => {
  const {
    allowedSchemes,
    isUrl,
    dangerouslySkipSanitization
  } = plateCommon.getPluginOptions(editor, ELEMENT_LINK);
  if (isUrl && !isUrl(url)) return false;
  if (!dangerouslySkipSanitization && !plateCommon.sanitizeUrl(url, {
    allowedSchemes,
    permitInvalid: true
  })) return false;
  return true;
};

/**
 * Insert space after a url to wrap a link.
 * Lookup from the block start to the cursor to check if there is an url.
 * If not found, lookup before the cursor for a space character to check the url.
 *
 * On insert data:
 * Paste a string inside a link element will edit its children text but not its url.
 *
 */

const withLink = (editor, {
  type,
  options: {
    isUrl,
    getUrlHref,
    rangeBeforeOptions,
    keepSelectedTextOnPaste
  }
}) => {
  const {
    insertData,
    insertText,
    apply,
    normalizeNode,
    insertBreak
  } = editor;

  const wrapLink = () => {
    plateCommon.withoutNormalizing(editor, () => {
      var _getUrlHref;

      const selection = editor.selection; // get the range from first space before the cursor

      let beforeWordRange = plateCommon.getRangeBefore(editor, selection, rangeBeforeOptions); // if no space found before, get the range from block start

      if (!beforeWordRange) {
        beforeWordRange = plateCommon.getRangeFromBlockStart(editor);
      } // if no word found before the cursor, exit


      if (!beforeWordRange) return;
      const hasLink = plateCommon.someNode(editor, {
        at: beforeWordRange,
        match: {
          type: plateCommon.getPluginType(editor, ELEMENT_LINK)
        }
      }); // if word before the cursor has a link, exit

      if (hasLink) return;
      let beforeWordText = plateCommon.getEditorString(editor, beforeWordRange);
      beforeWordText = (_getUrlHref = getUrlHref === null || getUrlHref === void 0 ? void 0 : getUrlHref(beforeWordText)) !== null && _getUrlHref !== void 0 ? _getUrlHref : beforeWordText; // if word before is not an url, exit

      if (!isUrl(beforeWordText)) return; // select the word to wrap link

      plateCommon.select(editor, beforeWordRange); // wrap link

      upsertLink(editor, {
        url: beforeWordText
      }); // collapse selection

      plateCommon.collapseSelection(editor, {
        edge: 'end'
      });
    });
  };

  editor.insertBreak = () => {
    if (!plateCommon.isCollapsed(editor.selection)) return insertBreak();
    wrapLink();
    insertBreak();
  };

  editor.insertText = text => {
    if (text === ' ' && plateCommon.isCollapsed(editor.selection)) {
      wrapLink();
    }

    insertText(text);
  };

  editor.insertData = data => {
    const text = data.getData('text/plain');
    const textHref = getUrlHref === null || getUrlHref === void 0 ? void 0 : getUrlHref(text);

    if (text) {
      const value = textHref || text;
      const inserted = upsertLink(editor, {
        text: keepSelectedTextOnPaste ? undefined : value,
        url: value,
        insertTextInLink: true
      });
      if (inserted) return;
    }

    insertData(data);
  }; // TODO: plugin


  editor.apply = operation => {
    if (operation.type === 'set_selection') {
      const range = operation.newProperties;

      if (range && range.focus && range.anchor && plateCommon.isCollapsed(range)) {
        const entry = plateCommon.getAboveNode(editor, {
          at: range,
          match: {
            type: plateCommon.getPluginType(editor, ELEMENT_LINK)
          }
        });

        if (entry) {
          const [, path] = entry;
          let newPoint;

          if (plateCommon.isStartPoint(editor, range.focus, path)) {
            newPoint = plateCommon.getPreviousNodeEndPoint(editor, path);
          }

          if (plateCommon.isEndPoint(editor, range.focus, path)) {
            newPoint = plateCommon.getNextNodeStartPoint(editor, path);
          }

          if (newPoint) {
            operation.newProperties = {
              anchor: newPoint,
              focus: newPoint
            };
          }
        }
      }
    }

    apply(operation);
  }; // TODO: plugin


  editor.normalizeNode = ([node, path]) => {
    if (node.type === plateCommon.getPluginType(editor, ELEMENT_LINK)) {
      const range = editor.selection;

      if (range && plateCommon.isCollapsed(range)) {
        if (plateCommon.isEndPoint(editor, range.focus, path)) {
          const nextPoint = plateCommon.getNextNodeStartPoint(editor, path); // select next text node if any

          if (nextPoint) {
            plateCommon.select(editor, nextPoint);
          } else {
            // insert text node then select
            const nextPath = slate.Path.next(path);
            plateCommon.insertNodes(editor, {
              text: ''
            }, {
              at: nextPath
            });
            plateCommon.select(editor, nextPath);
          }
        }
      }
    }

    normalizeNode([node, path]);
  };

  editor = plateNormalizers.withRemoveEmptyNodes(editor, plateCommon.mockPlugin({
    options: {
      types: type
    }
  }));
  return editor;
};

const ELEMENT_LINK = 'a';

/**
 * Enables support for hyperlinks.
 */
const createLinkPlugin = plateCommon.createPluginFactory({
  key: ELEMENT_LINK,
  isElement: true,
  isInline: true,
  withOverrides: withLink,
  options: {
    allowedSchemes: ['http', 'https', 'mailto', 'tel'],
    dangerouslySkipSanitization: false,
    defaultLinkAttributes: {},
    isUrl: plateCommon.isUrl,
    rangeBeforeOptions: {
      matchString: ' ',
      skipInvalid: true,
      afterMatch: true
    },
    triggerFloatingLinkHotkeys: 'meta+k, ctrl+k',
    keepSelectedTextOnPaste: true
  },
  then: (editor, {
    type
  }) => ({
    props: ({
      element
    }) => ({
      nodeProps: getLinkAttributes(editor, element)
    }),
    deserializeHtml: {
      rules: [{
        validNodeName: 'A'
      }],
      getNode: el => {
        const url = el.getAttribute('href');

        if (url && validateUrl(editor, url)) {
          return {
            type,
            url,
            target: el.getAttribute('target') || '_blank'
          };
        }

        return undefined;
      }
    }
  })
});

exports.ELEMENT_LINK = ELEMENT_LINK;
exports.FloatingLink = FloatingLink;
exports.FloatingLinkEditButton = FloatingLinkEditButton;
exports.FloatingLinkEditRoot = FloatingLinkEditRoot;
exports.FloatingLinkInsertRoot = FloatingLinkInsertRoot;
exports.FloatingLinkNewTabInput = FloatingLinkNewTabInput;
exports.FloatingLinkTextInput = FloatingLinkTextInput;
exports.FloatingLinkUrlInput = FloatingLinkUrlInput;
exports.LaunchIcon = LaunchIcon;
exports.Link = Link;
exports.LinkIcon = LinkIcon;
exports.LinkOffIcon = LinkOffIcon;
exports.LinkRoot = LinkRoot;
exports.OpenLinkButton = OpenLinkButton;
exports.ShortTextIcon = ShortTextIcon;
exports.UnlinkButton = UnlinkButton;
exports.createLinkNode = createLinkNode;
exports.createLinkPlugin = createLinkPlugin;
exports.floatingLinkActions = floatingLinkActions;
exports.floatingLinkSelectors = floatingLinkSelectors;
exports.floatingLinkStore = floatingLinkStore;
exports.getLinkAttributes = getLinkAttributes;
exports.insertLink = insertLink;
exports.submitFloatingLink = submitFloatingLink;
exports.triggerFloatingLink = triggerFloatingLink;
exports.triggerFloatingLinkEdit = triggerFloatingLinkEdit;
exports.triggerFloatingLinkInsert = triggerFloatingLinkInsert;
exports.unwrapLink = unwrapLink;
exports.upsertLink = upsertLink;
exports.upsertLinkText = upsertLinkText;
exports.useFloatingLinkEdit = useFloatingLinkEdit;
exports.useFloatingLinkEditButton = useFloatingLinkEditButton;
exports.useFloatingLinkEnter = useFloatingLinkEnter;
exports.useFloatingLinkEscape = useFloatingLinkEscape;
exports.useFloatingLinkInsert = useFloatingLinkInsert;
exports.useFloatingLinkNewTabInput = useFloatingLinkNewTabInput;
exports.useFloatingLinkSelectors = useFloatingLinkSelectors;
exports.useFloatingLinkTextInput = useFloatingLinkTextInput;
exports.useFloatingLinkUrlInput = useFloatingLinkUrlInput;
exports.useLink = useLink;
exports.useOpenLinkButton = useOpenLinkButton;
exports.useUnlinkButton = useUnlinkButton;
exports.useVirtualFloatingLink = useVirtualFloatingLink;
exports.validateUrl = validateUrl;
exports.withLink = withLink;
exports.wrapLink = wrapLink;
//# sourceMappingURL=index.js.map
