{"version":3,"file":"index.js","sources":["../src/createTEditor.ts","../src/interfaces/editor/TEditor.ts","../src/interfaces/editor/addMark.ts","../src/interfaces/editor/createPathRef.ts","../src/interfaces/editor/createPointRef.ts","../src/interfaces/editor/createRangeRef.ts","../src/interfaces/editor/deleteBackward.ts","../src/interfaces/editor/deleteForward.ts","../src/interfaces/editor/deleteFragment.ts","../../../node_modules/lodash/isArray.js","../../../node_modules/lodash/castArray.js","../src/interfaces/element/elementMatches.ts","../src/interfaces/element/isElement.ts","../src/interfaces/element/isElementList.ts","../src/interfaces/editor/isBlock.ts","../src/utils/match.ts","../src/interfaces/editor/getAboveNode.ts","../src/interfaces/editor/unhangRange.ts","../src/interfaces/editor/getNodeEntries.ts","../src/interfaces/editor/getParentNode.ts","../src/interfaces/editor/getPreviousNode.ts","../src/interfaces/editor/isElementEmpty.ts","../src/interfaces/editor/withoutNormalizing.ts","../src/interfaces/text/isText.ts","../src/interfaces/node/hasSingleChild.ts","../src/interfaces/transforms/deleteText.ts","../src/interfaces/transforms/moveNodes.ts","../src/interfaces/transforms/removeNodes.ts","../src/interfaces/transforms/select.ts","../src/interfaces/transforms/mergeNodes.ts","../src/interfaces/editor/getEndPoint.ts","../src/interfaces/editor/getLeafNode.ts","../src/interfaces/editor/getPointAfter.ts","../src/interfaces/editor/getPointBefore.ts","../src/interfaces/editor/getStartPoint.ts","../src/interfaces/editor/getVoidNode.ts","../src/interfaces/editor/isVoid.ts","../src/interfaces/editor/deleteMerge.ts","../src/interfaces/editor/getEdgePoints.ts","../src/interfaces/editor/getEditorString.ts","../src/interfaces/editor/getFirstNode.ts","../src/interfaces/editor/getFragment.ts","../src/interfaces/editor/getLastNode.ts","../src/interfaces/editor/getLevels.ts","../src/interfaces/editor/getMarks.ts","../src/interfaces/editor/getNextNode.ts","../src/interfaces/editor/getNodeEntry.ts","../src/interfaces/editor/getPath.ts","../src/interfaces/editor/getPathRefs.ts","../src/interfaces/editor/getPoint.ts","../src/interfaces/editor/getPointRefs.ts","../src/interfaces/editor/getPositions.ts","../src/interfaces/editor/getRange.ts","../src/interfaces/editor/getRangeRefs.ts","../src/interfaces/editor/hasBlocks.ts","../src/interfaces/editor/hasInlines.ts","../src/interfaces/editor/hasTexts.ts","../src/interfaces/editor/insertBreak.ts","../src/interfaces/editor/insertNode.ts","../src/interfaces/editor/isEdgePoint.ts","../src/interfaces/editor/isEditor.ts","../src/interfaces/editor/isEditorNormalizing.ts","../src/interfaces/editor/isEndPoint.ts","../src/interfaces/editor/isInline.ts","../src/interfaces/editor/isStartPoint.ts","../src/interfaces/editor/normalizeEditor.ts","../src/interfaces/editor/removeEditorMark.ts","../src/interfaces/history-editor/isHistoryEditor.ts","../src/interfaces/history-editor/isHistoryMerging.ts","../src/interfaces/history-editor/isHistorySaving.ts","../src/interfaces/history-editor/withoutMergingHistory.ts","../src/interfaces/history-editor/withoutSavingHistory.ts","../src/interfaces/node/TDescendant.ts","../src/interfaces/node/getCommonNode.ts","../src/interfaces/text/isTextList.ts","../src/interfaces/text/textEquals.ts","../src/interfaces/text/textMatches.ts","../src/interfaces/node/getNode.ts","../src/interfaces/node/getNodeAncestor.ts","../src/interfaces/node/getNodeAncestors.ts","../src/interfaces/node/getNodeChild.ts","../src/interfaces/node/getNodeChildren.ts","../src/interfaces/node/getNodeDescendant.ts","../src/interfaces/node/getNodeDescendants.ts","../src/interfaces/node/getNodeElements.ts","../src/interfaces/node/getNodeFirstNode.ts","../src/interfaces/node/getNodeFragment.ts","../src/interfaces/node/getNodeLastNode.ts","../src/interfaces/node/getNodeLeaf.ts","../src/interfaces/node/getNodeLevels.ts","../src/interfaces/node/getNodeParent.ts","../src/interfaces/node/getNodeProps.ts","../src/interfaces/node/getNodeString.ts","../src/interfaces/node/getNodeTexts.ts","../src/interfaces/node/getNodes.ts","../src/interfaces/node/hasNode.ts","../src/interfaces/node/isAncestor.ts","../src/interfaces/node/isNode.ts","../src/interfaces/node/isNodeList.ts","../src/interfaces/node/nodeMatches.ts","../src/interfaces/range/isCollapsed.ts","../src/interfaces/range/isExpanded.ts","../src/interfaces/transforms/collapseSelection.ts","../src/interfaces/transforms/deselect.ts","../src/interfaces/transforms/insertFragment.ts","../src/interfaces/transforms/insertNodes.ts","../src/interfaces/transforms/insertText.ts","../src/interfaces/transforms/liftNodes.ts","../src/interfaces/transforms/moveSelection.ts","../src/interfaces/transforms/setNodes.ts","../src/interfaces/transforms/setPoint.ts","../src/interfaces/transforms/setSelection.ts","../src/interfaces/transforms/splitNodes.ts","../src/interfaces/transforms/unsetNodes.ts","../src/interfaces/transforms/unwrapNodes.ts","../src/interfaces/transforms/wrapNodes.ts","../src/utils/queryNode.ts","../src/queries/findNode.ts","../src/queries/someNode.ts","../src/transforms/addRangeMarks.ts","../src/transforms/setElements.ts","../src/transforms/unhangCharacterRange.ts"],"sourcesContent":["import { createEditor } from 'slate';\nimport { TEditor, Value } from './interfaces/editor/TEditor';\n\nexport const createTEditor = <V extends Value>() =>\n  (createEditor() as any) as TEditor<V>;\n","import { Modify, UnknownObject } from '@udecode/utils';\nimport { Editor, Path } from 'slate';\nimport { TOperation } from '../../types/TOperation';\nimport { EElement, EElementOrText, TElement } from '../element/TElement';\nimport { TDescendant } from '../node/TDescendant';\nimport { ENode, TNode } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\n\nexport type Value = TElement[];\n\n/**\n * A helper type for getting the value of an editor.\n */\nexport type ValueOf<E extends TEditor> = E['children'];\n\nexport type TEditor<V extends Value = Value> = Modify<\n  Editor,\n  {\n    id: any;\n    children: V;\n    operations: TOperation[];\n    marks: Record<string, any> | null;\n\n    // Schema-specific node behaviors.\n    isInline: <N extends TElement>(element: N) => boolean;\n    isVoid: <N extends TElement>(element: N) => boolean;\n    markableVoid: <N extends TElement>(element: N) => boolean;\n    normalizeNode: <N extends TNode>(entry: TNodeEntry<N>) => void;\n\n    // Overrideable core actions.\n    apply: <N extends TDescendant>(operation: TOperation<N>) => void;\n    getFragment: <N extends TDescendant>() => N[];\n    insertFragment: <N extends TDescendant>(fragment: N[]) => void;\n    insertNode: <N extends TDescendant>(node: N) => void;\n    getDirtyPaths: <N extends TDescendant>(operation: TOperation<N>) => Path[];\n  }\n> &\n  UnknownObject;\n\n/**\n * Get editor with typed methods and operations.\n * Note that it can't be used as a parameter of type TEditor.\n */\nexport const getTEditor = <V extends Value, E extends TEditor<V> = TEditor<V>>(\n  editor: E\n) =>\n  editor as Modify<\n    E,\n    {\n      operations: TOperation<EElementOrText<V>>[];\n\n      // Schema-specific node behaviors.\n      isInline: (element: EElement<V>) => boolean;\n      isVoid: (element: EElement<V>) => boolean;\n      normalizeNode: (entry: TNodeEntry<ENode<V>>) => void;\n\n      // Overrideable core actions.\n      apply: (operation: TOperation<EElementOrText<V>>) => void;\n      getFragment: () => EElementOrText<V>[];\n      insertFragment: (fragment: EElementOrText<V>[]) => void;\n      insertNode: (node: EElementOrText<V> | EElementOrText<V>[]) => void;\n    }\n  >;\n","import { Editor } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Add a custom property to the leaf text nodes in the current selection.\n *\n * If the selection is currently collapsed, the marks will be added to the\n * `editor.marks` property instead, and applied when text is inserted next.\n */\nexport const addMark = <V extends Value>(\n  editor: TEditor<V>,\n  key: string,\n  value: any\n) => Editor.addMark(editor as any, key, value);\n","import { Editor, Path } from 'slate';\nimport { EditorPathRefOptions } from 'slate/dist/interfaces/editor';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Create a mutable ref for a `Path` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createPathRef = <V extends Value>(\n  editor: TEditor<V>,\n  at: Path,\n  options?: EditorPathRefOptions\n) => Editor.pathRef(editor as any, at, options as any);\n","import { Editor, Point } from 'slate';\nimport { EditorPointRefOptions } from 'slate/dist/interfaces/editor';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Create a mutable ref for a `Point` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createPointRef = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point,\n  options?: EditorPointRefOptions\n) => Editor.pointRef(editor as any, point, options as any);\n","import { Editor, Range } from 'slate';\nimport { EditorRangeRefOptions } from 'slate/dist/interfaces/editor';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Create a mutable ref for a `Range` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createRangeRef = <V extends Value>(\n  editor: TEditor<V>,\n  range: Range,\n  options?: EditorRangeRefOptions\n) => Editor.rangeRef(editor as any, range, options as any);\n","import { Editor } from 'slate';\nimport { EditorDirectedDeletionOptions } from 'slate/dist/interfaces/editor';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Delete content in the editor backward from the current selection.\n */\nexport const deleteBackward = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorDirectedDeletionOptions\n) => Editor.deleteBackward(editor as any, options);\n","import { Editor } from 'slate';\nimport { EditorDirectedDeletionOptions } from 'slate/dist/interfaces/editor';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Delete content in the editor forward from the current selection.\n */\nexport const deleteForward = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorDirectedDeletionOptions\n) => Editor.deleteForward(editor as any, options);\n","import { Editor } from 'slate';\nimport { EditorFragmentDeletionOptions } from 'slate/dist/interfaces/editor';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Delete the content in the current selection.\n */\nexport const deleteFragment = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorFragmentDeletionOptions\n) => Editor.deleteFragment(editor as any, options);\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var isArray = require('./isArray');\n\n/**\n * Casts `value` as an array if it's not one.\n *\n * @static\n * @memberOf _\n * @since 4.4.0\n * @category Lang\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast array.\n * @example\n *\n * _.castArray(1);\n * // => [1]\n *\n * _.castArray({ 'a': 1 });\n * // => [{ 'a': 1 }]\n *\n * _.castArray('abc');\n * // => ['abc']\n *\n * _.castArray(null);\n * // => [null]\n *\n * _.castArray(undefined);\n * // => [undefined]\n *\n * _.castArray();\n * // => []\n *\n * var array = [1, 2, 3];\n * console.log(_.castArray(array) === array);\n * // => true\n */\nfunction castArray() {\n  if (!arguments.length) {\n    return [];\n  }\n  var value = arguments[0];\n  return isArray(value) ? value : [value];\n}\n\nmodule.exports = castArray;\n","import { Element } from 'slate';\nimport { TElement } from './TElement';\n\n/**\n * Check if an element matches set of properties.\n *\n * Note: this checks custom properties, and it does not ensure that any\n * children are equivalent.\n */\nexport const elementMatches = (element: TElement, props: object) =>\n  Element.matches(element, props);\n","import { Element } from 'slate';\nimport { TElement } from './TElement';\n\n/**\n * Check if a value implements the 'Element' interface.\n */\nexport const isElement = (value: any): value is TElement =>\n  Element.isElement(value);\n","import { Element } from 'slate';\nimport { TElement } from './TElement';\n\n/**\n * Check if a value is an array of `Element` objects.\n */\nexport const isElementList = (value: any): value is TElement[] =>\n  Element.isElementList(value);\n","import { Editor } from 'slate';\nimport { isElement } from '../element';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a value is a block `Element` object.\n */\nexport const isBlock = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => isElement(value) && Editor.isBlock(editor as any, value);\n","import { castArray } from 'lodash';\nimport { isBlock } from '../interfaces/editor/isBlock';\nimport { TEditor, Value } from '../interfaces/editor/TEditor';\nimport { ENode, TNode } from '../interfaces/node/TNode';\nimport { TPath } from '../types/interfaces';\n\nexport type PredicateObj = Record<string, any | any[]>;\nexport type PredicateFn<T extends TNode> = (obj: T, path: TPath) => boolean;\nexport type Predicate<T extends TNode> = PredicateObj | PredicateFn<T>;\n\n/**\n * Match the object with a predicate object or function.\n * If predicate is:\n * - object: every predicate key/value should be in obj.\n * - function: it should return true.\n */\nexport const match = <T extends TNode>(\n  obj: T,\n  path: TPath,\n  predicate?: Predicate<T>\n): boolean => {\n  if (!predicate) return true;\n\n  if (typeof predicate === 'object') {\n    return Object.entries(predicate).every(([key, value]) => {\n      const values = castArray<any>(value);\n\n      return values.includes(obj[key]);\n    });\n  }\n\n  return predicate(obj, path);\n};\n\n/**\n * Extended query options for slate queries:\n * - `match` can be an object predicate where one of the values should include the node value.\n * Example: { type: ['1', '2'] } will match the nodes having one of these 2 types.\n */\nexport const getQueryOptions = <V extends Value>(\n  editor: TEditor<V>,\n  options: any = {}\n) => {\n  const { match: _match, block } = options;\n\n  return {\n    ...options,\n    match:\n      _match || block\n        ? (n: ENode<V>, path: TPath) =>\n            match(n, path, _match) && (!block || isBlock(editor, n))\n        : undefined,\n  };\n};\n\nexport type ENodeMatch<N extends TNode> = Predicate<N>;\n\nexport interface ENodeMatchOptions<V extends Value = Value> {\n  match?: ENodeMatch<ENode<V>>;\n  block?: boolean;\n}\n","import { Modify } from '@udecode/utils';\nimport { Editor } from 'slate';\nimport { EditorAboveOptions } from 'slate/dist/interfaces/editor';\nimport { ENodeMatchOptions, getQueryOptions } from '../../utils/match';\nimport { EAncestor, TAncestor } from '../node/TAncestor';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\nexport type GetAboveNodeOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorAboveOptions<TAncestor>>,\n  ENodeMatchOptions<V>\n>;\n\n/**\n * Get the ancestor above a location in the document.\n */\nexport const getAboveNode = <N extends EAncestor<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetAboveNodeOptions<V>\n): TNodeEntry<N> | undefined =>\n  Editor.above(editor as any, getQueryOptions(editor, options)) as any;\n","import {\n  Editor,\n  EditorUnhangRangeOptions,\n  Path,\n  Point,\n  Range,\n  Span,\n} from 'slate';\nimport { TRange } from '../../types/interfaces';\nimport { TEditor, Value } from './TEditor';\n\nexport type UnhangRangeOptions = EditorUnhangRangeOptions & {\n  unhang?: boolean;\n};\n\n/**\n * Convert a range into a non-hanging one if:\n * - `unhang` is true,\n * - `at` (default: selection) is a range.\n */\nexport const unhangRange = <V extends Value>(\n  editor: TEditor<V>,\n  range?: Range | Path | Point | Span | null,\n  options: UnhangRangeOptions = {}\n) => {\n  const { voids, unhang = true } = options;\n\n  if (Range.isRange(range) && unhang) {\n    return Editor.unhangRange(editor as any, range, { voids }) as TRange;\n  }\n};\n","import { Modify } from '@udecode/utils';\nimport { Editor, EditorNodesOptions } from 'slate';\nimport { ENodeMatchOptions, getQueryOptions } from '../../utils/match';\nimport { ENode, TNode } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\nimport { unhangRange, UnhangRangeOptions } from './unhangRange';\n\nexport type GetNodeEntriesOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorNodesOptions<TNode>>,\n  ENodeMatchOptions<V>\n> &\n  UnhangRangeOptions;\n\n/**\n * Iterate through all of the nodes in the Editor.\n */\nexport const getNodeEntries = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetNodeEntriesOptions<V>\n): Generator<TNodeEntry<N>, void, undefined> => {\n  unhangRange(editor, options?.at, options);\n\n  return Editor.nodes(editor as any, getQueryOptions(editor, options)) as any;\n};\n","import { Editor, EditorParentOptions, Location } from 'slate';\nimport { EAncestor } from '../node/TAncestor';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the parent node of a location.\n * Returns undefined if there is no parent.\n */\nexport const getParentNode = <N extends EAncestor<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorParentOptions\n): TNodeEntry<N> | undefined => {\n  try {\n    return Editor.parent(editor as any, at, options) as any;\n  } catch (err) {}\n};\n","import { Modify } from '@udecode/utils';\nimport { Editor, EditorPreviousOptions } from 'slate';\nimport { ENode, TNode, TNodeMatch } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\nexport type GetPreviousNodeOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorPreviousOptions<TNode>>,\n  {\n    match?: TNodeMatch<ENode<V>>;\n  }\n>;\n\n/**\n * Get the matching node in the branch of the document before a location.\n */\nexport const getPreviousNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetPreviousNodeOptions<V>\n): TNodeEntry<N> | undefined =>\n  Editor.previous(editor as any, options as any) as any;\n","import { Editor } from 'slate';\nimport { EElement } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if an element is empty, accounting for void nodes.\n */\nexport const isElementEmpty = <V extends Value>(\n  editor: TEditor<V>,\n  element: EElement<V>\n) => Editor.isEmpty(editor as any, element);\n","import { Editor } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Call a function, deferring normalization until after it completes\n * @return true if normalized.\n */\nexport const withoutNormalizing = <V extends Value>(\n  editor: TEditor<V>,\n  fn: () => boolean | void\n) => {\n  let normalized = false;\n\n  Editor.withoutNormalizing(editor as any, () => {\n    normalized = !!fn();\n  });\n\n  return normalized;\n};\n","import { Text } from 'slate';\nimport { TText } from './TText';\n\n/**\n * Check if a value implements the `Text` interface.\n */\nexport const isText = (value: any): value is TText => Text.isText(value);\n","import { isText } from '../text/isText';\nimport { TNode } from './TNode';\n\nexport const hasSingleChild = <N extends TNode>(node: N): boolean => {\n  if (isText(node)) {\n    return true;\n  }\n  return node.children.length === 1 && hasSingleChild(node.children[0]);\n};\n","import { Transforms } from 'slate';\nimport { TextDeleteOptions } from 'slate/dist/interfaces/transforms/text';\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Delete content in the editor.\n */\nexport const deleteText = <V extends Value>(\n  editor: TEditor<V>,\n  options?: TextDeleteOptions\n) => {\n  Transforms.delete(editor as any, options);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type MoveNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.moveNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Move the nodes at a location to a new location.\n */\nexport const moveNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: MoveNodesOptions<V>\n) => Transforms.moveNodes(editor as any, options as any);\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type RemoveNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.removeNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Remove the nodes at a specific location in the document.\n */\nexport const removeNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: RemoveNodesOptions<V>\n) => Transforms.removeNodes(editor as any, options as any);\n","import { Location, Transforms } from 'slate';\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Set the selection to a new value.\n */\nexport const select = <V extends Value>(\n  editor: TEditor<V>,\n  target: Location\n) => {\n  Transforms.select(editor as any, target);\n};\n","import { Modify } from '@udecode/utils';\nimport { Editor, Element, Path, Range, Text, Transforms } from 'slate';\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { createPathRef } from '../editor/createPathRef';\nimport { createPointRef } from '../editor/createPointRef';\nimport { getAboveNode } from '../editor/getAboveNode';\nimport { getNodeEntries } from '../editor/getNodeEntries';\nimport { getParentNode } from '../editor/getParentNode';\nimport { getPreviousNode } from '../editor/getPreviousNode';\nimport { isBlock } from '../editor/isBlock';\nimport { isElementEmpty } from '../editor/isElementEmpty';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { withoutNormalizing } from '../editor/withoutNormalizing';\nimport { isElement } from '../element/isElement';\nimport { hasSingleChild } from '../node/hasSingleChild';\nimport { isText } from '../text/isText';\nimport { deleteText } from './deleteText';\nimport { moveNodes } from './moveNodes';\nimport { removeNodes } from './removeNodes';\nimport { select } from './select';\n\nexport type MergeNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.mergeNodes>[1]>,\n  NodeMatchOption<V>\n> & {\n  /**\n   * Default: if the node isn't already the next sibling of the previous node, move\n   * it so that it is before merging.\n   */\n  mergeNode?: (editor: TEditor<V>, options: { at: Path; to: Path }) => void;\n\n  /**\n   * Default: if there was going to be an empty ancestor of the node that was merged,\n   * we remove it from the tree.\n   */\n  removeEmptyAncestor?: (editor: TEditor<V>, options: { at: Path }) => void;\n};\n\n/**\n * Merge a node at a location with the previous node of the same depth,\n * removing any empty containing nodes after the merge if necessary.\n */\nexport const mergeNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options: MergeNodesOptions<V> = {}\n): void => {\n  withoutNormalizing(editor as any, () => {\n    let { match, at = editor.selection } = options;\n    const {\n      mergeNode,\n      removeEmptyAncestor,\n      hanging = false,\n      voids = false,\n      mode = 'lowest',\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = getParentNode(editor, at)!;\n        match = (n) => parent.children.includes(n as any);\n      } else {\n        match = (n) => isBlock(editor as any, n);\n      }\n    }\n\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor as any, at);\n    }\n\n    if (Range.isRange(at)) {\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        const [, end] = Range.edges(at);\n        const pointRef = createPointRef(editor as any, end);\n        deleteText(editor, { at });\n        at = pointRef.unref()!;\n\n        if (options.at == null) {\n          select(editor as any, at);\n        }\n      }\n    }\n\n    const _nodes = getNodeEntries(editor as any, { at, match, voids, mode });\n    const [current] = Array.from(_nodes);\n    const prev = getPreviousNode(editor as any, { at, match, voids, mode });\n\n    if (!current || !prev) {\n      return;\n    }\n\n    const [node, path] = current;\n    const [prevNode, prevPath] = prev;\n\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n\n    const newPath = Path.next(prevPath);\n    const commonPath = Path.common(path, prevPath);\n    const isPreviousSibling = Path.isSibling(path, prevPath);\n    const _levels = Editor.levels(editor as any, { at: path });\n    const levels = Array.from(_levels, ([n]) => n)\n      .slice(commonPath.length)\n      .slice(0, -1);\n\n    // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n    const emptyAncestor = getAboveNode(editor as any, {\n      at: path,\n      mode: 'highest',\n      match: (n) => levels.includes(n) && isElement(n) && hasSingleChild(n),\n    });\n\n    const emptyRef =\n      emptyAncestor && createPathRef(editor as any, emptyAncestor[1]);\n    let properties;\n    let position;\n\n    // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n    if (isText(node) && isText(prevNode)) {\n      const { text, ...rest } = node;\n      position = prevNode.text.length;\n      properties = rest as Partial<Text>;\n    } else if (isElement(node) && isElement(prevNode)) {\n      const { children, ...rest } = node;\n      position = prevNode.children.length;\n      properties = rest as Partial<Element>;\n    } else {\n      throw new Error(\n        `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n          node\n        )} ${JSON.stringify(prevNode)}`\n      );\n    }\n\n    // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n    if (!isPreviousSibling) {\n      // DIFF\n      if (!mergeNode) {\n        moveNodes(editor, { at: path, to: newPath, voids });\n      }\n    }\n\n    // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n    if (emptyRef) {\n      // DIFF: start\n      if (!removeEmptyAncestor) {\n        removeNodes(editor, { at: emptyRef.current!, voids });\n      } else {\n        const emptyPath = emptyRef.current;\n        emptyPath && removeEmptyAncestor(editor as any, { at: emptyPath });\n      }\n      // DIFF: end\n    }\n\n    // If the target node that we're merging with is empty, remove it instead\n    // of merging the two. This is a common rich text editor behavior to\n    // prevent losing formatting when deleting entire nodes when you have a\n    // hanging selection.\n    // DIFF: start\n    if (mergeNode) {\n      mergeNode(editor as any, { at: path, to: newPath });\n      // DIFF: end\n    } else if (\n      (isElement(prevNode) && isElementEmpty(editor as any, prevNode)) ||\n      (isText(prevNode) && prevNode.text === '')\n    ) {\n      removeNodes(editor, { at: prevPath, voids });\n    } else {\n      editor.apply({\n        type: 'merge_node',\n        path: newPath,\n        position,\n        properties,\n      });\n    }\n\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n  });\n};\n","import { Editor, Location } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the end point of a location.\n */\nexport const getEndPoint = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n) => Editor.end(editor as any, at);\n","import { Editor, Location } from 'slate';\nimport { EditorLeafOptions } from 'slate/dist/interfaces/editor';\nimport { ETextEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the leaf text node at a location.\n */\nexport const getLeafNode = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorLeafOptions\n): ETextEntry<V> => Editor.leaf(editor as any, at, options) as any;\n","import { Editor, EditorAfterOptions, Location } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the point after a location.\n */\nexport const getPointAfter = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorAfterOptions\n) => Editor.after(editor as any, at, options);\n","import { Editor, EditorBeforeOptions, Location } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the point before a location.\n */\nexport const getPointBefore = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorBeforeOptions\n) => Editor.before(editor as any, at, options);\n","import { Editor, Location } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the start point of a location.\n */\nexport const getStartPoint = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n) => Editor.start(editor as any, at);\n","import { Editor, EditorVoidOptions } from 'slate';\nimport { EElement } from '../element/TElement';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Match a void node in the current branch of the editor.\n */\nexport const getVoidNode = <N extends EElement<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: EditorVoidOptions\n): TNodeEntry<N> | undefined => Editor.void(editor as any, options) as any;\n","import { Editor } from 'slate';\nimport { isElement } from '../element';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a value is a void `Element` object.\n */\nexport const isVoid = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => {\n  return isElement(value) && Editor.isVoid(editor as any, value);\n};\n","import { Editor, Location, Path, Point, Range } from 'slate';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { mergeNodes } from '../transforms/mergeNodes';\nimport { removeNodes } from '../transforms/removeNodes';\nimport { select } from '../transforms/select';\nimport { createPathRef } from './createPathRef';\nimport { createPointRef } from './createPointRef';\nimport { getAboveNode } from './getAboveNode';\nimport { getEndPoint } from './getEndPoint';\nimport { getLeafNode } from './getLeafNode';\nimport { getNodeEntries } from './getNodeEntries';\nimport { getPointAfter } from './getPointAfter';\nimport { getPointBefore } from './getPointBefore';\nimport { getStartPoint } from './getStartPoint';\nimport { getVoidNode } from './getVoidNode';\nimport { isBlock } from './isBlock';\nimport { isVoid } from './isVoid';\nimport { TEditor, Value } from './TEditor';\nimport { withoutNormalizing } from './withoutNormalizing';\n\nexport const deleteMerge = <V extends Value>(\n  editor: TEditor<V>,\n  options: {\n    at?: Location;\n    distance?: number;\n    unit?: 'character' | 'word' | 'line' | 'block';\n    reverse?: boolean;\n    hanging?: boolean;\n    voids?: boolean;\n    test?: any;\n  } = {}\n): void => {\n  withoutNormalizing(editor as any, () => {\n    const {\n      reverse = false,\n      unit = 'character',\n      distance = 1,\n      voids = false,\n    } = options;\n    let { at = editor.selection, hanging = false } = options;\n\n    if (!at) {\n      return;\n    }\n\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      at = at.anchor;\n    }\n\n    if (Point.isPoint(at)) {\n      const furthestVoid = getVoidNode(editor as any, { at, mode: 'highest' });\n\n      if (!voids && furthestVoid) {\n        const [, voidPath] = furthestVoid;\n        at = voidPath;\n      } else {\n        const opts = { unit, distance };\n        const target = reverse\n          ? getPointBefore(editor as any, at, opts) ||\n            getStartPoint(editor as any, [])\n          : getPointAfter(editor as any, at, opts) ||\n            getEndPoint(editor as any, []);\n        at = { anchor: at, focus: target };\n        hanging = true;\n      }\n    }\n\n    if (Path.isPath(at)) {\n      removeNodes(editor, { at, voids });\n      return;\n    }\n\n    if (Range.isCollapsed(at)) {\n      return;\n    }\n\n    if (!hanging) {\n      at = Editor.unhangRange(editor as any, at, { voids });\n    }\n\n    let [start, end] = Range.edges(at);\n    const startBlock = getAboveNode(editor, {\n      match: (n) => isBlock(editor as any, n),\n      at: start,\n      voids,\n    });\n    const endBlock = getAboveNode(editor, {\n      match: (n) => isBlock(editor as any, n),\n      at: end,\n      voids,\n    });\n    const isAcrossBlocks =\n      startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n    const isSingleText = Path.equals(start.path, end.path);\n    const startVoid = voids\n      ? null\n      : getVoidNode(editor as any, { at: start, mode: 'highest' });\n    const endVoid = voids\n      ? null\n      : getVoidNode(editor as any, { at: end, mode: 'highest' });\n\n    // If the start or end points are inside an inline void, nudge them out.\n    if (startVoid) {\n      const before = getPointBefore(editor as any, start);\n\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start = before;\n      }\n    }\n\n    if (endVoid) {\n      const after = getPointAfter(editor as any, end);\n\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    }\n\n    // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n    const matches: TNodeEntry[] = [];\n    let lastPath: Path | undefined;\n\n    const _nodes = getNodeEntries(editor as any, { at, voids });\n    for (const entry of _nodes) {\n      const [node, path] = entry;\n\n      if (lastPath && Path.compare(path, lastPath) === 0) {\n        continue;\n      }\n\n      if (\n        (!voids && isVoid(editor as any, node)) ||\n        (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n      ) {\n        matches.push(entry as any);\n        lastPath = path;\n      }\n    }\n\n    const pathRefs = Array.from(matches, ([, p]) =>\n      createPathRef(editor as any, p)\n    );\n    const startRef = createPointRef(editor as any, start);\n    const endRef = createPointRef(editor as any, end);\n\n    if (!isSingleText && !startVoid) {\n      const point = startRef.current!;\n      const [node] = getLeafNode(editor as any, point);\n      const { path } = point;\n      const { offset } = start;\n      const text = node.text.slice(offset);\n      editor.apply({ type: 'remove_text', path, offset, text });\n    }\n\n    for (const pathRef of pathRefs) {\n      const path = pathRef.unref()!;\n      removeNodes(editor, { at: path, voids });\n    }\n\n    if (!endVoid) {\n      const point = endRef.current!;\n      const [node] = getLeafNode(editor as any, point);\n      const { path } = point;\n      const offset = isSingleText ? start.offset : 0;\n      const text = node.text.slice(offset, end.offset);\n      editor.apply({ type: 'remove_text', path, offset, text });\n    }\n\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      // DIFF: allow custom mergeNodes\n      mergeNodes(editor as any, {\n        at: endRef.current,\n        hanging: true,\n        voids,\n      });\n    }\n\n    const point = endRef.unref() || startRef.unref();\n\n    if (options.at == null && point) {\n      select(editor as any, point);\n    }\n  });\n};\n","import { Editor, Location } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the start and end points of a location.\n */\nexport const getEdgePoints = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n) => Editor.edges(editor as any, at);\n","import { Editor, Location } from 'slate';\nimport { EditorStringOptions } from 'slate/dist/interfaces/editor';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the text string content of a location.\n *\n * Note: by default the text of void nodes is considered to be an empty\n * string, regardless of content, unless you pass in true for the voids option\n */\nexport const getEditorString = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location | null | undefined,\n  options?: EditorStringOptions\n) => {\n  if (!at) return '';\n\n  try {\n    return Editor.string(editor as any, at, options);\n  } catch (error) {\n    return '';\n  }\n};\n","import { Editor, Location } from 'slate';\nimport { ENodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the first node at a location.\n */\nexport const getFirstNode = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n): ENodeEntry<V> => Editor.first(editor as any, at) as any;\n","import { Editor, Location } from 'slate';\nimport { EElementOrText } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the fragment at a location.\n */\nexport const getFragment = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n): EElementOrText<V>[] => Editor.fragment(editor as any, at) as any;\n","import { Editor, Location } from 'slate';\nimport { ENodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the last node at a location.\n */\nexport const getLastNode = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location\n): ENodeEntry<V> => Editor.last(editor as any, at) as any;\n","import { Modify } from '@udecode/utils';\nimport { Editor, EditorLevelsOptions } from 'slate';\nimport { ENode, TNode, TNodeMatch } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\nexport type GetLevelsOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorLevelsOptions<TNode>>,\n  {\n    match?: TNodeMatch<ENode<V>>;\n  }\n>;\n\n/**\n * Iterate through all of the levels at a location.\n */\nexport const getLevels = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetLevelsOptions<V>\n): Generator<TNodeEntry<N>, void, undefined> =>\n  Editor.levels(editor as any, options as any) as any;\n","import { Editor } from 'slate';\nimport { EMarks } from '../text/TText';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the marks that would be added to text at the current selection.\n */\nexport const getMarks = <V extends Value>(editor: TEditor<V>) =>\n  Editor.marks(editor as any) as EMarks<V> | null;\n","import { Modify } from '@udecode/utils';\nimport { Editor, EditorNextOptions } from 'slate';\nimport { TDescendant } from '../node';\nimport { ENode, TNodeMatch } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\nexport type GetNextNodeOptions<V extends Value = Value> = Modify<\n  NonNullable<EditorNextOptions<TDescendant>>,\n  {\n    match?: TNodeMatch<ENode<V>>;\n  }\n>;\n\n/**\n * Get the matching node in the branch of the document after a location.\n */\nexport const getNextNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options?: GetNextNodeOptions<V>\n): TNodeEntry<N> | undefined =>\n  Editor.next(editor as any, options as any) as any;\n","import { Editor, EditorNodeOptions, Location } from 'slate';\nimport { ENode } from '../node/TNode';\nimport { TNodeEntry } from '../node/TNodeEntry';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the node at a location.\n */\nexport const getNodeEntry = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorNodeOptions\n): TNodeEntry<N> | undefined => {\n  try {\n    return Editor.node(editor as any, at, options) as any;\n  } catch (err) {}\n};\n","import { Editor, EditorPathOptions, Location } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the path of a location.\n */\nexport const getPath = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorPathOptions\n) => Editor.path(editor as any, at, options as any);\n","import { Editor } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the set of currently tracked path refs of the editor.\n */\nexport const getPathRefs = <V extends Value>(editor: TEditor<V>) =>\n  Editor.pathRefs(editor as any);\n","import { Editor, EditorPointOptions, Location } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the start or end point of a location.\n */\nexport const getPoint = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  options?: EditorPointOptions\n) => Editor.point(editor as any, at, options);\n","import { Editor } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the set of currently tracked point refs of the editor.\n */\nexport const getPointRefs = <V extends Value>(editor: TEditor<V>) =>\n  Editor.pointRefs(editor as any);\n","import { Editor, EditorPositionsOptions } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Iterate through all of the positions in the document where a `Point` can be\n * placed.\n *\n * By default it will move forward by individual offsets at a time,  but you\n * can pass the `unit: 'character'` option to moved forward one character, word,\n * or line at at time.\n *\n * Note: By default void nodes are treated as a single point and iteration\n * will not happen inside their content unless you pass in true for the\n * voids option, then iteration will occur.\n */\nexport const getPositions = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorPositionsOptions\n) => Editor.positions(editor as any, options);\n","import { Editor, Location } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get a range of a location.\n */\nexport const getRange = <V extends Value>(\n  editor: TEditor<V>,\n  at: Location,\n  to?: Location\n) => Editor.range(editor as any, at, to);\n","import { Editor } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Get the set of currently tracked range refs of the editor.\n */\nexport const getRangeRefs = <V extends Value>(editor: TEditor<V>) =>\n  Editor.rangeRefs(editor as any);\n","import { Editor } from 'slate';\nimport { TElement } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a node has block children.\n */\nexport const hasBlocks = <V extends Value>(\n  editor: TEditor<V>,\n  element: TElement\n) => Editor.hasBlocks(editor as any, element);\n","import { Editor } from 'slate';\nimport { TElement } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a node has inline and text children.\n */\nexport const hasInlines = <V extends Value>(\n  editor: TEditor<V>,\n  element: TElement\n) => Editor.hasInlines(editor as any, element);\n","import { Editor } from 'slate';\nimport { TElement } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a node has text children.\n */\nexport const hasTexts = <V extends Value>(\n  editor: TEditor<V>,\n  element: TElement\n) => Editor.hasTexts(editor as any, element);\n","import { Editor } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Insert a block break at the current selection.\n *\n * If the selection is currently expanded, it will be deleted first.\n */\nexport const insertBreak = <V extends Value>(editor: TEditor<V>) =>\n  Editor.insertBreak(editor as any);\n","import { Editor } from 'slate';\nimport { EElementOrText } from '../element/TElement';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Insert a node at the current selection.\n *\n * If the selection is currently expanded, it will be deleted first.\n */\nexport const insertNode = <V extends Value>(\n  editor: TEditor<V>,\n  node: EElementOrText<V> | EElementOrText<V>[]\n) => Editor.insertNode(editor as any, node as any);\n","import { Editor, Location, Point } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a point is an edge of a location.\n */\nexport const isEdgePoint = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point,\n  at: Location\n) => Editor.isEdge(editor as any, point, at);\n","import { Editor } from 'slate';\nimport { TEditor } from './TEditor';\n\n/**\n * Check if a value is an `Editor` object.\n */\nexport const isEditor = (value: any): value is TEditor =>\n  Editor.isEditor(value);\n","import { Editor } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if the editor is currently normalizing after each operation.\n */\nexport const isEditorNormalizing = <V extends Value>(editor: TEditor<V>) =>\n  Editor.isNormalizing(editor as any);\n","import { Editor, Location, Point } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a point is the end point of a location.\n * If point is null, return false.\n */\nexport const isEndPoint = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point | null | undefined,\n  at: Location\n) => !!point && Editor.isEnd(editor as any, point, at);\n","import { Editor } from 'slate';\nimport { isElement } from '../element';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a value is an inline `Element` object.\n */\nexport const isInline = <V extends Value>(\n  editor: TEditor<V>,\n  value: any\n): boolean => isElement(value) && Editor.isInline(editor as any, value);\n","import { Editor, Location, Point } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Check if a point is the start point of a location.\n * If point is null, return false.\n */\nexport const isStartPoint = <V extends Value>(\n  editor: TEditor<V>,\n  point: Point | null | undefined,\n  at: Location\n) => !!point && Editor.isStart(editor as any, point, at);\n","import { Editor, EditorNormalizeOptions } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Normalize any dirty objects in the editor.\n */\nexport const normalizeEditor = <V extends Value>(\n  editor: TEditor<V>,\n  options?: EditorNormalizeOptions\n) => Editor.normalize(editor as any, options);\n","import { Editor } from 'slate';\nimport { TEditor, Value } from './TEditor';\n\n/**\n * Remove a custom property from all of the leaf text nodes in the current\n * selection.\n *\n * If the selection is currently collapsed, the removal will be stored on\n * `editor.marks` and applied to the text inserted next.\n */\nexport const removeEditorMark = <V extends Value>(\n  editor: TEditor<V>,\n  key: string\n) => Editor.removeMark(editor as any, key);\n","import { HistoryEditor } from 'slate-history';\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.isHistoryEditor}\n */\nexport const isHistoryEditor = (value: any): value is THistoryEditor =>\n  HistoryEditor.isHistoryEditor(value as any);\n","import { HistoryEditor } from 'slate-history';\nimport { Value } from '../editor/TEditor';\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.isMerging}\n */\nexport const isHistoryMerging = <V extends Value>(editor: THistoryEditor<V>) =>\n  HistoryEditor.isMerging(editor as any);\n","import { HistoryEditor } from 'slate-history';\nimport { Value } from '../editor/TEditor';\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.isSaving}\n */\nexport const isHistorySaving = <V extends Value>(editor: THistoryEditor<V>) =>\n  HistoryEditor.isSaving(editor as any);\n","import { HistoryEditor } from 'slate-history';\nimport { Value } from '../editor/TEditor';\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.withoutMerging}\n */\nexport const withoutMergingHistory = <V extends Value>(\n  editor: THistoryEditor<V>,\n  fn: () => void\n) => HistoryEditor.withoutMerging(editor as any, fn);\n","import { HistoryEditor } from 'slate-history';\nimport { Value } from '../editor/TEditor';\nimport { THistoryEditor } from './THistoryEditor';\n\n/**\n * {@link HistoryEditor.withoutSaving}\n */\nexport const withoutSavingHistory = <V extends Value>(\n  editor: THistoryEditor<V>,\n  fn: () => void\n) => HistoryEditor.withoutSaving(editor as any, fn);\n","import { TEditor, Value } from '../editor/TEditor';\nimport { isElement } from '../element/isElement';\nimport { ElementOf, TElement } from '../element/TElement';\nimport { isText } from '../text/isText';\nimport { TextOf, TText } from '../text/TText';\nimport { TNode } from './TNode';\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\nexport type TDescendant = TElement | TText;\n\n/**\n * Descendant of an editor.\n */\nexport type EDescendant<V extends Value> = DescendantOf<TEditor<V>>;\n\n/**\n * A utility type to get all the descendant node types from a root node type.\n */\nexport type DescendantOf<N extends TNode> = N extends TEditor\n  ? ElementOf<N> | TextOf<N>\n  : N extends TElement\n  ? ElementOf<N['children'][number]> | TextOf<N>\n  : never;\n\n/**\n * A utility type to get the child node types from a root node type.\n */\nexport type ChildOf<\n  N extends TNode,\n  I extends number = number\n> = N extends TEditor\n  ? N['children'][I]\n  : N extends TElement\n  ? N['children'][I]\n  : never;\n\nexport const isDescendant: (value: any) => value is TDescendant = ((\n  node: any\n) => isElement(node) || isText(node)) as any;\n","import { Node, Path } from 'slate';\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Get an entry for the common ancesetor node of two paths.\n */\nexport const getCommonNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  another: Path\n) => Node.common(root, path, another) as TNodeEntry<N>;\n","import { Text } from 'slate';\nimport { TText } from './TText';\n\n/**\n * Check if a value is a list of `Text` objects.\n */\nexport const isTextList = (value: any): value is TText[] =>\n  Text.isTextList(value);\n","import { Text } from 'slate';\nimport { TText } from './TText';\n\n/**\n * Check if two text nodes are equal.\n */\nexport const textEquals = (text: TText, another: TText) =>\n  Text.equals(text, another);\n","import { Text } from 'slate';\nimport { TText } from './TText';\n\n/**\n * Check if an text matches set of properties.\n *\n * Note: this is for matching custom properties, and it does not ensure that\n * the `text` property are two nodes equal.\n */\nexport const textMatches = <T extends TText>(text: T, props: object) =>\n  Text.matches(text, props);\n","import { Path } from 'slate';\nimport { isText } from '../text';\nimport { NodeOf, TNode } from './TNode';\n\n/**\n * Get the descendant node referred to by a specific path.\n * If the path is an empty array, it refers to the root node itself.\n * If the node is not found, return null.\n * Based on Slate get and has, performance optimization without overhead of\n * stringify on throwing\n */\nexport const getNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => {\n  try {\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i];\n\n      if (isText(root) || !root.children[p]) {\n        return null;\n      }\n\n      root = root.children[p] as R;\n    }\n\n    return root as N;\n  } catch (e) {\n    return null;\n  }\n};\n","import { Node, Path } from 'slate';\nimport { AncestorOf } from './TAncestor';\nimport { TNode } from './TNode';\n\n/**\n * Get the node at a specific path, asserting that it's an ancestor node.\n */\nexport const getNodeAncestor = <\n  N extends AncestorOf<R>,\n  R extends TNode = TNode\n>(\n  root: R,\n  path: Path\n) => Node.ancestor(root, path) as N;\n","import { Node, NodeAncestorsOptions, Path } from 'slate';\nimport { AncestorOf } from './TAncestor';\nimport { TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the ancestor nodes above a specific path.\n *\n * By default the order is bottom-up, from lowest to highest ancestor in\n * the tree, but you can pass the `reverse: true` option to go top-down.\n */\nexport const getNodeAncestors = <\n  N extends AncestorOf<R>,\n  R extends TNode = TNode\n>(\n  root: R,\n  path: Path,\n  options?: NodeAncestorsOptions\n) =>\n  Node.ancestors(root, path, options) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Node } from 'slate';\nimport { ChildOf } from './TDescendant';\nimport { TNode } from './TNode';\n\n/**\n * Get the child of a node at a specific index.\n */\nexport const getNodeChild = <\n  N extends ChildOf<R, I>,\n  R extends TNode = TNode,\n  I extends number = number\n>(\n  root: R,\n  index: I\n) => Node.child(root, index) as N;\n","import { Node, NodeChildrenOptions, Path } from 'slate';\nimport { ChildOf } from './TDescendant';\nimport { TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Iterate over the children of a node at a specific path.\n */\nexport const getNodeChildren = <N extends ChildOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  options?: NodeChildrenOptions\n) =>\n  Node.children(root, path, options) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Node, Path } from 'slate';\nimport { DescendantOf } from './TDescendant';\nimport { TNode } from './TNode';\n\n/**\n * Get the node at a specific path, asserting that it's a descendant node.\n */\nexport const getNodeDescendant = <\n  N extends DescendantOf<R>,\n  R extends TNode = TNode\n>(\n  root: R,\n  path: Path\n) => Node.descendant(root, path) as N;\n","import { Modify } from '@udecode/utils';\nimport { Node, NodeDescendantsOptions } from 'slate';\nimport { DescendantOf } from './TDescendant';\nimport { TNode } from './TNode';\nimport { TDescendantEntry, TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the descendant node entries inside a root node.\n */\nexport const getNodeDescendants = <\n  N extends DescendantOf<R>,\n  R extends TNode = TNode\n>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeDescendantsOptions>,\n    {\n      pass?: (node: TDescendantEntry<N>) => boolean;\n    }\n  >\n) =>\n  Node.descendants(root, options as any) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Modify } from '@udecode/utils';\nimport { Node, NodeElementsOptions } from 'slate';\nimport { ElementOf } from '../element/TElement';\nimport { TNode } from './TNode';\nimport { TElementEntry, TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the element nodes inside a root node. Each iteration\n * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n * root node is an element it will be included in the iteration as well.\n */\nexport const getNodeElements = <\n  N extends ElementOf<R>,\n  R extends TNode = TNode\n>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeElementsOptions>,\n    {\n      pass?: (node: TElementEntry<N>) => boolean;\n    }\n  >\n) =>\n  Node.elements(root, options as any) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Node, Path } from 'slate';\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Get the first node entry in a root node from a path.\n */\nexport const getNodeFirstNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.first(root, path) as TNodeEntry<N>;\n","import { Node, Range } from 'slate';\nimport { ElementOf } from '../element/TElement';\nimport { TextOf } from '../text/TText';\nimport { TNode } from './TNode';\n\n/**\n * Get the sliced fragment represented by a range inside a root node.\n */\nexport const getNodeFragment = <\n  N extends ElementOf<R> | TextOf<R>,\n  R extends TNode = TNode\n>(\n  root: R,\n  range: Range\n) => Node.fragment(root, range) as Array<N>;\n","import { Node, Path } from 'slate';\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Get the last node entry in a root node from a path.\n */\nexport const getNodeLastNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.last(root, path) as TNodeEntry<N>;\n","import { Node, Path } from 'slate';\nimport { TextOf } from '../text/TText';\nimport { TNode } from './TNode';\n\n/**\n * Get the node at a specific path, ensuring it's a leaf text node.\n */\nexport const getNodeLeaf = <N extends TextOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.leaf(root, path) as N;\n","import { Node, NodeLevelsOptions, Path } from 'slate';\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of the in a branch of the tree, from a specific path.\n *\n * By default the order is top-down, from lowest to highest node in the tree,\n * but you can pass the `reverse: true` option to go bottom-up.\n */\nexport const getNodeLevels = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  options?: NodeLevelsOptions\n) =>\n  Node.levels(root, path, options) as Generator<TNodeEntry<N>, void, undefined>;\n","import { Node, Path } from 'slate';\nimport { AncestorOf } from './TAncestor';\nimport { TNode } from './TNode';\n\n/**\n * Get the parent of a node at a specific path.\n */\nexport const getNodeParent = <N extends AncestorOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.parent(root, path) as N;\n","import { Node } from 'slate';\nimport { TNode, TNodeProps } from './TNode';\n\n/**\n * Extract the custom properties from a node.\n */\nexport const getNodeProps = <N extends TNode>(node: N) =>\n  Node.extractProps(node) as TNodeProps<N>;\n","import { Node } from 'slate';\nimport { TNode } from './TNode';\n\n/**\n * Get the concatenated text string of a node's content.\n *\n * Note that this will not include spaces or line breaks between block nodes.\n * It is not a user-facing string, but a string for performing offset-related\n * computations for a node.\n */\nexport const getNodeString = (node: TNode) => Node.string(node);\n","import { Modify } from '@udecode/utils';\nimport { Node, NodeTextsOptions } from 'slate';\nimport { TextOf } from '../text/TText';\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all leaf text nodes in a root node.\n */\nexport const getNodeTexts = <N extends TextOf<R>, R extends TNode = TNode>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeTextsOptions>,\n    {\n      pass?: (entry: TNodeEntry<NodeOf<N>>) => boolean;\n    }\n  >\n) =>\n  Node.texts(root, options as any) as Generator<TNodeEntry<N>, void, undefined>;\n","import { Modify } from '@udecode/utils';\nimport { Node, NodeNodesOptions } from 'slate';\nimport { NodeOf, TNode } from './TNode';\nimport { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the node entries of a root node. Each entry is\n * returned as a `[Node, Path]` tuple, with the path referring to the node's\n * position inside the root node.\n */\nexport const getNodes = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeNodesOptions>,\n    {\n      pass?: (entry: TNodeEntry<NodeOf<N>>) => boolean;\n    }\n  >\n) =>\n  Node.nodes(root, options as any) as Generator<TNodeEntry<N>, void, undefined>;\n","import { Node, Path } from 'slate';\nimport { TNode } from './TNode';\n\n/**\n * Check if a descendant node exists at a specific path.\n */\nexport const hasNode = (root: TNode, path: Path) => Node.has(root, path);\n","import { Element } from 'slate';\nimport { TAncestor } from './TAncestor';\n\n/**\n * Check if a value implements the 'Ancestor' interface.\n */\nexport const isAncestor = (value: any): value is TAncestor =>\n  Element.isAncestor(value);\n","import { Node } from 'slate';\nimport { TNode } from './TNode';\n\n/**\n * Check if a value implements the `Node` interface.\n */\nexport const isNode = (value: any): value is TNode => Node.isNode(value);\n","import { Node } from 'slate';\nimport { TNode } from './TNode';\n\n/**\n * Check if a value is a list of `Node` objects.\n */\nexport const isNodeList = (value: any): value is TNode[] =>\n  Node.isNodeList(value);\n","import { Node } from 'slate';\nimport { TNode } from './TNode';\n\n/**\n * Check if a node matches a set of props.\n */\nexport const nodeMatches = (node: TNode, props: object) =>\n  Node.matches(node, props);\n","import { Range } from 'slate';\n\n/**\n * See {@link Range.isCollapsed}.\n * Return false if `range` is not defined.\n */\nexport const isCollapsed = (range?: Range | null) =>\n  !!range && Range.isCollapsed(range);\n","import { Range } from 'slate';\n\n/**\n * See {@link Range.isExpanded}.\n * Return false if `range` is not defined.\n */\nexport const isExpanded = (range?: Range | null) =>\n  !!range && Range.isExpanded(range);\n","import { Transforms } from 'slate';\nimport { SelectionCollapseOptions } from 'slate/dist/interfaces/transforms/selection';\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Collapse the selection.\n */\nexport const collapseSelection = <V extends Value>(\n  editor: TEditor<V>,\n  options?: SelectionCollapseOptions\n) => {\n  Transforms.collapse(editor as any, options);\n};\n","import { Transforms } from 'slate';\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Unset the selection.\n */\nexport const deselect = <V extends Value>(editor: TEditor<V>) => {\n  Transforms.deselect(editor as any);\n};\n","import { Transforms } from 'slate';\nimport { TextInsertFragmentOptions } from 'slate/dist/interfaces/transforms/text';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { EElementOrText } from '../element/TElement';\n\n/**\n * Insert a fragment at a specific location in the editor.\n */\nexport const insertFragment = <\n  N extends EElementOrText<V>,\n  V extends Value = Value\n>(\n  editor: TEditor<V>,\n  fragment: N[],\n  options?: TextInsertFragmentOptions\n) => {\n  Transforms.insertFragment(editor as any, fragment, options);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { EElementOrText } from '../element/TElement';\n\nexport type InsertNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.insertNodes>[2]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Insert nodes at a specific location in the Editor.\n */\nexport const insertNodes = <\n  N extends EElementOrText<V>,\n  V extends Value = Value\n>(\n  editor: TEditor<V>,\n  nodes: N | N[],\n  options?: InsertNodesOptions<V>\n) => Transforms.insertNodes(editor as any, nodes, options as any);\n","import { Transforms } from 'slate';\nimport { TextInsertTextOptions } from 'slate/dist/interfaces/transforms/text';\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Insert a string of text in the Editor.\n */\nexport const insertText = <V extends Value>(\n  editor: TEditor<V>,\n  text: string,\n  options?: TextInsertTextOptions\n) => {\n  Transforms.insertText(editor as any, text, options);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type LiftNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.liftNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Lift nodes at a specific location upwards in the document tree, splitting\n * their parent in two if necessary.\n */\nexport const liftNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: LiftNodesOptions<V>\n) => Transforms.liftNodes(editor as any, options as any);\n","import { Transforms } from 'slate';\nimport { SelectionMoveOptions } from 'slate/dist/interfaces/transforms/selection';\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Move the selection's point forward or backward.\n */\nexport const moveSelection = <V extends Value>(\n  editor: TEditor<V>,\n  options?: SelectionMoveOptions\n) => {\n  Transforms.move(editor as any, options);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { ENode, TNodeProps } from '../node/TNode';\n\nexport type SetNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.setNodes>[2]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Set new properties on the nodes at a location.\n */\nexport const setNodes = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  props: Partial<TNodeProps<N>>,\n  options?: SetNodesOptions<V>\n) => Transforms.setNodes(editor as any, props, options as any);\n","import { Point, Transforms } from 'slate';\nimport { SelectionSetPointOptions } from 'slate/dist/interfaces/transforms/selection';\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Set new properties on one of the selection's points.\n */\nexport const setPoint = <V extends Value>(\n  editor: TEditor<V>,\n  props: Partial<Point>,\n  options?: SelectionSetPointOptions\n) => {\n  Transforms.setPoint(editor as any, props, options);\n};\n","import { Range, Transforms } from 'slate';\nimport { TEditor, Value } from '../editor/TEditor';\n\n/**\n * Set new properties on the selection.\n */\nexport const setSelection = <V extends Value>(\n  editor: TEditor<V>,\n  props: Partial<Range>\n) => {\n  Transforms.setSelection(editor as any, props);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type SplitNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.splitNodes>[1]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Split the nodes at a specific location.\n */\nexport const splitNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: SplitNodesOptions<V>\n) => Transforms.splitNodes(editor as any, options as any);\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { ENode, TNodeProps } from '../node/TNode';\n\nexport type UnsetNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.unsetNodes>[2]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Unset properties on the nodes at a location.\n */\nexport const unsetNodes = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  props: keyof TNodeProps<N> | (keyof TNodeProps<N>)[],\n  options?: UnsetNodesOptions<V>\n) => {\n  return Transforms.unsetNodes(editor as any, props as any, options as any);\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\nimport { ENodeMatchOptions, getQueryOptions } from '../../utils/match';\nimport { TEditor, Value } from '../editor/TEditor';\n\nexport type UnwrapNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.unwrapNodes>[1]>,\n  ENodeMatchOptions<V>\n>;\n\n/**\n * Unwrap the nodes at a location from a parent node, splitting the parent if\n * necessary to ensure that only the content in the range is unwrapped.\n */\nexport const unwrapNodes = <V extends Value>(\n  editor: TEditor<V>,\n  options?: UnwrapNodesOptions<V>\n) => {\n  Transforms.unwrapNodes(editor as any, getQueryOptions(editor, options));\n};\n","import { Modify } from '@udecode/utils';\nimport { Transforms } from 'slate';\nimport { NodeMatchOption } from '../../types/NodeMatchOption';\nimport { TEditor, Value } from '../editor/TEditor';\nimport { unhangRange } from '../editor/unhangRange';\nimport { EElement } from '../element/TElement';\n\nexport type WrapNodesOptions<V extends Value = Value> = Modify<\n  NonNullable<Parameters<typeof Transforms.wrapNodes>[2]>,\n  NodeMatchOption<V>\n>;\n\n/**\n * Wrap the nodes at a location in a new container node, splitting the edges\n * of the range first to ensure that only the content in the range is wrapped.\n */\nexport const wrapNodes = <N extends EElement<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  element: N,\n  options?: WrapNodesOptions<V>\n) => {\n  unhangRange(editor, options?.at, options);\n\n  Transforms.wrapNodes(editor as any, element as any, options as any);\n};\n","import castArray from 'lodash/castArray';\nimport { TNode, TNodeEntry } from '../interfaces';\nimport { QueryNodeOptions } from '../types/QueryNodeOptions';\n\n/**\n * Query the node entry.\n */\nexport const queryNode = <N extends TNode>(\n  entry?: TNodeEntry<N>,\n  { filter, allow, exclude, level, maxLevel }: QueryNodeOptions = {}\n) => {\n  if (!entry) return false;\n\n  const [node, path] = entry;\n\n  if (level) {\n    const levels = castArray(level);\n\n    if (!levels.includes(path.length)) {\n      return false;\n    }\n  }\n\n  if (maxLevel) {\n    if (path.length > maxLevel) {\n      return false;\n    }\n  }\n\n  if (filter && !filter(entry)) {\n    return false;\n  }\n\n  if (allow) {\n    const allows = castArray(allow);\n\n    if (allows.length && !allows.includes(node.type as any)) {\n      return false;\n    }\n  }\n\n  if (exclude) {\n    const excludes = castArray(exclude);\n\n    if (excludes.length && excludes.includes(node.type as any)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n","import {\n  ENode,\n  getNodeEntries,\n  GetNodeEntriesOptions,\n  TEditor,\n  TNodeEntry,\n  Value,\n} from '../interfaces';\nimport { getQueryOptions } from '../utils';\n\nexport type FindNodeOptions<V extends Value = Value> = GetNodeEntriesOptions<V>;\n\n/**\n * Find node matching the condition.\n */\nexport const findNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options: FindNodeOptions<V> = {}\n): TNodeEntry<N> | undefined => {\n  // Slate throws when things aren't found so we wrap in a try catch and return undefined on throw.\n  try {\n    const nodeEntries = getNodeEntries<N, V>(editor, {\n      at: editor.selection || [],\n      ...getQueryOptions(editor, options),\n    });\n\n    for (const [node, path] of nodeEntries) {\n      return [node, path];\n    }\n  } catch (error) {\n    return undefined;\n  }\n};\n","import { ENode, TEditor, Value } from '../interfaces';\nimport { findNode, FindNodeOptions } from './findNode';\n\n/**\n * Iterate through all of the nodes in the editor and break early for the first truthy match. Otherwise\n * returns false.\n */\nexport const someNode = <N extends ENode<V>, V extends Value = Value>(\n  editor: TEditor<V>,\n  options: FindNodeOptions<V>\n) => {\n  return !!findNode<N, V>(editor, options);\n};\n","import { Editor, Location, Node, Path, Range, Text, Transforms } from 'slate';\nimport { getRange } from '../interfaces';\nimport { TEditor, Value } from '../interfaces/editor/TEditor';\n\n/**\n * Add marks to each node of a range.\n */\nexport const addRangeMarks = <V extends Value>(\n  editor: TEditor<V>,\n  props: any,\n  {\n    at = editor.selection,\n  }: {\n    at?: Location | null;\n  } = {}\n) => {\n  if (at) {\n    if (Path.isPath(at)) {\n      at = getRange(editor as any, at);\n    }\n\n    const match = (node: Node, path: Path) => {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n      const parentEntry = Editor.parent(editor as any, path);\n      if (!parentEntry) return false;\n\n      const [parentNode] = parentEntry;\n\n      return (\n        !editor.isVoid(parentNode as any) ||\n        editor.markableVoid(parentNode as any)\n      );\n    };\n    const isExpandedRange = Range.isExpanded(at as Range);\n    let markAcceptingVoidSelected = false;\n    if (!isExpandedRange) {\n      const selectedEntry = Editor.node(editor as any, at);\n      if (!selectedEntry) return;\n\n      const [selectedNode, selectedPath] = selectedEntry;\n\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        const parentEntry = Editor.parent(editor as any, selectedPath);\n        if (!parentEntry) return;\n\n        const [parentNode] = parentEntry;\n\n        markAcceptingVoidSelected =\n          parentNode && editor.markableVoid(parentNode as any);\n      }\n    }\n    if (isExpandedRange || markAcceptingVoidSelected) {\n      Transforms.setNodes(editor as any, props, {\n        match,\n        split: true,\n        voids: true,\n        at,\n      });\n    }\n    // else {\n    //   const marks = {\n    //     ...(Editor.marks(editor as any) || {}),\n    //     [key]: value,\n    //   };\n    //\n    //   editor.marks = marks;\n    //   if (!FLUSHING.get(editor as any)) {\n    //     editor.onChange();\n    //   }\n    // }\n  }\n};\n","import { TEditor, TElement, TNodeProps, Value } from '../interfaces';\nimport { setNodes, SetNodesOptions } from '../interfaces/transforms/setNodes';\n\nexport const setElements = <V extends Value>(\n  editor: TEditor<V>,\n  props: Partial<TNodeProps<TElement>>,\n  options?: SetNodesOptions\n) => setNodes<TElement>(editor, props, options);\n","import { Path, Range } from 'slate';\nimport { getPointAfter, getPointBefore, TEditor, Value } from '../interfaces';\n\n/**\n * Unhang the range of length 1 so both edges are in the same text node.\n */\nexport const unhangCharacterRange = <V extends Value>(\n  editor: TEditor<V>,\n  at: Range\n) => {\n  let [start, end] = Range.edges(at);\n\n  if (!Path.equals(start.path, end.path)) {\n    if (end.offset === 0) {\n      const pointAfter = getPointAfter(editor, start);\n      if (pointAfter) {\n        end = pointAfter;\n      }\n    } else {\n      const pointBefore = getPointBefore(editor, end);\n      if (pointBefore) {\n        start = pointBefore;\n      }\n    }\n  }\n\n  return { anchor: start, focus: end };\n};\n"],"names":["createTEditor","createEditor","getTEditor","editor","addMark","key","value","Editor","createPathRef","at","options","pathRef","createPointRef","point","pointRef","createRangeRef","range","rangeRef","deleteBackward","deleteForward","deleteFragment","isArray","elementMatches","element","props","Element","matches","isElement","isElementList","isBlock","match","obj","path","predicate","Object","entries","every","values","_castArray","includes","getQueryOptions","_match","block","n","undefined","getAboveNode","above","unhangRange","voids","unhang","Range","isRange","getNodeEntries","nodes","getParentNode","parent","err","getPreviousNode","previous","isElementEmpty","isEmpty","withoutNormalizing","fn","normalized","isText","Text","hasSingleChild","node","children","length","deleteText","Transforms","delete","moveNodes","removeNodes","select","target","mergeNodes","selection","mergeNode","removeEmptyAncestor","hanging","mode","Path","isPath","isCollapsed","anchor","end","edges","unref","_nodes","current","Array","from","prev","prevNode","prevPath","newPath","next","commonPath","common","isPreviousSibling","isSibling","_levels","levels","slice","emptyAncestor","emptyRef","properties","position","text","rest","Error","JSON","stringify","to","emptyPath","apply","type","getEndPoint","getLeafNode","leaf","getPointAfter","after","getPointBefore","before","getStartPoint","start","getVoidNode","void","isVoid","deleteMerge","reverse","unit","distance","Point","isPoint","furthestVoid","voidPath","opts","focus","startBlock","endBlock","isAcrossBlocks","equals","isSingleText","startVoid","endVoid","isAncestor","lastPath","entry","compare","isCommon","push","pathRefs","p","startRef","endRef","offset","getEdgePoints","getEditorString","string","error","getFirstNode","first","getFragment","fragment","getLastNode","last","getLevels","getMarks","marks","getNextNode","getNodeEntry","getPath","getPathRefs","getPoint","getPointRefs","pointRefs","getPositions","positions","getRange","getRangeRefs","rangeRefs","hasBlocks","hasInlines","hasTexts","insertBreak","insertNode","isEdgePoint","isEdge","isEditor","isEditorNormalizing","isNormalizing","isEndPoint","isEnd","isInline","isStartPoint","isStart","normalizeEditor","normalize","removeEditorMark","removeMark","isHistoryEditor","HistoryEditor","isHistoryMerging","isMerging","isHistorySaving","isSaving","withoutMergingHistory","withoutMerging","withoutSavingHistory","withoutSaving","isDescendant","getCommonNode","root","another","Node","isTextList","textEquals","textMatches","getNode","i","e","getNodeAncestor","ancestor","getNodeAncestors","ancestors","getNodeChild","index","child","getNodeChildren","getNodeDescendant","descendant","getNodeDescendants","descendants","getNodeElements","elements","getNodeFirstNode","getNodeFragment","getNodeLastNode","getNodeLeaf","getNodeLevels","getNodeParent","getNodeProps","extractProps","getNodeString","getNodeTexts","texts","getNodes","hasNode","has","isNode","isNodeList","nodeMatches","isExpanded","collapseSelection","collapse","deselect","insertFragment","insertNodes","insertText","liftNodes","moveSelection","move","setNodes","setPoint","setSelection","splitNodes","unsetNodes","unwrapNodes","wrapNodes","queryNode","filter","allow","exclude","level","maxLevel","castArray","allows","excludes","findNode","nodeEntries","someNode","addRangeMarks","parentEntry","parentNode","markableVoid","isExpandedRange","markAcceptingVoidSelected","selectedEntry","selectedNode","selectedPath","split","setElements","unhangCharacterRange","pointAfter","pointBefore"],"mappings":"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"}