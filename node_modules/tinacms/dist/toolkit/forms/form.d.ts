import { FormApi, Config, FormState } from 'final-form';
import type { FormSubscription } from 'final-form';
import type { Plugin } from '../core';
import { Field, AnyField } from './field';
export type { FormApi };
declare type GlobalOptions = {
    global: true;
    icon?: any;
    layout?: 'fullscreen' | 'popup';
};
export interface FormOptions<S, F extends Field = AnyField> extends Config<S> {
    id: any;
    label: string;
    fields?: F[];
    __type?: string;
    reset?(): void;
    actions?: any[];
    global?: GlobalOptions;
    buttons?: {
        save: string;
        reset: string;
    };
    loadInitialValues?: () => Promise<S>;
    onChange?(values: FormState<S>): void;
    extraSubscribeValues?: FormSubscription;
    queries?: string[];
    crudType?: 'create' | 'update';
    relativePath?: string;
}
export declare class Form<S = any, F extends Field = AnyField> implements Plugin {
    private _reset;
    __type: string;
    id: any;
    label: string;
    fields: F[];
    finalForm: FormApi<S>;
    actions: any[];
    buttons: {
        save: string;
        reset: string;
    };
    queries: string[];
    global: GlobalOptions | null;
    loading: boolean;
    relativePath: string;
    crudType?: 'create' | 'update';
    constructor({ id, label, fields, actions, buttons, global, reset, loadInitialValues, onChange, queries, ...options }: FormOptions<S, F>);
    /**
     * A unique identifier for Forms.
     *
     * @deprecated use id instead
     */
    get name(): any;
    /**
     * Returns the current values of the form.
     *
     * if the form is still loading it returns `undefined`.
     */
    get values(): S | undefined;
    /**
     * The values the form was initialized with.
     */
    get initialValues(): Partial<S>;
    get pristine(): boolean;
    get dirty(): boolean;
    get submitting(): boolean;
    get valid(): boolean;
    /**
     * Resets the values back to the initial values the form was initialized with.
     * Or empties all the values if the form was not initialized.
     */
    reset(): Promise<void>;
    /**
     * @deprecated Unnecessary indirection
     */
    updateFields(fields: F[]): void;
    /**
     * Subscribes to changes to the form. The subscriber will only be called when
     * values specified in subscription change. A form can have many subscribers.
     */
    subscribe: FormApi<S>['subscribe'];
    onSubmit: Config<S>['onSubmit'];
    private handleSubmit;
    /**
     * Submits the form if there are currently no validation errors. It may
     * return undefined or a Promise depending on the nature of the onSubmit
     * configuration value given to the form when it was created.
     */
    submit: FormApi<S>['submit'];
    /**
     * Changes the value of the given field.
     *
     * @param name
     * @param value
     */
    change(name: keyof S, value?: any): void;
    get mutators(): Record<string, (...args: any[]) => any>;
    addQuery(queryId: string): void;
    removeQuery(queryId: string): void;
    /**
     * Updates multiple fields in the form.
     *
     * The updates are batched so that it only triggers one `onChange` event.
     *
     * In order to prevent disruptions to the user's editing experience this
     * function will _not_ update the value of any field that is currently
     * being edited.
     *
     * @param values
     */
    updateValues(values: S): void;
    /**
     * Replaces the initialValues of the form without deleting the current values.
     *
     * This function is helpful when the initialValues are loaded asynchronously.
     *
     * @param initialValues
     */
    updateInitialValues(initialValues: S): void;
    /**
     * Based on field's name this function will
     * return an array of fields for the give form along
     * with the path that it was found at top nearest
     * object-like group
     *
     * So if you have a field named blocks.3.title
     * It will return the fields from the 3rd "block"
     * along with the path it was found at
     * fields: [{type: 'string', name: 'title'}, ... other fields]
     * activePath: ['blocks', '3']
     */
    getActiveField(fieldName: string | null): {
        label?: string;
        name?: string;
        fields: Field[];
    };
    private getFieldGroup;
}
