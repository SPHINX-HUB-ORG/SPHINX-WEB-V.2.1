import { TokenObject } from '../auth/authenticate';
import { BranchData, EventBus } from '@tinacms/toolkit';
import { DocumentNode, GraphQLSchema } from 'graphql';
import gql from 'graphql-tag';
import { TinaSchema, Schema } from '@tinacms/schema-tools';
import { TinaCloudProject } from './types';
import { SearchClient } from '@tinacms/search/dist/index-client';
export declare type OnLoginFunc = (args: {
    token: TokenObject;
}) => Promise<void>;
export declare type TinaIOConfig = {
    assetsApiUrlOverride?: string;
    frontendUrlOverride?: string;
    identityApiUrlOverride?: string;
    contentApiUrlOverride?: string;
};
interface ServerOptions {
    schema?: Schema;
    clientId: string;
    branch: string;
    tinaGraphQLVersion: string;
    customContentApiUrl?: string;
    getTokenFn?: () => Promise<TokenObject>;
    tinaioConfig?: TinaIOConfig;
    tokenStorage?: 'MEMORY' | 'LOCAL_STORAGE' | 'CUSTOM';
}
/**
 * The function you pass to `asyncPoll` should return a promise
 * that resolves with object that satisfies this interface.
 *
 * The `done` property indicates to the async poller whether to
 * continue polling or not.
 *
 * When done is `true` that means you've got what you need
 * and the poller will resolve with `data`.
 *
 * When done is `false` taht means you don't have what you need
 * and the poller will continue polling.
 */
export interface AsyncData<T> {
    done: boolean;
    data?: T;
}
/**
 * Your custom function you provide to the async poller should
 * satisfy this interface. Your function returns a promise that
 * resolves with `AsyncData` to indicate to the poller whether
 * you have what you need or we should continue polling.
 */
export interface AsyncFunction<T> extends Function {
    (): PromiseLike<AsyncData<T>>;
}
/**
* How to repeatedly call an async function until get a desired result.
*
* Inspired by the following gist:
* https://gist.github.com/twmbx/2321921670c7e95f6fad164fbdf3170e#gistcomment-3053587
* https://davidwalsh.name/javascript-polling
*
* Usage:
  asyncPoll(
      async (): Promise<AsyncData<any>> => {
          try {
              const result = await getYourAsyncResult();
              if (result.isWhatYouWant) {
                  return Promise.resolve({
                      done: true,
                      data: result,
                  });
              } else {
                  return Promise.resolve({
                      done: false
                  });
              }
          } catch (err) {
              return Promise.reject(err);
          }
      },
      500,    // interval
      15000,  // timeout
  );
*/
export declare function asyncPoll<T>(
/**
 * Function to call periodically until it resolves or rejects.
 *
 * It should resolve as soon as possible indicating if it found
 * what it was looking for or not. If not then it will be reinvoked
 * after the `pollInterval` if we haven't timed out.
 *
 * Rejections will stop the polling and be propagated.
 */
fn: AsyncFunction<T>, 
/**
 * Milliseconds to wait before attempting to resolve the promise again.
 * The promise won't be called concurrently. This is the wait period
 * after the promise has resolved/rejected before trying again for a
 * successful resolve so long as we haven't timed out.
 *
 * Default 5 seconds.
 */
pollInterval?: number, 
/**
 * Max time to keep polling to receive a successful resolved response.
 * If the promise never resolves before the timeout then this method
 * rejects with a timeout error.
 *
 * Default 30 seconds.
 */
pollTimeout?: number): (Promise<T> | (() => void))[];
export declare class Client {
    onLogin?: OnLoginFunc;
    onLogout?: () => Promise<void>;
    frontendUrl: string;
    contentApiUrl: string;
    identityApiUrl: string;
    assetsApiUrl: string;
    gqlSchema: GraphQLSchema;
    schema?: TinaSchema;
    clientId: string;
    contentApiBase: string;
    tinaGraphQLVersion: string;
    setToken: (_token: TokenObject) => void;
    private getToken;
    token: string;
    branch: string;
    private options;
    events: EventBus;
    protectedBranches: string[];
    usingEditorialWorkflow: boolean;
    constructor({ tokenStorage, ...options }: ServerOptions);
    get isLocalMode(): boolean;
    get isCustomContentApi(): boolean;
    setBranch(branchName: string): void;
    getBranch(): string;
    addPendingContent: (props: any) => Promise<any>;
    getSchema: () => Promise<GraphQLSchema>;
    /**
     *
     * Returns a version of the query with fragments inlined. Eg.
     * ```graphql
     * {
     *   getPostDocument(relativePath: "") {
     *     data {
     *       ...PostFragment
     *     }
     *   }
     * }
     *
     * fragment PostFragment on Post {
     *   title
     * }
     * ```
     * Turns into
     * ```graphql
     * {
     *   getPostDocument(relativePath: "") {
     *     data {
     *       title
     *     }
     *   }
     * }
     */
    getOptimizedQuery: (documentNode: DocumentNode) => Promise<DocumentNode>;
    request<ReturnType>(query: ((gqlTag: typeof gql) => DocumentNode) | string, { variables }: {
        variables: object;
    }): Promise<ReturnType>;
    get appDashboardLink(): string;
    checkSyncStatus({ assetsSyncing, }: {
        assetsSyncing: string[];
    }): Promise<{
        assetsSyncing: string[];
    }>;
    getProject(): Promise<TinaCloudProject>;
    createPullRequest({ baseBranch, branch, title, }: {
        baseBranch: string;
        branch: string;
        title: string;
    }): Promise<any>;
    fetchEvents(limit?: number, cursor?: string): Promise<{
        events: {
            message: string;
            timestamp: number;
            id: string;
            isError: boolean;
            isGlobal: boolean;
        }[];
        cursor?: string;
    }>;
    parseJwt(token: any): any;
    getRefreshedToken(tokens: string): Promise<TokenObject>;
    isAuthorized(context?: any): Promise<boolean>;
    isAuthenticated(): Promise<boolean>;
    logout(): Promise<void>;
    authenticate(): Promise<TokenObject>;
    authorize(context?: any): Promise<any>;
    /**
     * Wraps the normal fetch function with same API but adds the authorization header token.
     *
     * @example
     * const test = await tinaCloudClient.fetchWithToken(`/mycustomAPI/thing/one`) // the token will be passed in the authorization header
     *
     * @param input fetch function input
     * @param init fetch function init
     */
    fetchWithToken(input: RequestInfo, init?: RequestInit): Promise<Response>;
    getUser(): Promise<any>;
    getBillingState(): Promise<{
        clientId: string;
        delinquencyDate: number;
        billingState: 'current' | 'late' | 'delinquent';
    }>;
    waitForIndexStatus({ ref }: {
        ref: string;
    }): (Promise<any> | (() => void))[];
    getIndexStatus({ ref }: {
        ref: string;
    }): Promise<{
        status?: "unknown" | "complete" | "failed" | "inprogress";
        timestamp?: number;
    }>;
    listBranches(args?: {
        includeIndexStatus?: boolean;
    }): Promise<[{
        name?: string;
        protected?: boolean;
        githubPullRequestUrl?: string;
    }, ...{
        name?: string;
        protected?: boolean;
        githubPullRequestUrl?: string;
    }[]] | {
        indexStatus: {
            status?: "unknown" | "complete" | "failed" | "inprogress";
            timestamp?: number;
        };
        name?: string;
        protected?: boolean;
        githubPullRequestUrl?: string;
    }[]>;
    usingProtectedBranch(): boolean;
    createBranch({ baseBranch, branchName }: BranchData): Promise<string>;
}
export declare const DEFAULT_LOCAL_TINA_GQL_SERVER_URL = "http://localhost:4001/graphql";
export declare class LocalClient extends Client {
    constructor(props?: {
        customContentApiUrl?: string;
        schema?: Schema;
    } & Omit<ServerOptions, 'clientId' | 'branch' | 'tinaGraphQLVersion'>);
    get isLocalMode(): boolean;
    logout(): Promise<void>;
    authenticate(): Promise<{
        access_token: string;
        id_token: string;
        refresh_token: string;
    }>;
    getUser(): Promise<boolean>;
}
export declare class TinaCMSSearchClient implements SearchClient {
    private client;
    private tinaSearchConfig?;
    constructor(client: Client, tinaSearchConfig?: {
        stopwordLanguages?: string[];
    });
    query(query: string, options?: {
        limit?: number;
        cursor?: string;
    }): Promise<{
        results: any[];
        nextCursor: string | null;
        total: number;
        prevCursor: string | null;
    }>;
    del(ids: string[]): Promise<any>;
    put(docs: any[]): Promise<any>;
    supportsClientSideIndexing(): boolean;
}
export declare class LocalSearchClient implements SearchClient {
    private client;
    constructor(client: Client);
    query(query: string, options?: {
        limit?: number;
        cursor?: string;
    }): Promise<{
        results: any[];
        nextCursor: string | null;
        total: number;
        prevCursor: string | null;
    }>;
    del(ids: string[]): Promise<any>;
    put(docs: any[]): Promise<any>;
    supportsClientSideIndexing(): boolean;
}
export {};
