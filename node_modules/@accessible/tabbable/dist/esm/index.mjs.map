{"version":3,"file":"index.mjs","sources":["../../src/index.ts"],"sourcesContent":["// Credit:\n// https://github.com/davidtheclark/tabbable\nconst candidateSelector =\n  'input,select,textarea,a[href],button,[tabindex],' +\n  'audio[controls],video[controls],' +\n  '[contenteditable]:not([contenteditable=\"false\"])'\n\nexport interface Tabbables {\n  documentOrder: number\n  tabIndex: number\n  node: HTMLElement | HTMLInputElement\n}\n\nconst matches: Element['matches'] =\n  typeof Element === 'undefined'\n    ? () => false\n    : Element.prototype.matches ||\n      // @ts-ignore\n      Element.prototype.msMatchesSelector ||\n      Element.prototype.webkitMatchesSelector\n\nconst tabbable = (el: HTMLElement, includeRootNode = false): HTMLElement[] => {\n  const regularTabbables: HTMLElement[] = []\n  const orderedTabbables: Tabbables[] = []\n\n  let candidates: HTMLElement[] | NodeListOf<HTMLElement> = el.querySelectorAll(\n    candidateSelector\n  )\n\n  if (includeRootNode && matches.call(el, candidateSelector)) {\n    candidates = Array.prototype.slice.apply(candidates) as HTMLElement[]\n    candidates.unshift(el)\n  }\n\n  let i, candidate, candidateTabindex\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i]\n    if (!isNodeMatchingSelectorTabbable(candidate)) continue\n    candidateTabindex = getTabindex(candidate)\n\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate)\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      })\n    }\n  }\n\n  return orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map((a) => a.node)\n    .concat(regularTabbables)\n}\n\nconst isNodeMatchingSelectorTabbable = (node: HTMLElement) =>\n  !(\n    !isNodeMatchingSelectorFocusable(node) ||\n    (node.tagName === 'INPUT' &&\n      (node as HTMLInputElement).type === 'radio' &&\n      !isTabbableRadio(node as HTMLInputElement)) ||\n    getTabindex(node) < 0\n  )\n\nconst isNodeMatchingSelectorFocusable = (node: HTMLElement) =>\n  !(\n    (node as HTMLInputElement).disabled ||\n    (isInput(node) && (node as HTMLInputElement).type === 'hidden') ||\n    // offsetParent being null will allow detecting cases where an element\n    // is invisible or inside an invisible element,  as long as the element\n    // does not use position: fixed. For them, their visibility has to be\n    // checked directly as well.\n    node.offsetParent === null ||\n    getComputedStyle(node).visibility === 'hidden'\n  )\n\nconst getTabindex = (node: HTMLElement) => {\n  const tabindexAttr = parseInt(node.getAttribute('tabindex') || '', 10)\n  if (!isNaN(tabindexAttr)) return tabindexAttr\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (node.contentEditable === 'true') return 0\n  return node.tabIndex\n}\n\n// @ts-ignore\nconst sortOrderedTabbables = (a: Tabbables, b: Tabbables) =>\n  a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex\n\nconst isInput = (node: HTMLElement) => node.tagName === 'INPUT'\n\nconst isTabbableRadio = (node: HTMLInputElement) => {\n  if (!node.name) return true\n  // This won't account for the edge case where you have radio groups with the\n  // same in separate forms on the same page.\n  if (node.ownerDocument) {\n    const radioSet = node.ownerDocument.querySelectorAll(\n      'input[type=\"radio\"][name=\"' + node.name + '\"]'\n    )\n\n    for (let i = 0; i < radioSet.length; i++)\n      if ((radioSet[i] as HTMLInputElement).checked) return radioSet[i] === node\n\n    return true\n  }\n\n  return false\n}\n\nexport default tabbable\n"],"names":["a","node","candidateSelector","matches","Element","prototype","msMatchesSelector","webkitMatchesSelector","isNodeMatchingSelectorFocusable","disabled","isInput","type","offsetParent","getComputedStyle","visibility","getTabindex","tabindexAttr","parseInt","getAttribute","isNaN","contentEditable","tabIndex","sortOrderedTabbables","b","documentOrder","tagName","isTabbableRadio","name","ownerDocument","radioSet","querySelectorAll","i","length","checked","el","includeRootNode","candidate","candidateTabindex","regularTabbables","orderedTabbables","candidates","call","Array","slice","apply","unshift","push","sort","map","concat"],"mappings":"AAqDS,WAACA,UAAMA,EAAEC,KAnDlB,IAAMC,EACJ,mIAUIC,EACe,oBAAZC,QACH,IAAM,EACNA,QAAQC,UAAUF,SAElBC,QAAQC,UAAUC,mBAClBF,QAAQC,UAAUE,sBA+ClBC,EAAmCP,KAEpCA,EAA0BQ,UAC1BC,EAAQT,IAA6C,WAAnCA,EAA0BU,MAKvB,OAAtBV,EAAKW,cACiC,WAAtCC,iBAAiBZ,GAAMa,YAGrBC,EAAed,QACbe,EAAeC,SAAShB,EAAKiB,aAAa,aAAe,GAAI,WAC9DC,MAAMH,GAGkB,SAAzBf,EAAKmB,gBAAmC,EACrCnB,EAAKoB,SAJqBL,GAQ7BM,EAAuB,CAACtB,EAAcuB,IAC1CvB,EAAEqB,WAAaE,EAAEF,SACbrB,EAAEwB,cAAgBD,EAAEC,cACpBxB,EAAEqB,SAAWE,EAAEF,SAEfX,EAAWT,GAAuC,UAAjBA,EAAKwB,QAEtCC,EAAmBzB,QAClBA,EAAK0B,KAAM,OAAO,KAGnB1B,EAAK2B,cAAe,SAChBC,EAAW5B,EAAK2B,cAAcE,iBAClC,6BAA+B7B,EAAK0B,KAAO,MAGpCI,EAAI,EAAGA,EAAIF,EAASG,OAAQD,OAC9BF,EAASE,GAAwBE,QAAS,OAAOJ,EAASE,KAAO9B,SAEjE,SAGF,kBAzFQ,SAACiC,EAAiBC,YAAAA,IAAAA,EAAkB,OAa/CJ,EAAGK,EAAWC,EAuBoBpC,EAnChCqC,EAAkC,GAClCC,EAAgC,GAElCC,EAAsDN,EAAGJ,iBAC3D5B,OAGEiC,GAAmBhC,EAAQsC,KAAKP,EAAIhC,KACtCsC,EAAaE,MAAMrC,UAAUsC,MAAMC,MAAMJ,IAC9BK,QAAQX,GAIhBH,EAAI,EAAGA,EAAIS,EAAWR,OAAQD,IACjCK,EAAYI,EAAWT,GAuBtBvB,EAFmCP,EApBAmC,KAuBlB,UAAjBnC,EAAKwB,SACgC,UAAnCxB,EAA0BU,MAC1Be,EAAgBzB,KACnBc,EAAYd,IAAQ,IAvBM,KAF1BoC,EAAoBtB,EAAYqB,IAG9BE,EAAiBQ,KAAKV,GAEtBG,EAAiBO,KAAK,CACpBtB,cAAeO,EACfV,SAAUgB,EACVpC,KAAMmC,YAKLG,EACJQ,KAAKzB,GACL0B,OACAC,OAAOX"}