(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.tabbable = factory());
}(this, (function () { 'use strict';

  // Credit:
  // https://github.com/davidtheclark/tabbable
  var candidateSelector = 'input,select,textarea,a[href],button,[tabindex],' + 'audio[controls],video[controls],' + '[contenteditable]:not([contenteditable="false"])';
  var matches = typeof Element === 'undefined' ? function () {
    return false;
  } : Element.prototype.matches || // @ts-ignore
  Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

  function _ref(a) {
    return a.node;
  }

  var tabbable = function tabbable(el, includeRootNode) {
    if (includeRootNode === void 0) {
      includeRootNode = false;
    }

    var regularTabbables = [];
    var orderedTabbables = [];
    var candidates = el.querySelectorAll(candidateSelector);

    if (includeRootNode && matches.call(el, candidateSelector)) {
      candidates = Array.prototype.slice.apply(candidates);
      candidates.unshift(el);
    }

    var i, candidate, candidateTabindex;

    for (i = 0; i < candidates.length; i++) {
      candidate = candidates[i];
      if (!isNodeMatchingSelectorTabbable(candidate)) continue;
      candidateTabindex = getTabindex(candidate);

      if (candidateTabindex === 0) {
        regularTabbables.push(candidate);
      } else {
        orderedTabbables.push({
          documentOrder: i,
          tabIndex: candidateTabindex,
          node: candidate
        });
      }
    }

    return orderedTabbables.sort(sortOrderedTabbables).map(_ref).concat(regularTabbables);
  };

  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(node) {
    return !(!isNodeMatchingSelectorFocusable(node) || node.tagName === 'INPUT' && node.type === 'radio' && !isTabbableRadio(node) || getTabindex(node) < 0);
  };

  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(node) {
    return !(node.disabled || isInput(node) && node.type === 'hidden' || // offsetParent being null will allow detecting cases where an element
    // is invisible or inside an invisible element,  as long as the element
    // does not use position: fixed. For them, their visibility has to be
    // checked directly as well.
    node.offsetParent === null || getComputedStyle(node).visibility === 'hidden');
  };

  var getTabindex = function getTabindex(node) {
    var tabindexAttr = parseInt(node.getAttribute('tabindex') || '', 10);
    if (!isNaN(tabindexAttr)) return tabindexAttr; // Browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.

    if (node.contentEditable === 'true') return 0;
    return node.tabIndex;
  }; // @ts-ignore


  var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
    return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
  };

  var isInput = function isInput(node) {
    return node.tagName === 'INPUT';
  };

  var isTabbableRadio = function isTabbableRadio(node) {
    if (!node.name) return true; // This won't account for the edge case where you have radio groups with the
    // same in separate forms on the same page.

    if (node.ownerDocument) {
      var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');

      for (var i = 0; i < radioSet.length; i++) {
        if (radioSet[i].checked) return radioSet[i] === node;
      }

      return true;
    }

    return false;
  };

  return tabbable;

})));
//# sourceMappingURL=tabbable.dev.js.map
