(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
  typeof define === 'function' && define.amd ? define(['react'], factory) :
  (global = global || self, global.useConditionalFocus = factory(global.React));
}(this, (function (React) { 'use strict';

  // Credit:
  // https://github.com/davidtheclark/tabbable
  var candidateSelector = 'input,select,textarea,a[href],button,[tabindex],' + 'audio[controls],video[controls],' + '[contenteditable]:not([contenteditable="false"])';
  var matches = typeof Element === 'undefined' ? function () {
    return false;
  } : Element.prototype.matches || // @ts-ignore
  Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

  function _ref(a) {
    return a.node;
  }

  var tabbable = function tabbable(el, includeRootNode) {
    if (includeRootNode === void 0) {
      includeRootNode = false;
    }

    var regularTabbables = [];
    var orderedTabbables = [];
    var candidates = el.querySelectorAll(candidateSelector);

    if (includeRootNode && matches.call(el, candidateSelector)) {
      candidates = Array.prototype.slice.apply(candidates);
      candidates.unshift(el);
    }

    var i, candidate, candidateTabindex;

    for (i = 0; i < candidates.length; i++) {
      candidate = candidates[i];
      if (!isNodeMatchingSelectorTabbable(candidate)) continue;
      candidateTabindex = getTabindex(candidate);

      if (candidateTabindex === 0) {
        regularTabbables.push(candidate);
      } else {
        orderedTabbables.push({
          documentOrder: i,
          tabIndex: candidateTabindex,
          node: candidate
        });
      }
    }

    return orderedTabbables.sort(sortOrderedTabbables).map(_ref).concat(regularTabbables);
  };

  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(node) {
    return !(!isNodeMatchingSelectorFocusable(node) || node.tagName === 'INPUT' && node.type === 'radio' && !isTabbableRadio(node) || getTabindex(node) < 0);
  };

  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(node) {
    return !(node.disabled || isInput(node) && node.type === 'hidden' || // offsetParent being null will allow detecting cases where an element
    // is invisible or inside an invisible element,  as long as the element
    // does not use position: fixed. For them, their visibility has to be
    // checked directly as well.
    node.offsetParent === null || getComputedStyle(node).visibility === 'hidden');
  };

  var getTabindex = function getTabindex(node) {
    var tabindexAttr = parseInt(node.getAttribute('tabindex') || '', 10);
    if (!isNaN(tabindexAttr)) return tabindexAttr; // Browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.

    if (node.contentEditable === 'true') return 0;
    return node.tabIndex;
  }; // @ts-ignore


  var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
    return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
  };

  var isInput = function isInput(node) {
    return node.tagName === 'INPUT';
  };

  var isTabbableRadio = function isTabbableRadio(node) {
    if (!node.name) return true; // This won't account for the edge case where you have radio groups with the
    // same in separate forms on the same page.

    if (node.ownerDocument) {
      var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');

      for (var i = 0; i < radioSet.length; i++) {
        if (radioSet[i].checked) return radioSet[i] === node;
      }

      return true;
    }

    return false;
  };

  var usePassiveLayoutEffect = React[typeof document !== 'undefined' && document.createElement !== void 0 ? 'useLayoutEffect' : 'useEffect'];

  var useLatest = function useLatest(current) {
    var storedValue = React.useRef(current);
    storedValue.current = current;
    return storedValue;
  };

  function useEvent(target, type, listener, cleanup) {
    var storedListener = useLatest(listener);
    var storedCleanup = useLatest(cleanup);
    usePassiveLayoutEffect(function () {
      var targetEl = target && 'current' in target ? target.current : target;
      if (!targetEl) return;
      var didUnsubscribe = 0;

      function listener() {
        if (didUnsubscribe) return;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        storedListener.current.apply(this, args);
      }

      targetEl.addEventListener(type, listener);
      var cleanup = storedCleanup.current;
      return function () {
        didUnsubscribe = 1;
        targetEl.removeEventListener(type, listener);
        cleanup && cleanup();
      }; // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [target, type]);
  }

  function useConditionalFocus(target, shouldFocus, _temp) {
    if (shouldFocus === void 0) {
      shouldFocus = false;
    }

    var _ref = _temp === void 0 ? defaultOptions : _temp,
        includeRoot = _ref.includeRoot,
        preventScroll = _ref.preventScroll;

    var didFocus = React.useRef(false);
    var didFocusAfterEvent = React.useRef(false);
    React.useEffect(function () {
      var element = target && 'current' in target ? target.current : target;
      if (!element || !shouldFocus || didFocus.current) return;
      var tabbableEls = tabbable(element, includeRoot);
      if (tabbableEls.length > 0) tabbableEls[0].focus({
        preventScroll: preventScroll
      });
      didFocus.current = true;
    }, [target, includeRoot, preventScroll, shouldFocus]);

    function _ref2() {
      didFocus.current = false;
      didFocusAfterEvent.current = false;
    }

    React.useEffect(function () {
      return _ref2;
    }, [shouldFocus]);
    useEvent(target, 'transitionend', function () {
      var element = target && 'current' in target ? target.current : target;
      if (!element || !shouldFocus || didFocusAfterEvent.current) return;
      var tabbableEls = tabbable(element, includeRoot);
      if (tabbableEls.length > 0) tabbableEls[0].focus({
        preventScroll: preventScroll
      });
      didFocusAfterEvent.current = true;
    });
  }

  var defaultOptions = {
    includeRoot: false,
    preventScroll: false
  };

  return useConditionalFocus;

})));
//# sourceMappingURL=use-conditional-focus.dev.js.map
