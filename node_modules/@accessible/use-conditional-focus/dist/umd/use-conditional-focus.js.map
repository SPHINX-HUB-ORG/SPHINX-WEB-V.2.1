{"version":3,"file":"use-conditional-focus.js","sources":["../../node_modules/@accessible/tabbable/src/index.ts","../../node_modules/@react-hook/passive-layout-effect/src/index.tsx","../../node_modules/@react-hook/latest/src/index.tsx","../../src/index.tsx","../../node_modules/@react-hook/event/src/index.tsx"],"sourcesContent":["// Credit:\n// https://github.com/davidtheclark/tabbable\nconst candidateSelector =\n  'input,select,textarea,a[href],button,[tabindex],' +\n  'audio[controls],video[controls],' +\n  '[contenteditable]:not([contenteditable=\"false\"])'\n\nexport interface Tabbables {\n  documentOrder: number\n  tabIndex: number\n  node: HTMLElement | HTMLInputElement\n}\n\nconst matches: Element['matches'] =\n  typeof Element === 'undefined'\n    ? () => false\n    : Element.prototype.matches ||\n      // @ts-ignore\n      Element.prototype.msMatchesSelector ||\n      Element.prototype.webkitMatchesSelector\n\nconst tabbable = (el: HTMLElement, includeRootNode = false): HTMLElement[] => {\n  const regularTabbables: HTMLElement[] = []\n  const orderedTabbables: Tabbables[] = []\n\n  let candidates: HTMLElement[] | NodeListOf<HTMLElement> = el.querySelectorAll(\n    candidateSelector\n  )\n\n  if (includeRootNode && matches.call(el, candidateSelector)) {\n    candidates = Array.prototype.slice.apply(candidates) as HTMLElement[]\n    candidates.unshift(el)\n  }\n\n  let i, candidate, candidateTabindex\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i]\n    if (!isNodeMatchingSelectorTabbable(candidate)) continue\n    candidateTabindex = getTabindex(candidate)\n\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate)\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      })\n    }\n  }\n\n  return orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map((a) => a.node)\n    .concat(regularTabbables)\n}\n\nconst isNodeMatchingSelectorTabbable = (node: HTMLElement) =>\n  !(\n    !isNodeMatchingSelectorFocusable(node) ||\n    (node.tagName === 'INPUT' &&\n      (node as HTMLInputElement).type === 'radio' &&\n      !isTabbableRadio(node as HTMLInputElement)) ||\n    getTabindex(node) < 0\n  )\n\nconst isNodeMatchingSelectorFocusable = (node: HTMLElement) =>\n  !(\n    (node as HTMLInputElement).disabled ||\n    (isInput(node) && (node as HTMLInputElement).type === 'hidden') ||\n    // offsetParent being null will allow detecting cases where an element\n    // is invisible or inside an invisible element,  as long as the element\n    // does not use position: fixed. For them, their visibility has to be\n    // checked directly as well.\n    node.offsetParent === null ||\n    getComputedStyle(node).visibility === 'hidden'\n  )\n\nconst getTabindex = (node: HTMLElement) => {\n  const tabindexAttr = parseInt(node.getAttribute('tabindex') || '', 10)\n  if (!isNaN(tabindexAttr)) return tabindexAttr\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (node.contentEditable === 'true') return 0\n  return node.tabIndex\n}\n\n// @ts-ignore\nconst sortOrderedTabbables = (a: Tabbables, b: Tabbables) =>\n  a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex\n\nconst isInput = (node: HTMLElement) => node.tagName === 'INPUT'\n\nconst isTabbableRadio = (node: HTMLInputElement) => {\n  if (!node.name) return true\n  // This won't account for the edge case where you have radio groups with the\n  // same in separate forms on the same page.\n  if (node.ownerDocument) {\n    const radioSet = node.ownerDocument.querySelectorAll(\n      'input[type=\"radio\"][name=\"' + node.name + '\"]'\n    )\n\n    for (let i = 0; i < radioSet.length; i++)\n      if ((radioSet[i] as HTMLInputElement).checked) return radioSet[i] === node\n\n    return true\n  }\n\n  return false\n}\n\nexport default tabbable\n","import * as React from 'react'\n\nconst usePassiveLayoutEffect =\n  React[\n    typeof document !== 'undefined' && document.createElement !== void 0\n      ? 'useLayoutEffect'\n      : 'useEffect'\n  ]\n\nexport default usePassiveLayoutEffect\n","import * as React from 'react'\n\nconst useLatest = <T extends any>(current: T) => {\n  const storedValue = React.useRef(current)\n  storedValue.current = current\n  return storedValue\n}\n\nexport default useLatest\n","import * as React from 'react'\nimport tabbable from '@accessible/tabbable'\nimport useEvent from '@react-hook/event'\n\nfunction useConditionalFocus<T extends Window>(\n  target: T | null,\n  shouldFocus?: boolean,\n  options?: UseConditionalFocusOptions\n): void\nfunction useConditionalFocus<T extends Document>(\n  target: T | null,\n  shouldFocus?: boolean,\n  options?: UseConditionalFocusOptions\n): void\nfunction useConditionalFocus<T extends HTMLElement>(\n  target: React.RefObject<T> | T | null,\n  shouldFocus?: boolean,\n  options?: UseConditionalFocusOptions\n): void\nfunction useConditionalFocus(\n  target: any,\n  shouldFocus = false,\n  {includeRoot, preventScroll} = defaultOptions\n) {\n  const didFocus = React.useRef(false)\n  const didFocusAfterEvent = React.useRef(false)\n\n  React.useEffect(() => {\n    const element = target && 'current' in target ? target.current : target\n    if (!element || !shouldFocus || didFocus.current) return\n    const tabbableEls = tabbable(element, includeRoot)\n    if (tabbableEls.length > 0) tabbableEls[0].focus({preventScroll})\n    didFocus.current = true\n  }, [target, includeRoot, preventScroll, shouldFocus])\n\n  React.useEffect(() => {\n    return () => {\n      didFocus.current = false\n      didFocusAfterEvent.current = false\n    }\n  }, [shouldFocus])\n\n  useEvent(target, 'transitionend', () => {\n    const element = target && 'current' in target ? target.current : target\n    if (!element || !shouldFocus || didFocusAfterEvent.current) return\n    const tabbableEls = tabbable(element, includeRoot)\n    if (tabbableEls.length > 0) tabbableEls[0].focus({preventScroll})\n    didFocusAfterEvent.current = true\n  })\n}\n\nconst defaultOptions: UseConditionalFocusOptions = {\n  includeRoot: false,\n  preventScroll: false,\n}\n\nexport type UseConditionalFocusOptions = {\n  includeRoot?: boolean\n  preventScroll?: boolean\n}\n\nexport default useConditionalFocus\n","import * as React from 'react'\nimport useLayoutEffect from '@react-hook/passive-layout-effect'\nimport useLatest from '@react-hook/latest'\n\nfunction useEvent<\n  T extends Window = Window,\n  K extends keyof WindowEventMap = keyof WindowEventMap\n>(\n  target: Window | null,\n  type: K,\n  listener: WindowEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent<\n  T extends Document = Document,\n  K extends keyof DocumentEventMap = keyof DocumentEventMap\n>(\n  target: Document | null,\n  type: K,\n  listener: DocumentEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent<\n  T extends HTMLElement = HTMLElement,\n  K extends keyof HTMLElementEventMap = keyof HTMLElementEventMap\n>(\n  target: React.RefObject<T> | T | null,\n  type: K,\n  listener: ElementEventListener<K>,\n  cleanup?: (...args: any[]) => void\n): void\nfunction useEvent(target: any, type: any, listener: any, cleanup: any): void {\n  const storedListener = useLatest(listener)\n  const storedCleanup = useLatest(cleanup)\n\n  useLayoutEffect(() => {\n    const targetEl = target && 'current' in target ? target.current : target\n    if (!targetEl) return\n\n    let didUnsubscribe = 0\n    function listener(this: any, ...args: any[]) {\n      if (didUnsubscribe) return\n      storedListener.current.apply(this, args)\n    }\n\n    targetEl.addEventListener(type, listener)\n    const cleanup = storedCleanup.current\n\n    return () => {\n      didUnsubscribe = 1\n      targetEl.removeEventListener(type, listener)\n      cleanup && cleanup()\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [target, type])\n}\n\nexport type ElementEventListener<\n  K extends keyof HTMLElementEventMap = keyof HTMLElementEventMap\n> = (this: HTMLElement, ev: HTMLElementEventMap[K]) => any\n\nexport type DocumentEventListener<\n  K extends keyof DocumentEventMap = keyof DocumentEventMap\n> = (this: Document, ev: DocumentEventMap[K]) => any\n\nexport type WindowEventListener<\n  K extends keyof WindowEventMap = keyof WindowEventMap\n> = (this: Document, ev: WindowEventMap[K]) => any\n\nexport default useEvent\n"],"names":["a","node","candidateSelector","matches","Element","prototype","msMatchesSelector","webkitMatchesSelector","tabbable","el","includeRootNode","i","candidate","candidateTabindex","regularTabbables","orderedTabbables","candidates","querySelectorAll","call","Array","slice","apply","unshift","length","isNodeMatchingSelectorTabbable","getTabindex","push","documentOrder","tabIndex","sort","sortOrderedTabbables","map","concat","isNodeMatchingSelectorFocusable","tagName","type","isTabbableRadio","disabled","isInput","offsetParent","getComputedStyle","visibility","tabindexAttr","parseInt","getAttribute","isNaN","contentEditable","b","name","ownerDocument","radioSet","checked","usePassiveLayoutEffect","React","document","createElement","useLatest","current","storedValue","defaultOptions","includeRoot","preventScroll","target","shouldFocus","didFocus","didFocusAfterEvent","element","tabbableEls","focus","listener","storedListener","storedCleanup","useEvent","useLayoutEffect","didUnsubscribe","args","this","targetEl","addEventListener","cleanup","removeEventListener"],"mappings":"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"}