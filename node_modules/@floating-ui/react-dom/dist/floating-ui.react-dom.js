(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@floating-ui/dom'), require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', '@floating-ui/dom', 'react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FloatingUIReactDOM = {}, global.FloatingUIDOM, global.React));
})(this, (function (exports, dom, react) { 'use strict';

  var index = typeof document !== 'undefined' ? react.useLayoutEffect : react.useEffect;

  /**
   * @see https://epicreact.dev/the-latest-ref-pattern-in-react/
   */

  function useLatestRef(value) {
    const ref = react.useRef(value);
    index(() => {
      ref.current = value;
    });
    return ref;
  }

  function useFloating(_temp) {
    let {
      middleware,
      placement,
      strategy
    } = _temp === void 0 ? {} : _temp;
    const reference = react.useRef(null);
    const floating = react.useRef(null);
    const [data, setData] = react.useState({
      // Setting these to `null` will allow the consumer to determine if
      // `computePosition()` has run yet
      x: null,
      y: null,
      strategy: strategy != null ? strategy : 'absolute',
      placement: 'bottom',
      middlewareData: {}
    }); // Memoize middleware internally, to remove the requirement of memoization by consumer

    const latestMiddleware = useLatestRef(middleware);
    const update = react.useCallback(() => {
      if (!reference.current || !floating.current) {
        return;
      }

      dom.computePosition(reference.current, floating.current, {
        middleware: latestMiddleware.current,
        placement,
        strategy
      }).then(setData);
    }, [latestMiddleware, placement, strategy]);
    index(update, [update]);
    const setReference = react.useCallback(node => {
      reference.current = node;
      update();
    }, [update]);
    const setFloating = react.useCallback(node => {
      floating.current = node;
      update();
    }, [update]);
    return react.useMemo(() => ({ ...data,
      update,
      reference: setReference,
      floating: setFloating,
      refs: {
        reference,
        floating
      }
    }), [data, update, setReference, setFloating]);
  }
  const arrow = _ref => {
    let {
      element,
      padding
    } = _ref;

    function isRef(value) {
      return Object.prototype.hasOwnProperty.call(value, 'current');
    }

    return {
      name: 'arrow',

      fn(args) {
        if (isRef(element)) {
          if (element.current != null) {
            return dom.arrow({
              element: element.current,
              padding
            }).fn(args);
          }

          return {};
        } else if (element) {
          return dom.arrow({
            element,
            padding
          }).fn(args);
        }

        return {};
      }

    };
  };

  Object.defineProperty(exports, 'autoPlacement', {
    enumerable: true,
    get: function () { return dom.autoPlacement; }
  });
  Object.defineProperty(exports, 'detectOverflow', {
    enumerable: true,
    get: function () { return dom.detectOverflow; }
  });
  Object.defineProperty(exports, 'flip', {
    enumerable: true,
    get: function () { return dom.flip; }
  });
  Object.defineProperty(exports, 'getScrollParents', {
    enumerable: true,
    get: function () { return dom.getScrollParents; }
  });
  Object.defineProperty(exports, 'hide', {
    enumerable: true,
    get: function () { return dom.hide; }
  });
  Object.defineProperty(exports, 'limitShift', {
    enumerable: true,
    get: function () { return dom.limitShift; }
  });
  Object.defineProperty(exports, 'offset', {
    enumerable: true,
    get: function () { return dom.offset; }
  });
  Object.defineProperty(exports, 'shift', {
    enumerable: true,
    get: function () { return dom.shift; }
  });
  Object.defineProperty(exports, 'size', {
    enumerable: true,
    get: function () { return dom.size; }
  });
  exports.arrow = arrow;
  exports.useFloating = useFloating;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
