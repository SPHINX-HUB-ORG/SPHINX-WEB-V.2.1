import { computePosition, arrow as arrow$1 } from '@floating-ui/dom';
export { autoPlacement, detectOverflow, flip, getScrollParents, hide, limitShift, offset, shift, size } from '@floating-ui/dom';
import { useLayoutEffect, useEffect, useRef, useState, useCallback, useMemo } from 'react';

var index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;

/**
 * @see https://epicreact.dev/the-latest-ref-pattern-in-react/
 */

function useLatestRef(value) {
  const ref = useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}

function useFloating(_temp) {
  let {
    middleware,
    placement,
    strategy
  } = _temp === void 0 ? {} : _temp;
  const reference = useRef(null);
  const floating = useRef(null);
  const [data, setData] = useState({
    // Setting these to `null` will allow the consumer to determine if
    // `computePosition()` has run yet
    x: null,
    y: null,
    strategy: strategy != null ? strategy : 'absolute',
    placement: 'bottom',
    middlewareData: {}
  }); // Memoize middleware internally, to remove the requirement of memoization by consumer

  const latestMiddleware = useLatestRef(middleware);
  const update = useCallback(() => {
    if (!reference.current || !floating.current) {
      return;
    }

    computePosition(reference.current, floating.current, {
      middleware: latestMiddleware.current,
      placement,
      strategy
    }).then(setData);
  }, [latestMiddleware, placement, strategy]);
  index(update, [update]);
  const setReference = useCallback(node => {
    reference.current = node;
    update();
  }, [update]);
  const setFloating = useCallback(node => {
    floating.current = node;
    update();
  }, [update]);
  return useMemo(() => ({ ...data,
    update,
    reference: setReference,
    floating: setFloating,
    refs: {
      reference,
      floating
    }
  }), [data, update, setReference, setFloating]);
}
const arrow = _ref => {
  let {
    element,
    padding
  } = _ref;

  function isRef(value) {
    return Object.prototype.hasOwnProperty.call(value, 'current');
  }

  return {
    name: 'arrow',

    fn(args) {
      if (isRef(element)) {
        if (element.current != null) {
          return arrow$1({
            element: element.current,
            padding
          }).fn(args);
        }

        return {};
      } else if (element) {
        return arrow$1({
          element,
          padding
        }).fn(args);
      }

      return {};
    }

  };
};

export { arrow, useFloating };
