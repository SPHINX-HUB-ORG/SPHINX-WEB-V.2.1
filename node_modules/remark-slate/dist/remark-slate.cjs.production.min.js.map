{"version":3,"file":"remark-slate.cjs.production.min.js","sources":["../src/deserialize.ts","../src/serialize.ts","../src/plugin.ts"],"sourcesContent":["export interface NodeTypes {\n  paragraph: string;\n  block_quote: string;\n  code_block: string;\n  link: string;\n  image: string;\n  ul_list: string;\n  ol_list: string;\n  listItem: string;\n  heading: {\n    1: string;\n    2: string;\n    3: string;\n    4: string;\n    5: string;\n    6: string;\n  };\n  emphasis_mark: string;\n  strong_mark: string;\n  delete_mark: string;\n  inline_code_mark: string;\n  thematic_break: string;\n}\n\ntype RecursivePartial<T> = {\n  [P in keyof T]?: RecursivePartial<T[P]>;\n};\n\nexport interface OptionType {\n  nodeTypes?: RecursivePartial<NodeTypes>;\n  linkDestinationKey?: string;\n  imageSourceKey?: string;\n  imageCaptionKey?: string;\n}\n\nexport interface MdastNode {\n  type?: string;\n  ordered?: boolean;\n  value?: string;\n  text?: string;\n  children?: Array<MdastNode>;\n  depth?: 1 | 2 | 3 | 4 | 5 | 6;\n  url?: string;\n  alt?: string;\n  lang?: string;\n  // mdast metadata\n  position?: any;\n  spread?: any;\n  checked?: any;\n  indent?: any;\n}\n\nexport const defaultNodeTypes: NodeTypes = {\n  paragraph: 'paragraph',\n  block_quote: 'block_quote',\n  code_block: 'code_block',\n  link: 'link',\n  ul_list: 'ul_list',\n  ol_list: 'ol_list',\n  listItem: 'list_item',\n  heading: {\n    1: 'heading_one',\n    2: 'heading_two',\n    3: 'heading_three',\n    4: 'heading_four',\n    5: 'heading_five',\n    6: 'heading_six',\n  },\n  emphasis_mark: 'italic',\n  strong_mark: 'bold',\n  delete_mark: 'strikeThrough',\n  inline_code_mark: 'code',\n  thematic_break: 'thematic_break',\n  image: 'image',\n};\n\nexport default function deserialize(node: MdastNode, opts?: OptionType) {\n  const types = {\n    ...defaultNodeTypes,\n    ...opts?.nodeTypes,\n    heading: {\n      ...defaultNodeTypes.heading,\n      ...opts?.nodeTypes?.heading,\n    },\n  };\n\n  const linkDestinationKey = opts?.linkDestinationKey ?? 'link';\n  const imageSourceKey = opts?.imageSourceKey ?? 'link';\n  const imageCaptionKey = opts?.imageCaptionKey ?? 'caption';\n\n  let children = [{ text: '' }];\n\n  if (\n    node.children &&\n    Array.isArray(node.children) &&\n    node.children.length > 0\n  ) {\n    // @ts-ignore\n    children = node.children.map((c: MdastNode) =>\n      deserialize(\n        {\n          ...c,\n          ordered: node.ordered || false,\n        },\n        opts\n      )\n    );\n  }\n\n  switch (node.type) {\n    case 'heading':\n      return { type: types.heading[node.depth || 1], children };\n    case 'list':\n      return { type: node.ordered ? types.ol_list : types.ul_list, children };\n    case 'listItem':\n      return { type: types.listItem, children };\n    case 'paragraph':\n      return { type: types.paragraph, children };\n    case 'link':\n      return { type: types.link, [linkDestinationKey]: node.url, children };\n    case 'image':\n      return {\n        type: types.image,\n        children: [{ text: '' }],\n        [imageSourceKey]: node.url,\n        [imageCaptionKey]: node.alt,\n      };\n    case 'blockquote':\n      return { type: types.block_quote, children };\n    case 'code':\n      return {\n        type: types.code_block,\n        language: node.lang,\n        children: [{ text: node.value }],\n      };\n\n    case 'html':\n      if (node.value?.includes('<br>')) {\n        return {\n          break: true,\n          type: types.paragraph,\n          children: [{ text: node.value?.replace(/<br>/g, '') || '' }],\n        };\n      }\n      return { type: 'paragraph', children: [{ text: node.value || '' }] };\n\n    case 'emphasis':\n      return {\n        [types.emphasis_mark]: true,\n        ...forceLeafNode(children),\n        ...persistLeafFormats(children),\n      };\n    case 'strong':\n      return {\n        [types.strong_mark]: true,\n        ...forceLeafNode(children),\n        ...persistLeafFormats(children),\n      };\n    case 'delete':\n      return {\n        [types.delete_mark]: true,\n        ...forceLeafNode(children),\n        ...persistLeafFormats(children),\n      };\n    case 'inlineCode':\n      return {\n        [types.inline_code_mark]: true,\n        text: node.value,\n        ...persistLeafFormats(children),\n      };\n    case 'thematicBreak':\n      return {\n        type: types.thematic_break,\n        children: [{ text: '' }],\n      };\n\n    case 'text':\n    default:\n      return { text: node.value || '' };\n  }\n}\n\nconst forceLeafNode = (children: Array<{ text?: string }>) => ({\n  text: children.map((k) => k?.text).join(''),\n});\n\n// This function is will take any unknown keys, and bring them up a level\n// allowing leaf nodes to have many different formats at once\n// for example, bold and italic on the same node\nfunction persistLeafFormats(children: Array<MdastNode>) {\n  return children.reduce((acc, node) => {\n    Object.keys(node).forEach(function (key) {\n      if (key === 'children' || key === 'type' || key === 'text') return;\n\n      // @ts-ignore\n      acc[key] = node[key];\n    });\n\n    return acc;\n  }, {});\n}\n","import escapeHtml from 'escape-html';\n\nimport { defaultNodeTypes, NodeTypes } from './deserialize';\n\nexport interface LeafType {\n  text: string;\n  strikeThrough?: boolean;\n  bold?: boolean;\n  italic?: boolean;\n  code?: boolean;\n  parentType?: string;\n}\n\nexport interface BlockType {\n  type: string;\n  parentType?: string;\n  link?: string;\n  caption?: string;\n  language?: string;\n  break?: boolean;\n  children: Array<BlockType | LeafType>;\n}\n\ninterface Options {\n  nodeTypes: NodeTypes;\n  listDepth?: number;\n  ignoreParagraphNewline?: boolean;\n}\n\nconst isLeafNode = (node: BlockType | LeafType): node is LeafType => {\n  return typeof (node as LeafType).text === 'string';\n};\n\nconst VOID_ELEMENTS: Array<keyof NodeTypes> = ['thematic_break'];\n\nconst BREAK_TAG = '<br>';\n\nexport default function serialize(\n  chunk: BlockType | LeafType,\n  opts: Options = { nodeTypes: defaultNodeTypes }\n) {\n  const {\n    nodeTypes: userNodeTypes = defaultNodeTypes,\n    ignoreParagraphNewline = false,\n    listDepth = 0,\n  } = opts;\n\n  let text = (chunk as LeafType).text || '';\n  let type = (chunk as BlockType).type || '';\n\n  const nodeTypes: NodeTypes = {\n    ...defaultNodeTypes,\n    ...userNodeTypes,\n    heading: {\n      ...defaultNodeTypes.heading,\n      ...userNodeTypes.heading,\n    },\n  };\n\n  const LIST_TYPES = [nodeTypes.ul_list, nodeTypes.ol_list];\n\n  let children = text;\n\n  if (!isLeafNode(chunk)) {\n    children = chunk.children\n      .map((c: BlockType | LeafType) => {\n        const isList = !isLeafNode(c)\n          ? LIST_TYPES.includes(c.type || '')\n          : false;\n\n        const selfIsList = LIST_TYPES.includes(chunk.type || '');\n\n        // Links can have the following shape\n        // In which case we don't want to surround\n        // with break tags\n        // {\n        //  type: 'paragraph',\n        //  children: [\n        //    { text: '' },\n        //    { type: 'link', children: [{ text: foo.com }]}\n        //    { text: '' }\n        //  ]\n        // }\n        let childrenHasLink = false;\n\n        if (!isLeafNode(chunk) && Array.isArray(chunk.children)) {\n          childrenHasLink = chunk.children.some(\n            (f) => !isLeafNode(f) && f.type === nodeTypes.link\n          );\n        }\n\n        return serialize(\n          { ...c, parentType: type },\n          {\n            nodeTypes,\n            // WOAH.\n            // what we're doing here is pretty tricky, it relates to the block below where\n            // we check for ignoreParagraphNewline and set type to paragraph.\n            // We want to strip out empty paragraphs sometimes, but other times we don't.\n            // If we're the descendant of a list, we know we don't want a bunch\n            // of whitespace. If we're parallel to a link we also don't want\n            // to respect neighboring paragraphs\n            ignoreParagraphNewline:\n              (ignoreParagraphNewline ||\n                isList ||\n                selfIsList ||\n                childrenHasLink) &&\n              // if we have c.break, never ignore empty paragraph new line\n              !(c as BlockType).break,\n\n            // track depth of nested lists so we can add proper spacing\n            listDepth: LIST_TYPES.includes((c as BlockType).type || '')\n              ? listDepth + 1\n              : listDepth,\n          }\n        );\n      })\n      .join('');\n  }\n\n  // This is pretty fragile code, check the long comment where we iterate over children\n  if (\n    !ignoreParagraphNewline &&\n    (text === '' || text === '\\n') &&\n    chunk.parentType === nodeTypes.paragraph\n  ) {\n    type = nodeTypes.paragraph;\n    children = BREAK_TAG;\n  }\n\n  if (children === '' && !VOID_ELEMENTS.find((k) => nodeTypes[k] === type))\n    return;\n\n  // Never allow decorating break tags with rich text formatting,\n  // this can malform generated markdown\n  // Also ensure we're only ever applying text formatting to leaf node\n  // level chunks, otherwise we can end up in a situation where\n  // we try applying formatting like to a node like this:\n  // \"Text foo bar **baz**\" resulting in \"**Text foo bar **baz****\"\n  // which is invalid markup and can mess everything up\n  if (children !== BREAK_TAG && isLeafNode(chunk)) {\n    if (chunk.strikeThrough && chunk.bold && chunk.italic) {\n      children = retainWhitespaceAndFormat(children, '~~***');\n    } else if (chunk.bold && chunk.italic) {\n      children = retainWhitespaceAndFormat(children, '***');\n    } else {\n      if (chunk.bold) {\n        children = retainWhitespaceAndFormat(children, '**');\n      }\n\n      if (chunk.italic) {\n        children = retainWhitespaceAndFormat(children, '_');\n      }\n\n      if (chunk.strikeThrough) {\n        children = retainWhitespaceAndFormat(children, '~~');\n      }\n\n      if (chunk.code) {\n        children = retainWhitespaceAndFormat(children, '`');\n      }\n    }\n  }\n\n  switch (type) {\n    case nodeTypes.heading[1]:\n      return `# ${children}\\n`;\n    case nodeTypes.heading[2]:\n      return `## ${children}\\n`;\n    case nodeTypes.heading[3]:\n      return `### ${children}\\n`;\n    case nodeTypes.heading[4]:\n      return `#### ${children}\\n`;\n    case nodeTypes.heading[5]:\n      return `##### ${children}\\n`;\n    case nodeTypes.heading[6]:\n      return `###### ${children}\\n`;\n\n    case nodeTypes.block_quote:\n      // For some reason, marked is parsing blockquotes w/ one new line\n      // as contiued blockquotes, so adding two new lines ensures that doesn't\n      // happen\n      return `> ${children}\\n\\n`;\n\n    case nodeTypes.code_block:\n      return `\\`\\`\\`${\n        (chunk as BlockType).language || ''\n      }\\n${children}\\n\\`\\`\\`\\n`;\n\n    case nodeTypes.link:\n      return `[${children}](${(chunk as BlockType).link || ''})`;\n    case nodeTypes.image:\n      return `![${(chunk as BlockType).caption}](${\n        (chunk as BlockType).link || ''\n      })`;\n\n    case nodeTypes.ul_list:\n    case nodeTypes.ol_list:\n      return `\\n${children}\\n`;\n\n    case nodeTypes.listItem:\n      const isOL = chunk && chunk.parentType === nodeTypes.ol_list;\n\n      let spacer = '';\n      for (let k = 0; listDepth > k; k++) {\n        if (isOL) {\n          // https://github.com/remarkjs/remark-react/issues/65\n          spacer += '   ';\n        } else {\n          spacer += '  ';\n        }\n      }\n      return `${spacer}${isOL ? '1.' : '-'} ${children}`;\n\n    case nodeTypes.paragraph:\n      return `${children}\\n`;\n\n    case nodeTypes.thematic_break:\n      return `---\\n`;\n\n    default:\n      return escapeHtml(children);\n  }\n}\n\n// This function handles the case of a string like this: \"   foo   \"\n// Where it would be invalid markdown to generate this: \"**   foo   **\"\n// We instead, want to trim the whitespace out, apply formatting, and then\n// bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\nfunction retainWhitespaceAndFormat(string: string, format: string) {\n  // we keep this for a comparison later\n  const frozenString = string.trim();\n\n  // children will be mutated\n  let children = frozenString;\n\n  // We reverse the right side formatting, to properly handle bold/italic and strikeThrough\n  // formats, so we can create ~~***FooBar***~~\n  const fullFormat = `${format}${children}${reverseStr(format)}`;\n\n  // This conditions accounts for no whitespace in our string\n  // if we don't have any, we can return early.\n  if (children.length === string.length) {\n    return fullFormat;\n  }\n\n  // if we do have whitespace, let's add our formatting around our trimmed string\n  // We reverse the right side formatting, to properly handle bold/italic and strikeThrough\n  // formats, so we can create ~~***FooBar***~~\n  const formattedString = format + children + reverseStr(format);\n\n  // and replace the non-whitespace content of the string\n  return string.replace(frozenString, formattedString);\n}\n\nconst reverseStr = (string: string) => string.split('').reverse().join('');\n","import transform, { OptionType, MdastNode } from './deserialize';\n\nexport default function plugin(opts?: OptionType) {\n  const compiler = (node: { children: Array<MdastNode> }) => {\n    return node.children.map((c) => transform(c, opts));\n  };\n\n  // @ts-ignore\n  this.Compiler = compiler;\n}\n"],"names":["defaultNodeTypes","paragraph","block_quote","code_block","link","ul_list","ol_list","listItem","heading","emphasis_mark","strong_mark","delete_mark","inline_code_mark","thematic_break","image","deserialize","node","opts","types","nodeTypes","_opts$nodeTypes","linkDestinationKey","imageSourceKey","imageCaptionKey","children","text","Array","isArray","length","map","c","ordered","type","depth","url","alt","language","lang","value","_node$value","includes","replace","forceLeafNode","persistLeafFormats","k","join","reduce","acc","Object","keys","forEach","key","isLeafNode","VOID_ELEMENTS","retainWhitespaceAndFormat","string","format","frozenString","trim","fullFormat","reverseStr","formattedString","split","reverse","Compiler","transform","serialize","chunk","userNodeTypes","ignoreParagraphNewline","listDepth","LIST_TYPES","isList","selfIsList","childrenHasLink","some","f","parentType","find","strikeThrough","bold","italic","code","caption","isOL","spacer","escapeHtml"],"mappings":"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"}